%In this section we discuss how import is encoded into session types, how processes in NomosUC use import, motivate our adaptation of import into \emph{import session types} (IST), and the relevant type rules for making judgements on polynomial time.
Import session types allow processes to send import to each other algonside messages like ITMs in UC, and concretizes the accounting of actual computation steps through a resource called \emph{potential}~\cite{das2018work,dasnomos}.
Recall that an ITM that possesses $n'$ net import (= import received - import sent) can do at most $T(n')$ computation for some polynomial $T$.
In NomosUC, we say that a process with $n'$ import posseses at most $T(n')$ potential.
When a process takes computation steps, it is bounded by the potential it possesses, and runtime in IST is checked against a user-defined polynomial provided as a parameter at comple-time.

Unlike import, potential is never exchanged between processes, but is generated by ``consuming'' import.
Generating potential creates a runtime budget for the process, affects the amount of import it has remaining (to send to another process), and makes explicit how much import has been ``consumed'' by the work already done.
For example, if a process with $n'$ import generates $X < T(n')$ potential, then it can send $k$ import to another process only if $X \leq T(n'-k)$.
%Generated potential creates a runtime budget for the calling process and affects the amount of import it has remaining and makes explicit how much import is ``consumed'' by the process: if a process $P$ with $n'$ tokens generates $X$ potential and performs work $X < T(n')$ it can only send $k$ import if $X \leq T(n'-k)$.
Concrete potential makes it possible to make a judgment about computation in the type system.

\paragraph{Why another resource?} 
%Why is it necessary to add another resource on top of import rather than directly account of runtime through import?
We first address the question of why another resource is needed to bound the execution of indivual processes rather than treating import as the direct accounting value.
%In general, an arbitrary mechanism for bounding runtime can be realized by a linear resource (like in Das et al.~\cite{das2018work}), but absracting runtime through a polynomial in import is critical and requires a separate resource to track work performed.
The motivation for not using import as the direct accounting resource is that it would greatly restrict for which protocols emulation is possible.
It is a requirement baked into import in UC \cite{canettiUC}, and we defer to the framework to motivate and explain it.
%In the general case of bounding runtime, a single linear resource is sufficient to control the runtime of processes (like the work by Das et al.~\cite{rast}), however, in UC we are concerned with capturing a realistic computation model and doing so leaks information that otherwise shouldn't be known. 
At a high level, using import as the direct accounting mechanism allows one ITM to precisely control the runtime budget of another, and it leads to problems in UC emulation.
First, \Z get use this power to distinguish the real and ideal worlds by their differences in run time: one world terminates while the other does not. 
In other words, it would constrain emulation to only real/ideal protocols that take \emph{exactly} the same number of steps.
Second, the runtime a receiving ITM needs is unknown to the sender apriori.
In \Fcom, for example, we require the sender to receive 1 import, despite \Fcom doing constant work, so that it can be realized by protocols that do non-constant work.
\footnote{The specific example given by Canetti~\cite{canettiUC}: ``For instance, the initial ITI $I$ can start in a rejecting state, and then pass control to another ITI $M$. If $I$ ever gets activated again, it moves to an accepting state. Whether $I$ is activated again depends on the running time of $M$. If it exceeds the computation given to it (known by $I$) then $I$ accepts depending on information that should not be ``legitimately known'' to $I$.}.
Furthermore, from a programming point of view, reusing definitions, session types, and code becomes difficult without carefully allocation runtime budget to each part of the protocol.

%The database functionality performs potentially quadratic work, in total, in the number of items stored (or, equivalently, in the number of activations): a sequence of $n$ inserts and queries results in $O(n^2)$ work iterating over $\ell$.
%In this section we introduce how processes like \Fdb receive and use import, motivate our design for adding import to NomosUC, and the relevant typing rules for making judgements on polynomial time.
%Specifically, we adapt import into session types and create \emph{import session types} (IST).
%IST allows processes to send each other import over channels and accounts for the number of computation steps a process can take through a resource called \emph{potential}~\cite{das2018work,dasnomos}.
%Recall that an ITM that possesses $n'$ net import (= import received - import sent) can do at most $T(n')$ computation for some polynomial $T$.
%In NomosUC, we say that such an ITM has at most $T(n')$ potential.
%Runtime in IST is checked against a concrete polynomial given as a parameter at compile time. 
%We account for the actual work performed by a process with \emph{potential} where every step costs 1 unit of potential.

%\paragraph{Why another resource?} 
%%Why is it necessary to add another resource on top of import rather than directly account of runtime through import?
%In general, an arbitrary mechanism for bounding runtime can be realized by a linear resource (like in Das et al.~\cite{das2018work}), but absracting runtime through a polynomial in import is critical and requires a separate resource to track work performed.
%This design is motivated by Canetti~\cite{canettiUC}.
%%In the general case of bounding runtime, a single linear resource is sufficient to control the runtime of processes (like the work by Das et al.~\cite{rast}), however, in UC we are concerned with capturing a realistic computation model and doing so leaks information that otherwise shouldn't be known. 
%At a high-level, using import as the the unit of computation allows an ITM to precisely control the runtime of an ITM it gives import to, giving it information about the other's state that, realistically, it shouldn't know.
%For example, imagine a real world and an ideal world where the environment uses import to control exactly the number of steps each world is can take.
%The differing ITMs will perform different work and terminate at different times, and \Z can use this information to artificially distinguish between them.
%\footnote{The specific example given by Canetti~\cite{canettiUC}: ``For instance, the initial ITI $I$ can start in a rejecting state, and then pass control to another ITI $M$. If $I$ ever gets activated again, it moves to an accepting state. Whether $I$ is activated again depends on the running time of $M$. If it exceeds the computation given to it (known by $I$) then $I$ accepts depending on information that should not be ``legitimately known'' to $I$.}.


\subsection{Giving Runtime To Processes}
We introduce two new type constructors to define the import sent with messages in IST: $\getpot$ and $\paypot$.
They are highlighted in red in the session types for \Fcom and \Fro in the previous section.
Canonically, the internal choice operator $\ichoice$ is paired with $\getpot$ and the external choice $\echoice$ with $\paypot$.

In the case of \Fcom, the sender must always send two import with label $\mb{commit}$ and none with $\mb{open}$.
Similarly, \Fcom sends one import to the receiver when sending label $\mb{committed}$ and none when sending $\mb{open}$.
%In UC, the adversary never receives any import from a functionality or protocol parties.

In the case of \Fro, over the course of its execution it must traverse a list per activation:
over $n$ activations it does $O(n^2)$ work.
Performing this necessitates that it always have net positive import, therefore its session type requires 1 import per activation and never gives any back.
%\Fcom, on the other hand, is one-shot and does constant work per activation. Yet, we still give it import so that a protocols that realizes it, with the same session type, isn't also restricted to constant work and can be arbitrarily complex.

%\input{figures/prot_com}

\paragraph{Exchanging Import in NomosUC}
In process code, the new type operators for import are paired with two operators in process code: \ipay and \iget.
The sender's code for the commit stage in Figure \ref{fig:protcom} we see the use of the two operators when it receives a message from \Z and when it sends a hash query to \Fro.
On line 4, the receiver receives the label from \Z and also ensures that it gets 2 units of import (denoted \texttt{\{K\}}.
There is an additional parameter to \iget (and \ipay), \texttt{K}, which is the \emph{token type being received}. 
It relates to the virtual token types we introduce shortly.
\todo{Fro here is also the channel}

%\subsection{Giving Import to \Fdb}
%Quadratic work over $n$ insertions and accesses to \Fdb, necessitates import linear in $n$.
%Therefore, we add an import requirement to the session types between \Fdb and the protocol parties (and \A).
%
%%We introduce \emph{import session types (IST)} to express and exchange import between processes. 
%%Unlike resource-aware session types, resource sent with import session types implies computation polynomial in the amount sent rather than linear. 
%We introduce two new type constructors:  $\getpot$ and $\paypot$.
%The \Fdb session type now becomes:
%\begin{tabbing}
%    $\mi{type} \; \m{db[k][v]} = \ichoice{$\=$\textcolor{red}{\paypot{1}}$\=$ \; \mb{store}:\m{PID} \arrow \m{k} \arrow$ \\
%    \>\>$\echoice{ \mb{OK}: \m{PID} \arrow \m{db[k][v]}},$ \\
%    \>$\textcolor{red}{\paypot{1}}$\=$ \; \mb{get}: \m{PID} \arrow \m{k} \arrow$ \\
%    \>\>$\echoice{$\=$\mb{yes}: \m{v} \arrow \m{db[k][v]},$ \\

%    \>\>\>$\mb{no}: \m{db[k][v]}}}$
%\end{tabbing}
%The calling party sends import using the $\paypot$ operator and \Fdb sends import using the $\getpot$ operator.
%In this case, the type enforces that 1 import token is sent when a party takes the $\ichoice$ and calls \Fdb, and \Fdb never sends any import back.
%\footnote{Rather than explicitly place a $\textcolor{red}{\getpot{0}}$ we omit the operator altogether.}
%This session type ensures \Fdb possesses $n$ import after $n$ activations. 

%In NomosUC process code, we introduce new operations to let processes exchange the import specified by the session type and use potential to account for the work done.
%The same \Fdb process code from Section~\ref{sec:example} is augmented with the commands \inline{$\nget$} and \inline{$\npay$} for sending/receiving import. 
%Below we show the case of \inline{store} in \Fdb and the corresponding party paying the import (lines 6 and 4, in \red{red}).
%\begin{lstlisting}[basicstyle=\scriptsize\BeraMonottFamily, frame=single, mathescape, numbers=left, xleftmargin=2em, xrightmargin=2em,firstnumber=3]
%$\tg{...}$
%$\ncase$ $\$$p2f (
%  store => pid,(k',v') = $\nrecv$ $\$$p2f
%    $\tr{get {1} \$p2f}$
%    $\ngenpot$(length l + 2)
%    $\ntick$(1)
%    $\$$tb' <- pappend[(k,v)] <- $\$$tb k' v' ;
%    $\ntick$(1)
%    $\$$p2f.Ok; $\nsend$ $\$$p2f pid ;
%    $\$$c $\leftarrow$ Fdb[k][v] <- $\tg{(* args *)}$ $\$$tb'
%$\tg{...}$
%\end{lstlisting}
%$\nproc$ Fdb[k][v]: ($\$$p2f: db[k][v]), ($\$$f2p: 1), 
%  ($\$$a2f: adv[k][v]), ($\$$f2a: 1), (l: [(k,v)]) |- ($\$$c: 1) =
%{

%    retrieve => pid,k' = $\nrecv$ $\$$p2f ;
%      $\tr{get {1} \$p2f}$
%      b $\leftarrow$ exist $\leftarrow$ $\$$tb k' ;
%      $\nif$ b $\nthen$
%        v' $\leftarrow$ get $\$$tb k' ;
%        $\$$p2f.yes; $\nsend$ $\$$p2f pid; $\nsend$ $\$$p2f v';
%      $\nelse$
%        $\$$p2f.no; $\nsend$ $\$$p2f pid ;
%      $\$$c $\leftarrow$ Fdb[k][v $\leftarrow$ $\tg{(* args *)}$ 
%\begin{lstlisting}[basicstyle=\scriptsize\BeraMonottFamily, frame=single, mathescape, numbers=left, xleftmargin=2em, xrightmargin=2em,firstnumber=4]
%$\$$p2f.store ; $\tr{pay {1} \$p2f}$
%$\nsend$ $\$$p2f pid ; 
%$\nsend$ $\$$p2f someK ; $\nsend$ $\$$p2f someV ;
%$\ncase$ $\$$p2f ( Ok => 1 )
%\end{lstlisting}
%$\nproc$ somparty[k][v]: (pid: PID), ($\$$p2f: db[k][v]), 
%  ($\$$f2p: 1)  |- ($\$$c: 1) =
%{
%}

%\subsection{Potential Mechanism}
%Import in UC allows for polynomial runtime, and, in a sense, import is \emph{consumed} when a computation is performed. 
%The UC security definition only cares that there is \emph{some} polynomial to bound an ITM's runtime.
%In NomosUC, we are explicit about the polynomial used, and type-checking a collection of processes relies on a concrete polynomial that runtime is checked agains.
%In order to actually account for runtime, another concrete value is needed: \emph{potential}.
%
%The potential mechanism directly determines how much import a process has actually consumed by measuring how much comutation it does and is still able to do.
%Specifically, we want to ensure the following situation is caught by NomosUC.
%Two processes $A$ and $B$ shouldn't be able to send 1 import back and forth and \emph{both} perform polynomial from that 1 token.
%
%For example, when a process $A$ sends import to another process, the type system must ensure
%that the computation already performed by $A$ is still polynomially bounded by the import remaining after sending import.
%In other words, two processes $A$ and $B$ shouldn't be able to send 1 import back and forth and perform polynomial from that 1 token.
%$A$ performing a polynomial computation with the single import and sending it to $B$ should fail to type check. 
%Potential is related to import by the following statement: if a process
%possesses $n`$ net import then it has potential of $T(n')$, and it can not take more than $T(n')$ computational steps.
%Potential is never exchanged between processes and is checked in relation to the net import a process has. If a process performs 
%$X < T(n)$ steps and sends an import to another process such that $X > T(n-1)$, NomosUC fails to type-check the process (we leave all typing rules to the end of the section).

\paragraph{Potential}
NomosUC processes must be explicity about how much potential they use through two new keywords: \inline{$\ngenpot$} and \inline{$\ntick$}.
%A UC proof on paper can theoretically reason about the execution of a ITM, but we require a concrete accounting mechanism for doing the same for NomosUC processes. 
The type system tracks the cumulative and current potentials, $q$ and $q'$, for every process.
To perform $r$ work, a process must first generate \inline{$\ngenpot$(r)} potential resultin in $q+r$ and $q'+r$ total and curernt potential (line 9).
The process takes $x$ steps and deducts \inline{$\ntick$(x)} potential resulting in $q'+r-x$ current potential.
Rather than force it manually, NomosUC can be instrumented to insert a \tick before every operation performed.
%The typing rules at the end of the section use $q$ and $q'$ to judge \emph{valid} NomosUC processes.
%The function call to \inline{pappend} performs \itick operations, but the calling process generates the potential.
%Therefore, conservatively, \Fdb generates enough potential to expend unit cost for accessing each item in the list (line 4).
%In this code section, we rely on \inline{pappend} to execute \inline{$\ntick$} operations of it own, and \Fdb and deducts potential before performing a message send back to the party (line 7).
%\begin{lstlisting}[basicstyle=\scriptsize\BeraMonottFamily, frame=single, mathescape, numbers=left, xleftmargin=2em, xrightmargin=2em]
%$\tg{...}$
%$\ncase$ $\$$p2f (
%  store => pid,(k',v') = $\nrecv$ $\$$p2f
%    $\tr{get {1} \$p2f}$
%    $\ngenpot$(length l)
%    $\$$tb' <- pappend[(k,v)] <- $\$$tb k' v' ;
%    $\ntick$(1)
%    $\$$p2f.Ok; $\nsend$ $\$$p2f pid ;
%    $\$$c $\leftarrow$ Fdb[k][v] <- $\tg{(* args *)}$ $\$$tb'
%$\tg{...}$
%\end{lstlisting}
%Additionaly, abstracting import into a sub-resource called potential makes the UC framework all the more expressive.
%If import was used to count and bound computation directly, rather than through a polynomial, the \Fdb example becomes untennable. 
%A party querying \Fdb has to know how long the list is so it sends enough import to iterate over it, and it doesn't know how many items other parties may have added.
%This leads to a bizarre setting where parties must attempt to learn information about the list size or keep trying higher increments of import to complete a query.
%Constraining runtime in this way makes the framework unnecessarily cumbersome.

%Imagine the database session type specified 1 import token is exchanged in both directions: 1 token from parties when querying and 1 token back from \Fdb with the result. 
%Without a concrete resource to track the actual com
%For example, without the potential mechanism the following processes set would type check but obviously violates the rules of import. 
%
%\begin{tabbing}
%   $\mi{type} \; \m{atob} = \ichoice{\textcolor{red}{\paypot{1}} \; \mb{give}: \echoice{\textcolor{red}{\getpot{1}} \; \mb{receive}: \m{atob}}}$
%\end{tabbing}
%
%\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single]
%$\nproc$ A : (bigNumr: Int), ($\$$a2b: atob) |- ($\$$ch: 1) = {
%  $\text{\color{Red}{genPot k}}$
%  let bigNum = bigNum * 2 ;
%  $\$$a2b.give; $\npay$ {1} $\$$a2b ;
%  $\ncase$ $\$$a2b ( receive => $\nget$ {1} $\$$a2v )
%  $\$$ch <- A bigNum $\$$a2b ;
%}
%
%$\nproc$ B : (bigNum: Int), ($\$$a2b: atob) |- ($\$$ch: 1) = {
%  $\ncase$ $\$$a2b (
%    give => $\nget$ {1} $\$$a2b ;
%      $\text{\color{Red}{genPot k}}$
%      $\nlet$ bigNum = bigNum * 2 ;
%      $\$$a2b.receive ; $\npay$ {1} $\$$a2b ;
%      $\$$ch <- B <- bigNum $\$$a2b ;
%  )
%}
%\end{lstlisting}
%
%Without additional rules for accounting for potential (lines 2 and 12), and \emph{consuming} import, the above system would violate the basic import mechanism as defined by UC.

%Furthermore, abstracting potential from import has the added benefit of a more expressive framework.
%Take the database ideal functionality below as an example. 
%When a party performs a read, it doesn't know the size of the list before-hand. 
%Using only import as the accounting for computation, the protocol party would always have to give a precise amount of import to ensure the whole list can be read. 
%With potential, a single unit of import is enough for the functionality to determine how much polynomial computation (in this case, linear) needs to be done.  
%
%\begin{tabbing}
%   $\mi{type} \; \m{db[k][v]} = \ichoice{$\=$\textcolor{red}{\paypot{1}}$\=$ \; \mb{store}:\m{PID} \arrow \m{k} \arrow$ \\
%   \>\>$\echoice{ \mb{OK}: \m{PID} \arrow \m{db[k][v]}},$ \\
%   \>$\textcolor{red}{\paypot{1}}$\=$ \; \mb{get}: \m{PID} \arrow \m{k} \arrow$ \\
%   \>\>$\echoice{$\=$\mb{yes}: \m{v} \arrow \m{db[k][v]},$ \\
%   \>\>\>$\mb{no}: \m{db[k][v]}}}$
%\end{tabbing}
%
%\todo{fdatabase is nontrivial, how much of it to include? maybe only where it iterates over the list and generates n potential to do it}
%\begin{bbox}[title={Functionality $\F_{\msf{db}}$}]
%
%Initialize list $l := []$
%
%\OnInput \inmsg{add}{$x$} form $P_i$:
%   \begin{ritemize}
%       \item Append $x$ to $\ell$
%       \item \Send $ok \rightarrow P_i$
%   \end{ritemize}
%
%\OnInput \inmsg{get}from $P_i$:
%   \begin{ritemize}
%       \item \Send $\ell \rightarrow P_i$
%   \end{ritemize}
%\end{bbox}

\subsection{Virtual Tokens}
An crucial part of UC simulator proofs is ITMs sandboxing other ITMs, i.e. a
``host ITM'' runs another ITM's code internally as its own.  Recall that cost
analysis in UC treats the sandboxed ITM as any other code in the body of the
host that doesn't have its own standlone import or potential.  Similarly, we
want to enable the same NomosUC process definition to be run generically in a
sandbox, and still satisfy the import requirements in its type, while our cost
analysis considers it as a part of the host process.  Simulators, in
particular, rely on this design pattern to emulate real-world protocols, rewind
them, replay them, and override their randomness.  The design of NomosUC, up to
now, would require an existing NomosUC process to be reimplemented as part of a
host's code, to ensure cost analysis works as desired, rather than allow
process definitions to be reused in arbitary settings.

\paragraph{A Concrete Example of the Constraint}
The ideal world simulator, designed w.r.t. a specific real world adverasry, is
given the same amount of import, and so forcing a simulator to run the real
world as ``main'', or ``real'', processes, requiring their own import, severely
limits its own ability to perform any computation.  The notion of wasted import
is clear and intuitive especially in case where a particular environment's
inputs result in the real world only needing to peform constant work, and their
types require net positive import because they \emph{could} do up to $O(n^2)$
work.

Imagine a real world functionality $\F_\m{real}$ that requires 1 import from
\A, and an ideal world functionality $\F_\m{ideal}$ that requires one import
from the simulator \Sim.  Consider a real world adverasary \A whose type
requires 2 import with input from \Z: one that it uses for input to
$\F_\m{real}$ and one it uses to perform some polynomial computation
internally.  The simulator \Sim in the ideal world, running a copy of
$\F_\m{real}$, gets the same 2 import from \Z.  \Sim uses 1 of its import for
input to $\F_\m{ideal}$, and, if $\F_\m{real}$ is run as a ``main'' process, it
has to use its other import to run it and observe its output.  It now has no
import left for any other meaningful computation such as simulating the same
computation performed by \A.  This simple example is representative of the
kinds of simulation proofs that are common in UC, and without some notion of
``fake'' import or potential that allows $\F_\m{real}$ to do its work,
programming with NomosUC becomes far more cumbersome.

% \Z must give \Sim in the ideal world, running a copy of $\F_\m{read}$, the same import as \A.
% If it must use one import to run $\F_\m{real}$ and one import for input to $\F_\m{ideal}$, it's left with no import and can only do constant work over the course of the execution.
% Though contrite, this example is representative of the issue of differentiating regular processes from ``sandboxed'' processes.
% Forcing a process to give up whole import (the source of computation) for a process it wants to simulate internally, rather than only expending the required potential (actual computation), significantly constrains NomosUC.
% 
% A simulator for \protcom is straightforward but elucidates and highlights additional design challenges necessary to overcome.
% We focus on the case of the corrupt sender and include the full simulator in Appendix~\ref{app:commitment}.
% 
% The simulator for \protcom is defined for the dummy adversary in the real worls, and wants to run simulate the real world in a sanboxed environment. 
% $\Sim_\m{com}$, and many other simulators, do this to ensure that the ideal world outputs and outcome mimic the real world.
% For example, the $\Sim_\m{com}$ must ensure the ideal world receiver outputs to the environment at the same time, and that the environment receives the same messages from the corrupt parties at the same time.
% Specifically, $\Sim_\m{com}$ runs \Fro internally, to handle requests by \Z to hash all while reading its state and learning the preimages of commitments when the sender is corrupt.
% In UC, the simulator internally executes \Fro on its tape and performs the same steps it would, and the work performed is counted toward as potential being consumed with the import the simulator possesses.
% 
% The simulator process's type is define simply as follows where we omit the common arguments to all processes. 
% \begin{lstlisting}[basicstyle=\scriptsize\BeraMonottFamily, mathescape, frame=single, numbers=left, xleftmargin=2em, xrightmargin=0em]
% $\nproc$ sim_com[K][K1] : $\tg{(* standard args *)}$ 
%   ($\$$z2a: Z2A[K][rop2f[commsg][roa2f]{1}), 
%   ($\$$a2z: A2Z[K][ro2fp[commsg][rof2a]{0}),
%   $\tg{(* other channels removed for brevity *)}$ = {
% \end{lstlisting}
% The simulator presents an interface to \Z that mimics the real world with \Fro, and it communicates with the corrupt sender and \Fcom through their respective types for channels \ic{a2p} and \ic{a2f}.
% \todo{something else here?}


% \paragraph*{\textbf{A Constraint Unique to NomosUC}}
% %Simulators in UC often run other ITMs internally in a black-box manner. 
% Doing the same in NomosUC with processes comes with the added constraint of satisfying the import requirement of the simulated process's session type.
% %Suppose a simulator \Sim that sandboxes \Fro internally. 
% Ideally, we want that the computation done by \Fro counts towards the total work performed by \Sim rather that requiring import of its own like its session type requires.
% Unless there is a way to give \Fro some ``fake'' import, simulators must, effectively, waste import simulating the real world rather use only the precise potential required to perform that same computatiuon.
% Spending potential on simulation is expected behavior, but spending import on simulation is depriving the simulator of far more computation than it should.
% This constrains the kind of simulator proofs that can be constructed, because they must contend with less import by the definition of NomosUC.
% We describe it in a more generic example.
% 
% Imagine a real world functionality $\F_\m{real}$ that requires one import from \A, and an ideal world functionality $\F_\m{ideal}$ that requires one import from \Sim.
% \Z activates \A with 2 import. One of which it uses for $\F_\m{real}$ and one it uses to perform some polynomial work.
% \Z must give \Sim in the ideal world, running a copy of $\F_\m{read}$, the same import as \A.
% If it must use one import to run $\F_\m{real}$ and one import for input to $\F_\m{ideal}$, it's left with no import and can only do constant work over the course of the execution.
% Though contrite, this example is representative of the issue of differentiating regular processes from ``sandboxed'' processes.
% Forcing a process to give up whole import (the source of computation) for a process it wants to simulate internally, rather than only expending the required potential (actual computation), significantly constrains NomosUC.

% Imagine an adversary in the real world that accepts one unit of import and uses it to query \Fro.
% The ideal world simulator is given the same single unit of import as the real world adversary, by definition, and if it must expend it to sandbox \Fro then it's left with no import to do anything else.
% This issue is further exacerbated when you consider \Sim simulating the entire real-world execution. All of its import budget is used up running the same processes as the real world rather than the sandbox counting toward its total potential budget.
% More generally, an ideal functionality in the real world, whose output depends on the amount of computation it's able to do, must perform exactly the same work when run by \Sim in order to produce the same output.
% Therefore, we formulate a mechanism to create \emph{virtual tokens} to give to sandboxed processes that satisfy its import requirements while still only counting towards the total work done by \Sim.
% Though a simple concept, realizing this in our typing rules is major contribution of this work.
% \todo{Perhaps a good way to frame it is saying that the work \Sim could otherwise do with only 1 import (sandboxing + other stuff) it now needs 2 import to do. When \Sim needs to spend import in the ideal world as well, liek interacting with the ideal functuionality it is one short and show all definitioons hafve to change to accomodate this.}

%In the ITM model, in UC, a simulator, \Sim, sandboxing \Fdb has the ITM encoded on its own tape allowing it to arbitrarily manipulate its state and execute it as necessary.
%Therefore, the computaton that \Sim and the sandboxed \Fdb perform are counted as part of \emph{the same ITM}.
%In NomosUC, there is no notion of encoding \Fdb within \Sim without rewriting its code.
%Reusing \Fdb then means treating it as \emph{a separate process}, which is undesirable.
%%In NomosUC, running \Fdb in a similar way mean reimplementing the functionality as part of the process code of \Sim. Reusing the \Fdb process means \emph{it must be treated as a separate process} 
%%%barring reimplementing the functionality as part of the code of \S, \emph{it is must be treated as a separate process} 
%%with a session type \m{db[k][v]} which requires one import sent with every message.
%In the listing below, the simulator wants to run a copy of \Fdb and communicates with it over a channel \ic{fdb} (line 5). 
%\Z gives both the dummy adversary, \DA, and \Sim a message with 1 import (line 9) intended for \Fdb in the real world, and like \DA, \Sim calls \Fdb (line 12) with 1 unit of import due to its type \m{db[k][v]} (line 13).
%%\Sim relies on the existing process to emulate the outputs \Z would see in the real world communicating with the dummy adverasry and \Fdb.
%%On line 9, \Sim gets 1 unit of import from \Z, the same the \DA gets in the real-world, and on line 13 it's forced to give it up to make the call to \Fdb and not do any polynomial work itself.
%Without giving the import, \Sim would fail to type-check, but in doing so is forced to give up its own import.
%
%More generally, a functionality in the real world, whose output depends on the amount of computation it's able to do, must do exactly the same work when run by \Sim to produce the same output.
%In the real world the dummy adversary, \DA, receiving $X$ import from \Z gives all $X$ to \F and doesn't do any other work.
%In the ideal world, \Sim runs the the real-world internally, receives the same $X$ import as \DA, and must give \F all $X$ import to ensure the same output is produced. 
%It is therefore forced to give up it's entire runtime budget, just as \DA does, and therefore can't do any additional polynomial work of its own (line 18).

%Ultimately, simply running \Fdb as a separate process constrains the kinds of simulators (and so proofs) that can be realized, and if we want our cost analysis to treat \Fdb and \Sim as one and the same, a few important questions are raised:
%does \Sim lose import and \Fdb gains import? do they both share the same import because \Fdb is sandboxed? can we tell the type system to ignore import in IST in some cases?
%
%\begin{lstlisting}[basicstyle=\scriptsize\BeraMonottFamily, frame=single, mathescape, numbers=left, xleftmargin=2em, xrightmargin=2em]
%$\nproc$ sim_db[k][v] : 
%  $\tg{(* the usual params *)}$
%  ($\$$z2a: Z2A[a2p,a2f]), ($\$$a2z: A2Z[p2a,f2a]),
%  ($\$$p2a: a2p), ($\$$f2a: f2a),
%  ($\$$fdb: db[k][v]) $\tg{(*...*)}$ |- ($\$$c: 1) =
%{
% $\nmatch$ $\$$z2a,$\$$p2a,$\$$f2a (
%    Z2A2F,*,* =>
%      $\nget$ {1} $\$$z2a
%      msg = $\nrecv$ $\$$z2a
%      $\ncase$ msg (
%        Query(k) => $\$$db.query
%          $\npay$ {1} $\$$db
%          $\nsend$ $\$$db k
%          $\ncase$ $\$$db (
%            yes => v = $\nrecv$ $\$$db 
%            _ => ()
%          x $\leftarrow$ do_poly_work ;
%  $\tg{.....}$
%\end{lstlisting}
%        Store(k,v) => $\$$db.store
%          $\npay$ {1} $\$$db
%          $\nsend$ $\$$db k ; $\nsend$ $\$$db v
%          $\ncase$ $\$$db ( Ok => 
%            x $\leftarrow$ do_poly_work ;
%            $\$$c <- sim_db[k][v] $\tg{(* args *)}$ )
%}


%% | describe the a simulated \Fdb now without virtual tokens and showcase the issue
%% | and we need to be able to reuse process definitions rather than make special virtual one
The approach we take is to allow creation of ``fake tokens'', called
\emph{virtual import tokens}, and make all processes parameteric in the token
type. In the scope of each process, its parameters specify what it consideres
its native (or ``real'') token type $K_i$ and its fake token type $K_{i+1}$ to be used for
sandboxing.  We tie the amount of virtual import created to the real import
that the calling process holds.  Token types are represented by a token
hierarchy 
\vspace{-0.5em}
\begin{mathpar}
  \mi{token types\;}\;\K_0 \to \K_1 \to ... \to \K_m
  \vspace{-0.5em}
\end{mathpar}
Where $\K_0$ are real import tokens and $\K_{i>0}$ are all virtual.  The
heirarchy is a global definition used by all processes, and the number of
levels $m$ in the heirarchy is fixed, at compile-time, and limits the depth of
sandboxes within sandboxes.  It is statically defined to prevent infinite type
creation at runtime, and the loss of expressivity is insignificant.  Process
definitions all include a type parameter \inline{K}, which is their ``real
token type'' (seen in the definition of \m{protcom} above).  The main processes
in the execution, such as \Z and \A, are obviously spawned with parameter $K_0$
and all sandboxed processes are spawned with $K_{i > 0}$.  Defining different
token types also creates additional useful guard rails for sandboxed programs:
they can't communicate with process outside the sandbox, because the type
system enforces matching token types.

%\plan{There used to be a code snippet here showing a process definition with the toke type paramter but it's useless we just point to the process definition of procom above}
%For example, the simulator above is now given the parameter $K_0$ (for real), and type $K_1$ as the virtual type to sandbox with:
%\begin{lstlisting}[basicstyle=\scriptsize\BeraMonottFamily, frame=single, mathescape, numbers=left, xleftmargin=2em, xrightmargin=2em]
%$\$$c $\leftarrow$ sim_db$\tr{[K0,K1]}$[k][v] $\tg{(* the usual params *)}$
%            $\tr{\^{}\^{}\^{}\^{}\^{}\^{}}$
%  ($\$$z2a: Z2A[a2p,a2f]), ($\$$a2z: A2Z[p2a,f2a]),
%  ($\$$p2a: a2p), ($\$$f2a: f2a) $\tg{...}$
%\end{lstlisting}
%The simulator, in turn, spawns an instance of \Fdb with a with  virtual token type, $K_1$ that \Fdb considers real tokens:
%\begin{lstlisting}[basicstyle=\scriptsize\BeraMonottFamily, frame=single, mathescape, numbers=left, xleftmargin=2em, xrightmargin=2em]
%$\$$fdb $\leftarrow$ Fdb$\tr{[K1]}$[k][v] $\leftarrow$ $\tg{...}$
%\end{lstlisting}

\begin{figure*}
\input{figures/sim_com}
\caption{The simulator for the corrupt sender, intercepting and replaying hash queries in its sandboxed \Fro.}
\label{fig:simcom}
\end{figure*}

The remainder of this section introduces the creation and handling virtual
tokens in NomosUC process code.  We provide the important parts of a simulator
\simcom's code for the corrupt sender's case, in protocol \protcom, in Figure
\ref{fig:sim_com} and use it as the illustrating example.  The typing rules and
judgements for NomosUC and IST are given in the next section (Section
\ref{sec:safety}).

\paragraph{Creating Virtual Import}
NomosUC processes create virtual tokens by withdrawing them from their real
token type.  The operator \inline{$\nwithdraw\ $ K0 K1 n} allows a process,
using its real token type $K_0$, to create $n$ new tokens of type $K_1$.  The
second parameter to $\npay$ and $\nget$, ignored in the previous section,
specifies the token type being sent or received so that a process $P$ can spawn
another process $P'$ with a virtual token type $K_1$ and pay/receive virtual
tokens to/from it.  The random oracle \Fro is created in a sandbox in Figure
\ref{fig:simom}, beacuse \simcom initializes it with a virtual token type $K_1$
(line 7). \todo{not shown in the code!!} When receiving a hash query from \Z,
\simcom, holding 0 virtual tokens, must first create the necessary virtual
tokens before querying a hash from \Fro (line 12).  On a reply from \Fro,
\simcom sends the result back to \Z just as the dummy adversary would.  The
virtual tokens satisfy the type of \Fro, because it considers these its
``real'' token type, and the work performed when it generates potential will be
counted towards the totel work allowed by the import held by \simcom
(formalized in Section \ref{sec:safety}).
%When communicating with augmented \Fdb (above), \Sim (below) first creates the virtual tokens (line 5) and then sends them on the channel (line 6).
%Trying to give a type $K_i$ to a process whose real token type is some $K_{j \neq i}$ fails to type-check for obvious reasons.
%\begin{lstlisting}[basicstyle=\scriptsize\BeraMonottFamily, frame=single, mathescape, numbers=left, xleftmargin=2em, xrightmargin=2em]
%$\nget$ {1} $\$$z2a
%msg = $\nrecv$ $\$$z2a
%$\ncase$ msg (
%  Query(k) => 
%    $\nwithdraw$ K0 K1 1
%    $\$$db.query
%    $\npay$ $\tm{K1}$ {1} $\$$db
%    $\nsend$ $\$$db k
%    $\ncase$ $\$$db (
%      yes => v = $\nrecv$ $\$$db 
%      _ => )
%    x $\leftarrow$ do_poly_work ;
%\end{lstlisting}

\paragraph{Relating virtual tokens to real work.}
%Without relating virtual tokens to the amount of import that the sanboxing process has, we encounter an infinite runs problem where processes can continue to create virtual tokens and processes to perform super-polynomial work.
% Intuitively, the number of virtual tokens created should be tied to the total runtime budget of the sandboxing process to prevent an infinite runs problem.
The number of virtual tokens created are bounded through a globally known
polynomial \GlobalF defined at compile-time.  The type system requires that the
virtual tokens of type $i+1$ (denoted $t_{i+1}$) created by a process $P_i$ are
upper bounded by $\GlobalF(t_i, k)$ where $t_i$ is the amount $P_i$'s tokens
that are of its native token type and $k$ is the UC security parameter.  Nested
sandboxing creates nested polynomials constraining virtual tokens created in
each layer by the tokens held in the layer above.  We also emphasize that
processes can not create virtual tokens indefinitely, because
\inline{$\nwithdraw$} expends potential like any other operation.  The type
system only compares the potential create/used by a process to a polynomial
\emph{in that process's native token type}.  In the next section, we clarify
how the type system determines whether a process satisfies it's runtime budget.

%Our treatment of virtual tokens bounded by a polynomial in the import a process has appears, on the surface to be identical to how we treat potential.
%A natural counter-point may be to treat potential as another virtual token in the heirarchy: make the last token in the heirarchy the potential.
%\todo{i don't know if i have a good answer for this other than it's easier. tokens don't know how deep the virtual tokens go. you can define one token type that everyone knows as potential but then there isn't really that much of a difference with that versus treating it differently. we want only one potential type to be used for compuation cost regadless of the token type of the process using it.}

%% | we need a different kind of virtual import to give to \Fb to satisfy its type and make the type system happy

%% | the keywords to create virtua tokens

%% | how do we make sure they don't exceed the polynomial constraints of the calling process?

%\subsection{Typing Rules for Import and NomosUC}

\paragraph{Completing the Commitment Proof} 
\plan{We want to highlight the compositional use of commitment, so we want to get \simcom out of the way NOW, but this paragraph seems out of place. Where to put it to finish explaining the simple simulator for commitment?}
The simulator in Figure~\ref{fig:simcom} runs the ideal hash function
internally, and waits until \Z tries to commit something to the receiver.  When
it does so, if the commitment and its preimage exist in \Fro (line 20-21) then
it commits to the bit with the ideal world sender, otherwise the environment is
commiting to value that the honest receiver rejects in the real world and
arbitrarily commits to bit zero, instead.  The receiver case is much simpler,
and we push it into the appendix, because \simcom can assign any hash value to
the committed bit send to the corrupt receiver by \Fcom. 

