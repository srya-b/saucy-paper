Universal Composability (UC)~\cite{canettiUC} is the leading framework for defining security properties of cryptographic protocols.
It is considered the strongest definitional model since it guarantees the security properties even when the protocol is arbitrarily composed with
multiple concurrently-executing sessions of the same (or another) protocol.
UC has recently gained popularity for analysis of cryptographic protocols due to its \emph{ideal world/real world} simulation mechanism.
In contrast to game-based cryptography where security properties are defined via attack games,
UC defines an \emph{ideal functionality} for a protocol, i.e., a program that serves as the protocol \emph{specification}.
When executed by a trusted third party that communicates over secure channels, the ideal functionality exhibits all possible behaviors of the protocol.
Thus, a protocol without access to a trusted third-party \emph{emulates} its functionality (with access to a trusted third-party),
being completely indistinguishable to an external environment.
When analyzing \emph{composition} of protocols, we only need analyze the composition of their ideal functionalities, thus greatly
simplifying the analysis!
UC also encourages a modular design of protocols which can then be composed into larger applications by applying generic composition operators
provided by UC and their associated theorems.

Despite UC's appeal, programming language tools and techniques for establishing UC emulation are fairly limited with some recent efforts providing
partial support~\cite{ilc,easyuc,ipdl,symbolicuc,barbosa}. This is a result of two key challenges.
First, at the core of UC lies demonstrating emulation which relies on proving program equivalence and is undecidable in general
and tends to be complicated even for simple programs.
Moreover, UC emulation requires designing a simulator generator such that \emph{for all} adversaries, \emph{there exists} a simulator (that is constructed
from the simulator generator) that emulates the protocol \emph{for all} environments.
This sequence of $\forall \exists \forall$ quantifiers complicates proving equivalence even further, especially when the adversary and simulator can exhibit
probabilistic behavior.
The second major challenge is \emph{execution cost} which plays a central role in UC since the security properties
guaranteed by UC only hold in the presence of polynomial-time bounded adveraries.
More formally, we need to prove that the simulator, which usually depends on the adversary actions, is \emph{PPT} (probabilistic polynomial time)
if the adversary is PPT.
Statically proving this PPT requirement calls for devising techniques for bounding the execution cost of UC Interactive Turing Machines (ITMs),
which is also an undecidable problem in general.
Most prior UC formalization efforts like EasyUC and ILC forego the polynomial runtime analysis entirely, while others~\cite{ipdl,barbosa,ilc}
express polynomial runtime constraints but only consider restricted subsets of the UC framework where, for example, the number of parties
or subsessions is statically bounded rather than determined at runtime by an arbitrary environment.

UC protocols and functionalities are expressed via Interactive Turing Machines that (i) communicate via \emph{message tapes} that ITMs can read from/write to,
and (ii) are polynomial-bounded, both in their communication and computation.
Noteworthy here is that ITMs involved in a UC protocol and its corresponding functionality exhibit the \emph{same} communication behavior even though their
their internal computation is different.
Further, ITM execution is restricted to polynomial-time using an \emph{import mechanism} where each message includes a special $\mathsf{import}$
field represented using a natural number.
The run-time budget of an ITM is then defined as a polynomial in the import contained in an ITM, i.e., sum of import received minus
sum of import sent.

Recognizing this polynomially bounded interactive nature, we propose a novel abstraction to statically express and enforce these
communication protocols called \emph{import session types} (IST).
IST is inspired from resource-aware session types~\cite{das2018work}, a type system for expressing costful communication protocols
in concurrent message-passign processes which has been successfully employed in quantitative analysis of distributed
protocols~\cite{dasnomos,Das20FSCD,Das22LMCS,Das20arxiv}.
Session types in IST prescribe and enforce bi-directional communication protocols between ITMs, both in the ideal-world functionalities and real-world protocols.
A necessary condition then for UC emulation is that the session types in both the worlds \emph{must match exactly}.
The import value of a message is also directly encoded in its type, thus providing a static description of the import exchange
among ITMs.
Internally, an ITM can use its import to generate \emph{potential}, an abstract quantity that is consumed to perform a single
unit of computation.
Formally, an ITM containing $n$ units of import can generate $T(n)$ potential units (where $T$ is a ``reasonable'' function)
and since each execution step costs 1 potential unit, we can ultimately prove that the run-time budget of an ITM is never exceeded.

To facilitate the implementation of UC protocols and functionalities, we propose a novel core calculus called NomosUC that
internally uses IST as its main abstraction layer.
However, the design of NomosUC presents its own unique challenges.
First, session types are inherently linear restricting the process network to an acyclic tree-shaped topology,
whereas UC allows for arbitrary communication patterns.
Second, UC execution has several dynamic components: the total number of parties, the order in which parties are activated,
the topology of the ITM network, etc.
Capturing these statically in the type system turns out to be quite complicated in practice.
We solve these issues by employing \emph{shared binary session types}~\cite{balzer2017manifest} which allow sharing
of communication channels allowing cyclic interactions.
%Specifically, we designed a novel \emph{shared communicator} as a communication device between two ITM parties, allowing
%arbitrary communication topologies.
Specifically, we design a novel abstraction, the \emph{providerless channel}, that wraps ITM processes and runs them virtually.
The channels allow ITM parties to work with linear session types while still allowing arbitrary communication topologies.
Third, Rast has only been employed to enforce linear bounds on execution cost, whereas UC allows for polynomial run-time budget.
We achieve this by introducing a \emph{virtual tokens in a hierarchy} where import tokens at level $k$ can be used to generate
tokens at level $k+1$, which is ultimately used to generate potential.
Finally, our main technical challenge was ensuring that UC security definitions and generic composition operators
can be expressed in their full generality.
Surprisingly, even contending to the static nature of IST, we arrive at a notion of compositional security that remains expressive and generalizable.

We evaluate our approach to UC by working through the canonical UC theorems and operators, and we show an example of a UC definition,
the cryptographic commitent, in the form a of a a simulator. 
First, we present the Dummy Lemma to illustrates the modularity of NomosUC and our virtual tokens construction.
The Lemma allows us to define a simulator, the \emph{dummy simulator}, for single adversary and systematically generate simulatrs for any arbitrary adversary
by running them virtually. Though more of a convenience for UC proofs, the lemma is crucial to show an easy to use framework.
The last Section~\ref{sec:commitment} details a dummy simulator, for a protocol that realizes \Fcom, which runs parts of the real world virtually. 
Next, we present two operators, the composition operator the multisession operator, and show simulators that can be constructed to provde UC security under them.
Finally, we use the operators to conclude that NomosUC realizes the full UC composition theorem.

%\ankush{TODO Surya: add a para on evaluation, what all protocols we expressed in NomosUC}
% %We validate Nomos-UC by working through the standard UC theory of composition operators, as well as including a modular composition case study where we show a coinflipping application based on random oracles, using commitments as an intermediate layer.
