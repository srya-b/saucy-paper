In this section we highlight how \m{execUC} is encoded in NomosUC.
Recall from Section~\ref{sec:basic} that linear session types impose constraints on what forms of communication can be captured, and pose challenges to supporting 
a dynamic number of protocol parties, or functionalities, at runtime. 
We detail how our encoding realizes dynamic parties through the use of virtual tokens in our \partywrapper,
and validate our encoding by realizing a few critical results from the UC literature: the Dummy Lemma, a composition operator, and a multisession operator. 
These three results allow us to ultimately conclude that NomosUC realizes full UC composition.
We also run through a case of a coin-flip protocol, composed with the cryptographic commitment, in the Appendix. 

% \subsection{The UC Experiment}
The definition of \m{execUC} is straightforward owing to our mechanism of providerless channels. 
\m{execUC} is parameterized by at least one virtual token type to allow for sandboxing
(usually by the adversary or environment) and message type parameters for the protocol in question. 
It also takes in a security parameter $k$ and a random bit string $r$ that is used as a source of
randomness for all future processes.
\m{execUC} offers the following type:
\begin{center}
\vspace{-2mm}
\parbox{0cm}{
\begin{tabbing} 
 $\m{execout}[\K][a]\{n\} = \textcolor{red}{\getpot^{\{n : \K\}}} \echoice{\mb{exec}: $\=$ \m{Bit} \product 1}$ 
 \end{tabbing}}
\vspace{-2mm}
\end{center}
The type is parameterized by the real token type $\K$, message type $a$ and the import quantity $n$.
The type $\m{execout}[a]$ accepts $n$ import tokens and an $\mb{exec}$ message, and returns an output \m{Bit} as the result from \Z. 
With the help of the super-additive conversion function, the NomosUC type system ensures
that the runtime bound of \m{execUC} is $poly(k)$ as long as the number of tokens $n \in poly(k)$.

All main processes in NomosUC are wrapped according to the providerless channel specification in Section~\ref{sec:basic}. 
Therefore, \m{execUC} creates only the external part of the providerless channel (e.g. $\m{PtoQ}$ channel from Figure~\ref{fig:newpandq})
and passes them as input to the communicator wrappers.
The wrapper creates the intermediate processes and the shared session types providing the linear channel to \m{execUC}.
For example \Z and \A are connected by the following channels:
\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape]
$\$$ztoa $\leftarrow$ channel_init[$\tp{G}$][$\tp{z2a}$]{$\tp{z2an}$}
$\$$atoz $\leftarrow$ channel_init[$\tp{G}$][$\tp{a2z}$]{$\tp{a2zn}$}
$\tg{...}$
$\$$z <- env[G] k rng $\$$ztop $\$$ptoz $\$$ztoa $\$$atoz ;
\end{lstlisting}
Once the channels are created using the communicator wrappers, we spawn the
environment process and provide the necessary channels as arguments (along with
security parameter $k$ and the $\m{rng}$).
The environment, \Z, is the first spawned process and defines the main parameters for the rest of the execution: the session id (\m{SID}) and a set of
process ids ([\m{PID}]) indicating the corrupted parties.
The channel connecting $\m{execUC}$ and \Z has type $\m{EtoZ}$:
\begin{center}
\vspace{-2mm}
\parbox{0cm}{
\begin{tabbing}
 $\m{EtoZ}[a]$ = $\m{SID}[a] \arrow [\m{PID}] \arrow \textcolor{red}{\getpot^n} \echoice{\mb{start}: \m{Bit} \arrow 1}$
 \end{tabbing}}
\vspace{-2mm}
\end{center}
The type dictates that \Z sends the SID and the corruption list to \m{execUC},
and \m{execUC} passes them as parameters to \F, \A and the \partywrapper.  
\Z starts on input \mb{start} with $n$ tokens. 
Finally, the output bit, \Z's guess of which world it is in, forms the basis of the definition of indistinguishability.


\paragraph*{\textbf{The \partywrapper}}
We create the \partywrapper to handle spawning parties, create their channels, and connect them to the rest of the experiment.
Instead of parties directly communicating with \F and \Z through providerless channels, the \partywrapper runs them virtually and presents a ``real'' view to them.
The virtual tokens construct enables us to virtualize the protocol parties and satisfy the import their session types require while sandboxing them. 
The \partywrapper, in turn, is connected by single channels each of \F, \Z, and \A and routes communication to/from the appropriate protocol party. 
Its design forces the wrapper around \F to do the same. It must de-multiplex inputs from the \partywrapper and react similarly to messages fro newly created parties. 

\paragraph*{\textbf{Emulation}}
The central security definition in UC is indistinguishability between the real and ideal world experiments.
It is defined in terms of the ensemble of distributions created by the output bits from the partial term
$(\m{execUC}\ \pi\ \F)$ over all possible random inputs and security parameters. 
We say that two worlds are indistinguishable if $\forall \A\ \exists \Sim\ \forall Z$
the \emph{statistical difference} in ensembles from the two worlds is negligible in $k$ (see
Definition~\ref{def:emulation} below).

\begin{definition}[Emulation]\label{def:emulation}
If two protocols $(\pi, \F_1)$ and $(\phi, \F_2)$, which we refer to only
by \PI and $\phi$, emulated each other, then $\forall \A$ of type $\Delta_3'$ well-matched with \PI, there must $\exists \Sim$ of the same type,  well-matched with $\phi$, s.t. $\forall \Z$ : $\msf{execUC}(\pi, \F_1, \Z, \A)$ $\approx$ $\msf{execUC}(\phi, \F_2, \Z, \Sim)$:

\begin{mathpar}
	\footnotesize
	\inferrule*[right=emulate]
	{
		\F_1 : \Delta_{\F_1}', \F_2 : \Delta_{\F_2}' \semi
		\Delta_{\F_1}' \vdash \pi : \Delta_1' \semi \Delta_{\F_2}' \vdash \phi : \Delta_2' \semi \\
		\forall \A \ . \ \Delta_4, \Delta_1' \vdash \A :: \Delta_3', \matched{\A}{\pi}, \matched{\A}{\F_1} \\
		\Rightarrow \exists \Sim_\A \ . \ (\Delta_3, \Delta_2' \vdash \Sim_\A :: \Delta_3'), \matched{\Sim_\A}{\phi}, \matched{\Sim_\A}{\F_2} \semi \\
		\forall \Z \ . \ \matched{\Z}{\pi}, \matched{\Z}{\phi} \Rightarrow \\
		\msf{execUC} \ \pi\ \F_1\ \Z\ \A \sim \msf{execUC} \ \phi\ \F_2\ \Z\ \Sim_\A
	}
	{
		% EMULATION DEFINITION
		\lambda \A \, . \, \Sim_\A \vdash (\pi, \F_1) \sim (\phi, \F_2)
	}
\end{mathpar}
\end{definition}
The notation $e \leftrightarrow e'$ is used to denote two \emph{well-matched} terms: a configuration connected the two is well-typed. 

\subsection{Dummy Lemma}
An important validation of our approach is the Dummy Lemma~\ref{thm:dummythicclemma} which shows that a simulator, \DS, for the dummy adversary, suffices to prove emulation. 
\begin{theorem}[Dummy Lemma]\label{thm:dummythicclemma}
If \ $\exists \DS$ s.t. $ \DA, \DS \vdash \F_2 \xrightarrow{\pi} \F_1$ then $\forall \A \ \exists \Sim_\A$ s.t. $\Sim_{\A} \vdash  \F_2 \xrightarrow{\pi} \F_1)$ 
\end{theorem}
The proof of the Lemma is in the form of a constructor for a simulator for any arbitrary real world \A (in Appendix~\ref{sec:dummy}).
Though a simple Lemma, and simulator construction, the simplicity of the resulting simulator proof highlights the simplicity and expressiveness that our token hierarchy and sandboxing afford. 

\subsection{Single Composition}
In this section we present a composition operator for protocols that completes Theorem~\ref{thm:singlecomp}.

The composition allows replacement of a single ideal functionality $\F_2$ with a protocol $\pi$ that realizes it in the $\F_1$-hybrid world. 
A protocol party $\rho_i$ that gives input to $\F_2$ instead gives input to party $\pi_i$ through a providerless channel in the \partywrapper. 
Like \m{execUC} (full code in the Appendix), the operator connects wrapped processes with providerless channels as shown below. 
\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single]
$\nproc$ compose[$\tg{...}$][rho2f,f2rho]{rho2fn,f2rhon}
  $\tg{(* args *)}$ |- ($\$$ch: 1) = {
  #rho2pi $\leftarrow$ channel_init[K][rho2f]{rho2fn} ;
  #pi2rho $\leftarrow$ channel_init[K][f2rho]{f2rhon} ;
  
  $\$$r $\leftarrow$ rho $\leftarrow$ k rng sid pid #z2p #p2z #rho2pi #pi2rho; 
  $\$$p $\leftarrow$ pi $\leftarrow$ k rng sid pid #rho2pi #pi2rho #p2f #f2p;
}
\end{lstlisting}

Proving UC security under composition requires creating a simulator for $\rho \circ \pi$ that realizes $\F_3$. 
This is done by connecting the two simulators, \SIM{\pi} and \SIM{\rho}, in the same way as the Dummy Lemma: sandboxed \SIM{\pi} receives input from \Z, gives output to \SIM{\rho} which gives output to the ideal world.  
Also like the Dummy Lemma, the simulator construction provided in the Appendix is agnostic to the types of the composed protocols and can be easily specified thanks to our token heirarchy. 

\subsection{UC Composition}

\begin{theorem}[Composition]\label{thm:composition}
\begin{mathpar}
\inferrule*[right=compose]
{
	%(\pi, !\F_1) \sim (\idealP, F_2) \semi (\rho, !\F_2) \sim (\idealP, \F_3) \\ 
	!\F_1 \xrightarrow{\pi} \F_2 \semi !\F_2 \xrightarrow{\rho} \F_3 \\
	%\Rightarrow \exists \Sim(\A) \vdash (\rho^{!\F_2 \rightarrow (!\pi \, \circ \, \msf{squash})}, !\F_1) \sim (\idealP, \F_3)
}
{
	!\F_1 \xrightarrow{\rho \, \circ !\pi \circ \, \msf{squash}} \F_3
	%(\rho \, \circ \, !\pi \circ \msf{squash}, !\F_1) \sim (\idealP, \F_3)
}
\end{mathpar}
\end{theorem}

Full composition, Theorem~\ref{thm:composition}, extends Theorem~\ref{thm:singlecomp} to replace multiple concurrent instances of a functionality with a realizing protocol.
We provide it by first proving a much simpler theorem arising from the multisession operator ($!$), Theorem~\ref{thm:functor}, and Theorem \ref{thm:squash}.
Theorem~\ref{thm:squash} trivially shows a protocol \m{squash} such that $!\F \xrightarrow{\m{squash}} !!\F$, and the proof of Theorem~\ref{thm:functor} is trivially proven by replicating \SIM{\pi} for every instance of $\F_2$.  

\begin{theorem}[Multisession Composition]\label{thm:functor}
	\begin{mathpar}
		\inferrule*[right=MultiComp]
		{
			\F_1 \xrightarrow{\pi} \F_2
		}
		{
			!\F_1 \xrightarrow{!\pi} !\F_2
		}
	\end{mathpar}
\end{theorem}

We can now prove Theorem~\ref{thm:composition} in NomosUC:
\begin{proof}
By Theorem~\ref{thm:singlecomp} we have that $\F_1 \xrightarrow{\pi} \F_2$. Combine it with Theorem~\ref{thm:functor} and conclude that $!!\F_1 \xrightarrow{\rho \circ !\pi} !\F_3$. 
Finally, squash two $!!$ operators into one with Theorem~\ref{thm:squash} to get $!\F_1 \xrightarrow{\rho \circ !\pi \circ \m{squash}} \F_3$.
\end{proof}

