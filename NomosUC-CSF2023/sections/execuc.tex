So far we have introduced a type system and process calculus for writing and checking runtime that conforms to the import mechanism for polynomial runtime.
In this section, we show that NomosUC can realize any arbitrary ITM configuration, as possible in UC, and that we can easily encode the set of fundamental proofs and lemmas of the framework and a generic composition operator.
The main challenges we overcome in realizing arbitrary ITM systems is grappling with the parent-child relationship between processes (and the provider-client reationship in channels) that prevents cyclical topologies in the normal case. 
We introduce a simple construction called \emph{providerless channels} which relies on shared session types and uses our virtual token construction. 
Second we discuss how the dummy lemma, a composition operator, and the composition theorem can be realized by the introduction of \emph{providerless channels}.




In this section we highlight how \m{execUC} is encoded in NomosUC.
Recall from Section~\ref{sec:basic} that linear session types impose constraints on what forms of communication can be captured, and pose challenges to supporting 
a dynamic number of protocol parties, or functionalities, at runtime. 
We detail how our encoding realizes dynamic parties through the use of virtual tokens in our \partywrapper,
and validate our encoding by realizing a few critical results from the UC literature: the Dummy Lemma, a composition operator, and a multisession operator. 
These three results allow us to ultimately conclude that NomosUC realizes full UC composition.
%We also run through a case of a coin-flip protocol, composed with the cryptographic commitment, in the Appendix. 

% \subsection{The UC Experiment}
The definition of \m{execUC} is straightforward owing to our mechanism of providerless channels. 
\m{execUC} is parameterized by at least one virtual token type to allow for sandboxing
(usually by the adversary or environment) and message type parameters for the protocol in question. 
It also takes in a security parameter $k$ and a random bit string $r$ that is used as a source of
randomness for all future processes.
\m{execUC} offers the following type:
\begin{center}
\vspace{-2mm}
\parbox{0cm}{
\begin{tabbing} 
 $\m{execout}[\K][a]\{n\} = \echoice{ \textcolor{red}{\getpot^{\{n : \K\}}}\mb{exec}: $\=$ \m{Bit} \product 1}$ 
 \end{tabbing}}
\vspace{-2mm}
\end{center}
The type is parameterized by the real token type $\K$, message type $a$ and the import quantity $n$.
The type $\m{execout}[a]$ accepts $n$ import tokens and an $\mb{exec}$ message, and returns an output \m{Bit} as the result from \Z. 
With the help of the super-additive conversion function, the NomosUC type system ensures
that the runtime bound of \m{execUC} is $poly(k)$ as long as the number of tokens $n \in poly(k)$.

\m{execUC} only spawns processes already wrapped according to the providerless channel specification in Section~\ref{sec:basic}.
Therefore, it only has to spawn the part of the channel that connects wrapped processes.
We make this separation because the wrapped processes code is autogenerated given a specification of the session type and functional
type associated with the process.

%All main processes in NomosUC are wrapped according to the providerless channel specification in Section~\ref{sec:basic}. 
%Therefore, \m{execUC} creates only the part of the providerless channel (e.g. $\m{PtoQ}$ channel from Figure~\ref{fig:newpandq})
%and passes them as input to the communicator wrappers.
%The wrapper creates the intermediate processes and the shared session types providing the linear channel to \m{execUC}.
%For example \Z and \A are connected by the following channels:
%\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape]
%$\$$ztoa $\leftarrow$ channel_init[$\tp{G}$][$\tp{z2a}$]{$\tp{z2an}$}
%$\$$atoz $\leftarrow$ channel_init[$\tp{G}$][$\tp{a2z}$]{$\tp{a2zn}$}
%$\tg{...}$
%$\$$z <- env[G] k rng $\$$ztop $\$$ptoz $\$$ztoa $\$$atoz ;
%\end{lstlisting}

Once channels are created, the environment \Z is the first process to be spawned.
As it's type \m{EtoZ} indicates below, it determines the main parameters of the experiment: the session id (\m{SID}) according to a user-defined type, and 
it determines the set of corrupt parties. 
\Z starts execution given some import $n$ by \m{execUC}.
These are given by \m{execUC} to the rest of the processes it spawns. 
\begin{center}
\vspace{-2mm}
\parbox{0cm}{
\begin{tabbing}
 $\m{EtoZ}[a]$ = $\m{SID}[a] \arrow [\m{PID}] \arrow \echoice{\textcolor{red}{\getpot^n} \mb{start}: \m{Bit} \arrow 1}$
 \end{tabbing}}
\vspace{-2mm}
\end{center}
%The type dictates that \Z sends the SID and the corruption list to \m{execUC},
%and \m{execUC} passes them as parameters to \F, \A and the \partywrapper.  
%\Z starts on input \mb{start} with $n$ tokens. 
Finally, the output bit, \Z's guess of which world it is in, forms the basis of the definition of indistinguishability.

\paragraph*{\textbf{The \partywrapper}}
We create the \partywrapper to handle process spawn, channel creation and connection to the rest of the experiment.
Instead of parties directly communicating with \F and \Z through providerless channels, the \partywrapper runs them virtually and presents a ``real'' view to them.
Virtual tokens enable us to simulate the protocol parties and satisfy the import their session types require while sandboxing them. 
The \partywrapper, in turn, is connected by a channel to each of \F, \Z, and \A and routes communication to/from the appropriate protocol party. 
Its design forces the wrapper around \F to do the same. It must de-multiplex inputs from the \partywrapper and react similarly to messages fro newly created parties. 

\paragraph*{\textbf{Emulation}}
The central security definition in UC is indistinguishability between the real and ideal world experiments.
It is defined in terms of the ensemble of distributions created by the output bits from the partial term
$(\m{execUC}\ \pi\ \F)$ over all possible random inputs and security parameters. 
We say that two worlds are indistinguishable if $\forall \A\ \exists \Sim\ \forall Z$
the \emph{statistical difference} in ensembles from the two worlds is negligible in $k$ (see
Definition~\ref{def:emulation} below).

\begin{definition}[Emulation]\label{def:emulation}
If two protocols $(\pi, \F_1)$ and $(\phi, \F_2)$, which we refer to only
by \PI and $\phi$, emulated each other, then $\forall \A$ of type $\Delta_3'$ well-matched with \PI, there must $\exists \Sim$ of the same type,  well-matched with $\phi$, s.t. $\forall \Z$ : $\msf{execUC}(\pi, \F_1, \Z, \A)$ $\approx$ $\msf{execUC}(\phi, \F_2, \Z, \Sim)$:

\begin{mathpar}
	\footnotesize
	\inferrule*[right=emulate]
	{
		\F_1 : \Delta_{\F_1}', \F_2 : \Delta_{\F_2}' \semi
		\Delta_{\F_1}' \vdash \pi : \Delta_1' \semi \Delta_{\F_2}' \vdash \phi : \Delta_2' \semi \\
		\forall \A \ . \ \Delta_4, \Delta_1' \vdash \A :: \Delta_3', \matched{\A}{\pi}, \matched{\A}{\F_1} \\
		\Rightarrow \exists \Sim_\A \ . \ (\Delta_3, \Delta_2' \vdash \Sim_\A :: \Delta_3'), \matched{\Sim_\A}{\phi}, \matched{\Sim_\A}{\F_2} \semi \\
		\forall \Z \ . \ \matched{\Z}{\pi}, \matched{\Z}{\phi} \Rightarrow \\
		\msf{execUC} \ \pi\ \F_1\ \Z\ \A \sim \msf{execUC} \ \phi\ \F_2\ \Z\ \Sim_\A
	}
	{
		% EMULATION DEFINITION
		\lambda \A \, . \, \Sim_\A \vdash (\pi, \F_1) \sim (\phi, \F_2)
	}
\end{mathpar}
\end{definition}
The notation $e \leftrightarrow e'$ is used to denote two \emph{well-matched} process terms meaning
that they have the \emph{same type on all the channels} used and provided.

% \paragraph*{\textbf{Dummy Lemma}}
\begin{theorem}[Dummy Lemma]\label{thm:dummythicclemma}
If \ $\exists \DS$ s.t. $ \DA, \DS \vdash \F_2 \xrightarrow{\pi} \F_1$ then $\forall \A \ \exists \Sim_\A$ s.t. $\Sim_{\A} \vdash  \F_2 \xrightarrow{\pi} \F_1)$ 
\end{theorem}
An important validation of our approach is the Dummy Lemma which shows that a simulator \DS for the dummy adversary, suffices to prove emulation. 
The proof of the Lemma is in the form of a constructor for a simulator for any arbitrary real world \A (in Appendix~\ref{sec:dummy}).
The simplicity of the simulator construction and the resulting simulation proof highlights the
simplicity and expressiveness that our token hierarchy and sandboxing afford. 

\paragraph*{\textbf{Single Composition}}
Recalling Theorem~\ref{thm:singlecomp}, composition allows replacement of a single ideal functionality $\F_2$ with a protocol $\pi$ that realizes it in the $\F_1$-hybrid world. 
A protocol party $\rho_i$ that gives input to $\F_2$ instead gives input to party $\pi_i$ through a providerless channel in the \partywrapper. 
Like \m{execUC} (full code in the Appendix), the operator connects wrapped processes with providerless channels as shown below. 
%%\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single]
%%$\nproc$ compose[$\tg{...}$][rho2f,f2rho]{rho2fn,f2rhon}
%%  $\tg{(* args *)}$ |- ($\$$ch: 1) = 
%%#rho2pi $\leftarrow$ channel_init[G][rho2f]{rho2fn} ;
%%#pi2rho $\leftarrow$ channel_init[G][f2rho]{f2rhon} ;
%%  
%%$\$$r $\leftarrow$ rho $\leftarrow$ k rng sid pid #z2p #p2z #rho2pi #pi2rho; 
%%$\$$p $\leftarrow$ pi $\leftarrow$ k rng sid pid #rho2pi #pi2rho #p2f #f2p;
%%\end{lstlisting}

\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single]
$\nproc$ compose[K,K1,s][z2rho,rho2z][pi2f,f2pi]$\tg{...}$
  (k: Int), (rng: [Bit]), (sid: SID[s]), (pid: PID),
  (#z2p: comm[K][z2rho]{z2rhon}), $\tg{...}$ 
  (#p2f: comm[K][pi2f]{pi2fn}) $\tg{...}$
    $\vdash$ ($\$$ch: 1) =
{
  #rhop2f $\leftarrow$ channel_init[K][rho2f]{rho2fn} ;
  #piz2p $\leftarrow$ wrap_z2p[K][rho2f]{rho2fn} $\leftarrow$ #rhop2f ;
  #piz2p $\leftarrow$ channel_init[K][rho2f]{rho2fn} ;
  #rhof2p $\leftarrow$ wrap_p2z[K][rho2f]{rho2fm $\leftarrow$ #piz2p ;

  $\leftarrow$ gen_wrapper_rho[K1] $\leftarrow$ 
    k rng sid pid #z2p #p2z #rho2pi #pi2rho ;
  $\leftarrow$ gen_wrapper_pi[K1] $\leftarrow$ 
    k rng sid pid #rho2pi #pi2rho #p2f #f2p ; 
}
\end{lstlisting}
As indicated the operator deals with the wrapped versions of $\rho$ and $\pi$, and its parametric type ensures that any two protocols, especially multisession versions of them ($!\pi$), can be composed together.
The two protocol parties are connected in the obvious way with output from $\rho$ wrapped into the a type \inline{Z2P} to making it look like input from \Z to $\pi$.

%The operator interacts with the wrapped versions of the constituent protocols $\rho$ and $\pi$, and its parametric type ensures that even multisession versions of a protocol $\pi$ can be composed with $\rho$.
%It creates channels between the two parties and wraps the message sent from $\rho$ to appear as input from \Z to $\pi$. 
%
%In the next section we talk briefly about building a zero-knowledge UC experient by applying the multisession extension of $!\Fcom$ used throughout this work.
%We talk about it at a high-level and relegate a more detailed specification of the protocol in the appendix.

Proving UC security under composition requires creating a simulator for $\rho \circ \pi$ that realizes $\F_3$. 
This is done by connecting the two simulators, \SIM{\pi} and \SIM{\rho}, in the same way as the Dummy Lemma: sandboxed \SIM{\pi} receives input from \Z, gives output to \SIM{\rho} which gives output to the ideal world.  
Also like the Dummy Lemma, the simulator construction provided in the Appendix is agnostic to the types of the composed protocols and can be easily specified thanks to our token hierarchy. 

% \paragraph*{\textbf{UC Composition}}
\paragraph*{\textbf{Parallel Composition}}
UC composition extends Theorem~\ref{thm:singlecomp} to replace multiple concurrent instances of a functionality with a realizing protocol. 
The multisession operator $!$ when applied to a functionality ($!\F$) or protocol ($!\pi$), allows for the creation of arbitrary many instances of the \F or $\pi$.
Messages from a protocol to $!\F$ include an additional user-defined session id that distinguishes different instances. 
The multisession composition theorem below, Theorem~\ref{thm:functor}, shows that UC emulation holds under the multisession operator. 
The simulator for this theorem is trivial as it spawns a new simulator for every new instances of $!\F$/$!\pi$.
We use Theorem~\ref{thm:functor}, whose simulator is found in Appendix~\ref{app:ms} and a simpler Theorem~\ref{thm:squash}, which allows $!!\F \xrightarrow{\msf{squash}} !\F$, 
to show that the UC composition Theorem~\ref{thm:composition} holds below.

\begin{theorem}[Multisession Composition]\label{thm:functor}
\vspace{-0.5em}
	\begin{mathpar}
		\inferrule*[right=MultiComp]
		{
			\F_1 \xrightarrow{\pi} \F_2
		}
		{
			!\F_1 \xrightarrow{!\pi} !\F_2
		}
	\end{mathpar}
\end{theorem}

%\begin{theorem}[Composition]\label{thm:composition}
%\vspace{-0.5em}
%\begin{mathpar}
%\inferrule*[right=compose]
%{
%	%(\pi, !\F_1) \sim (\idealP, F_2) \semi (\rho, !\F_2) \sim (\idealP, \F_3) \\ 
%	!\F_1 \xrightarrow{\pi} \F_2 \and !\F_2 \xrightarrow{\rho} \F_3 \\
%	%\Rightarrow \exists \Sim(\A) \vdash (\rho^{!\F_2 \rightarrow (!\pi \, \circ \, \msf{squash})}, !\F_1) \sim (\idealP, \F_3)
%}
%{
%	!\F_1 \xrightarrow{\rho \, \circ !\pi \circ \, \msf{squash}} \F_3
%	%(\rho \, \circ \, !\pi \circ \msf{squash}, !\F_1) \sim (\idealP, \F_3)
%}
%\end{mathpar}
%\end{theorem}

With these preliminary theories we can combine their simulator proofs through our generic composition operator to show that the composition operator defined in NomosUC satisfies the UC composition theorem:
\begin{proof}
By Theorem~\ref{thm:singlecomp} we have that $\F_1 \xrightarrow{\pi} \F_2$. Combine it with Theorem~\ref{thm:functor} and conclude that $!!\F_1 \xrightarrow{\rho \circ !\pi} !\F_3$. 
Finally, squash two $!!$ operators into one with Theorem~\ref{thm:squash} to get $!\F_1 \xrightarrow{\rho \circ !\pi \circ \m{squash}} \F_3$.
\end{proof}


%$!\F_1 \xrightarrow{\pi} \F_2, \, !\F_2 \xrightarrow{\rho} \F_3 \xRightarrow[\left( !!\F_2 \xrightarrow{!\pi} !\F_2 \right)]{\textsc{Multi-Comp}} \; !!\F_1 \xrightarrow{\rho \circ !\pi} \F_3$ \\ \\
%
%$\xRightarrow[\left( !\F_1 \xrightarrow{\msf{squash}} !!\F_1 \right)]{\textsc{Squash}} \; !\F_1 \xrightarrow{\rho \circ !\pi \circ \msf{squash}} \F_3$
%
