In this section we show how virtual tokens are used to construct a simulator for the running example, \Fcom, in this work.
The design pattern is identical to the simulator proofs of Theorems~\ref{thm:dummythicclemma}, \ref{thm:singlecomp}, \ref{thm:functor}.
This section highlights the simplicity of our encoding and token heirarchy.

\subsection{Commitment Protocol}
The commitment protocol that we prove realizes \Fcom exists in the \Fropp-hybrid world.
\Fropp is a combination of a a random oracle \Fro (idealized hash function) a one-way channel \Fauth.
Let the output of the function $\O{x}$ be the hash reply of \Fropp on query $x$ with 1 import token.
On input \mb{commit(b)} and 1 import from \Z, the committer chooses a random blind $n \sample \bits{k-1}$ and sends $h = \O{b || n}$ to the receiver. 
On \mb{open} from \Z, the commiter sends $b,n$ and the receiver checks $h \equiv \O{b || n}$ and outputs \mb{open} and $b$ if true. 

\subsection{A Simulator for \Fcom}
The protocol above is full-information, i.e. it relies on no secret information like locally generated keys or coinflips. 
Therefore, a common strategy for simulators full-informatio protocols is to run the real world in a sandbox and give the corrupt and honest parties in it the same input as the ideal world. 
In this case, the simulator \simcom is even simpler and need only sandbox the random oracle \Fro to maintain the real world hash table.
Sandboxing in NomosUC is achieved simply by passing a virtual token type as a parameter to a process rather than the real one. 
\simcom spawns the wrapped \Fro simply with
\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single, numbers=left, xleftmargin=2em, xrightmargin=2em]
#p_to_f $\leftarrow$ chan[K1][rop2f]{1}
#f_to_p $\leftarrow$ chan[K1][rof2p]{1}

$\leftarrow$ Fro[K1] <- k rng sid #p_to_f #f_to_p ;
$\$$p2f' $\leftarrow$ ro_p2f[K1] #p_to_f #f_to_p;
\end{lstlisting}
where \inline{$\$$p2f'}, the linear endpoint of the providerless channel with \Fro, is typed as 
{\centering
\parbox{0cm}{
\begin{tabbing}
$\m{hash} = \textcolor{red}{\getpot^1} \ichoice{\mb{query}: $\=$PID \product Int \product$ \\
\>$\echoice{\mb{hash}: PID \arrow Int \arrow \m{hash}}}$
\end{tabbing}}
}

Communication between \Z and \A is governed by the simple linear type \inline{comm[K][Z2A[2p][2f]} introduced in Section~\ref{sec:basic} where \inline{z2a} is defined as 
\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape]
$\Type$ z2a[a][b] = Z2A2P of PID ^ a | Z2A2F of b 
$\Type$ a2z[a][b] = P2A2Z of PID ^ a | F2A2Z of b
\end{lstlisting}

\subsection{Corrupt Committer}
We only cover the case of the corrupt committer here as it is the most interesting with the incomplete case match below.
When \Z gives \simcom a hash query for the committer with 1 unit of import (line 1-3), \simcom creates 1 virtual token of type $K_1$ (line 4) and queries the sandboxed \Fro (lines 5-6).  
The hash from \Fro is forwarded back to \Z as output \inline{P2A2Z(pid, msg} from the committer (lines 10-11).
%\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single, numbers=left, xleftmargin=2em, xrightmargin=2em]
%$\ncase$ m ( Z2A2P(pid, msg) =>
%  $\nget$ {1} K $\$$z2p ;
%  $\ncase$ msg ( QHash(x) =>
%    $\nwithdraw$ K K1 1 ;
%    $\$$p2f'.hash; $\nsend$ $\$$p2f' pid; $\nsend$ $\$$p2f' x ;
%    $\npay$ {1} K1 $\$$p2f'
%    $\ncase$ $\$$p2f' (
%      shash => pid = $\nrecv$ $\$$p2f' 
%               h = $\nrecv$ $\$$p2f'
%               $\$$a2z.send ;
%               $\nsend$ $\$$a2z P2A2Z(pid, RHash(h))
%\end{lstlisting}
The import tokens that \simcom receives ensurs that it can make a polynomial number of virtual tokens for a potentially polynomial number of queries. 

We complete the inner case match, for \inline{msg} in the above example, with \Z sending a message from the corrupt committer to the receiver.
\simcom searches through a list of saved preimages \inline{$\$$l} (line 15-16) and looks for an existing hash table entry (line 17-19). 
If the commitment exists, extract the bit from the pre-image and instruct the committer in the ideal world to commit (line 25).
%\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single, numbers=left, xleftmargin=2em, xrightmargin=2em, firstnumber=13]
%Send(pid, d) =>
%  b = sample rng 1 ;
%  forSeq_ $\$$l \p ->
%    withdrawtoken K K1 1 ;
%    $\$$p2f'.hash ; $\nsend$ $\$$p2f' 1 ; $\nsend$ $\$$p2f' p ;
%    $\npay$ {1} K1 $\$$p2f' ;
%    $\ncase$ $\$$p2f'( 
%      shash => $\nrecv$ $\$$p2f' ; h = $\nrecv$ $\$$p2f' ;
%        $\nif$ h == d $\nthen$
%          (b: n) = h  $\tg{(*parse bit and nonce *)}$
%          break
%        $\nelse$ ())
%  $\$$a2s.commit ; send $\$$a2s b ;
%\end{lstlisting}
When the commitment is opened by \Z and no bit $b$ was found above on line 21, the open is ignored and the \Fcom doesn't open.
If a $b$ is found, \simcom simply instructs the sender to open (\inline{$\$$a2s.open}) and it, itself, terminates.  

\subsection{Sandboxing}
Akin to how \Fro was used above in a sandbox, the main theorems in this work are proven through connectin simulators, and potentially adversaries, in a sandbox. 
As we can see above, the providerless channel abstraction allows specification to be very general and straightforward. 
The token heirarchy neatly abstracts away the notion of virtualization from process definitions. 

%The resulting type definition of \simcom below is straightdorward, and we omit the default parameters for the sake of space.
%\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single]
%$\nproc$ simcom[K][K1]: ($\$$z2a: comm[K][A2Z[rop2f]]{1}),
%($\$$a2s: sender[K][a]), ($\$$a2r: reciever[K][a]), ($\$$a2f: 1) 
%  |- ($\$$ch: 1)
%\end{lstlisting}
%It is parameterized by its own token type \inline{K} and a virtual token type \inline{K1} to be used for sandboxing other processes.
%Much like the environment and \Fcom, \simcom is parameterized  two channels for the sender and the receiver, and to the functionality with a channel typed \m{1}.

\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single, numbers=left, xleftmargin=2em, xrightmargin=2em, firstnumber=8]
case m (
  Z2A2P(pid, msg) =>
    case msg (
      QHash(x) => 
        withdrawtoken K K1 1 ;
        $\$$l <- append $l x ;
        $\$$p2f'.hash; send $\$$p2f' pid ; send $\$$p2f' x ;
        pay {1} K1 $\$$p2f' ;
        case $\$$p2f' (
          shash => pid = recv $\$$p2f' ; h = recv $\$$p2f' ;
            $\$$a2z.send ; send $\$$a2z P2A2Z(pid, RHash(h))
        )
        $\$$ch <- sim_zom_z2p_crupt_commitment[K][K1]
      Send(pid, d) =>
        b = sample rng 1 ;
        forSeq_ $\$$l \p ->
          withdrawtoken K K1 1 ;
          $\$$p2f'.hash ; send $\$$p2f' 1 ; send $\$$p2f' p ;
          pay {1} K1 $\$$p2f' ;
          case $\$$p2f'( 
            shash => recv $\$$p2f' ; h = recv $\$$p2f' ;
              if h == d then
                (b: n) = h 
                break
              else ())
        $\$$a2s.commit ; send $\$$a2s b ;
        $\$$ch <- sim_com_z2p_crupt_committer[K][K1] <- k rng sid $\$$z2a $\$$a2z $\$$a2s $\$$a2r $\$$p2f' $\$$f2p' $\$$l
    )
\end{lstlisting}






