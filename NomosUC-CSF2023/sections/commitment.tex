In this section we highlight the use of our token heirarchy and virtual tokens construction in NomosUC.
Specifically, we expand on the commitment ideal functionality \Fcom, used throughout this work, to show a simple example of a simulator for a commitment protocol that sandboxes a real world ideal functionality. 

\subsection{Commitment Protocol}
This commitment protocol realizes \Fcom exists in the \Fropp-hybrid world. \Fropp consists of a random oracle (an idealized hash function) and a one-way channel from the committer to the receiver. 
The random oracle accepts pre-images of size $k$, generates a ``hash'' for them by sampling $k$-bit randomness ($\{0,1\}^k$, and stores the mapping.
It requires 1 import token to be sent with each query to cover a polynomial number of activations and searching through a polynomial size database. The type for just the random oracle part, \Fro, used below captures the requirement. 
The oracle's hiding and binding properties mean that a generated hash does not leak information about the pre-image (the value committed to)  and that the committer can't equivocate on the pre-image on a hash sent to the receiver. 
Let \O{x} be the reply of \Fropp on query $x$. The protocol is succintly described as: 
The committer commits to bit $b$ by sampling a bliding nonce $n \sample \bits{k-1}$ and sending $c = \O{b || n}$ to the receiver. When opening the commitment, the committer sends $b, n$ to the receiver who can check that $c \equiv \O{b || n}$.
We omit the details of the communication with the one-way channel but they are identical to the \Fauth presented in Section~\ref{sec:execuc}.

\subsection{A Simulator for \Fcom}
The protocol above is full-information, i.e. it relies on no secret information like locally generated keys or coinflips. 
Therefore, a common strategy for simulators is to sandbox the entire real world execution internall and pass it input from the environment.
In this case, the simulator \simcom sandboxes only the random oracle, \Fro, part of the ideal functionality \Fropp. 
Sandboxing is performed by creating virtual tokens and passing them to sandboxd processes as ``real'' tokens. 
Our typing rules for a valid token context ensures polynomial runtime for virtual processes and the processes sandboxing them at arbitrary token depths.

First, we introduce some necessary types. 
\simcom receives messages from (and gives output to) \Z for protocol parties and the ideal functionality with the message types through the \m{comm} session type. 

\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape]
$\Type$ z2a[a][b] = Z2A2P of PID ^ a | Z2A2F of b 
$\Type$ a2z[a][b] = P2A2Z of PID ^ a | F2A2Z of b
\end{lstlisting}
where \inline{a}'s \inline{rop2f} and \inline{rof2p}, and the \inline{b}'s are 1 in this example.  

The resulting type definition of \simcom below is straightdorward, and we omit the default parameters for the sake of space.
\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single]
$\nproc$ simcom[K][K1]: ($\$$z2a: comm[K][A2Z[rop2f]]{1}),
($\$$a2s: sender[K][a]), ($\$$a2r: reciever[K][a]), ($\$$a2f: 1) 
  |- ($\$$ch: 1)
\end{lstlisting}
It is parameterized by its own token type \inline{K} and a virtual token type \inline{K1} to be used for sandboxing other processes.
Much like the environment and \Fcom, \simcom is parameterized  two channels for the sender and the receiver, and to the functionality with a channel typed \m{1}.

\simcom spawns \Fro below with a virtual token type $K_1$. The type system ensures that \Fro is bounced by a polynomial \GlobalF in  $k$ and the virtual tokens $t_1$ it receives.
The providerless channels are created with \inline{chan} in line 1-2 and the linear endpoints are obtained subsequently (line 5-6).
Simply passing a virtual token type parameter ensures that all potential and import used are virtual, and that \Fro can not communicate outside of the sandbox.
\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single, numbers=left, xleftmargin=2em, xrightmargin=2em]
#p_to_f $\leftarrow$ chan[K1][rop2f]{1}
#f_to_p $\leftarrow$ chan[K1][rof2p]{1}

$\leftarrow$ Fro[K1] <- k rng sid #p_to_f #f_to_p ;
$\$$p2f' $\leftarrow$ ro_p2f[K1] #p_to_f ;
$\$$f2p' $\leftarrow$ ro_f2p[K1] #f_to_p ;
\end{lstlisting}


\paragraph{Messages for \Fro}
The session type desribing \Fro is given by

{\centering
\parbox{0cm}{
\begin{tabbing}
$\m{hash} = \textcolor{red}{\getpot^1} \ichoice{\mb{query}: $\=$PID \product Int \product$ \\
\>$\echoice{\mb{hash}: PID \arrow Int \arrow \m{hash}}}$
\end{tabbing}}
}
\Z queries \simcom with input for a corrupt party in the form of a message for \Fropp (a random oracle query or a message for the receiver).
\simcom handles hash queries below. 
\simcom gets 1 unit of import from \Z (line 3) for input to \Fropp, creates 1 virtual token of type $K_1$ (line 5) and pays it to \Fro with the query (line 7).
The number of $K_1$ tokens, $t_1$, is constrained in the type system by a polynomial of the number of type $K$: $t_{1} \leq \GlobalF(t_0, k)$. \simcom never sends import to any other process and therefore can create a polynomial number to perform a potentially polynomial number of hash queries. 
This snippet of an incomplete case match, from \simcom, for a hash query message from \Z illustrates communication over sandboxed channels.
\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single, numbers=left, xleftmargin=2em, xrightmargin=2em]
$\ncase$ m ( Z2A2P(pid, msg) =>
  $\nget$ {1} K $\$$z2p ;
  $\ncase$ msg ( QHash(x) =>
    $\nwithdraw$ K K1 1 ;
    $\$$p2f'.hash; $\nsend$ $\$$p2f' pid; $\nsend$ $\$$p2f' x ;
    $\npay$ {1} K1 $\$$p2f'
    $\ncase$ $\$$p2f' (
      shash => pid = $\nrecv$ $\$$p2f' 
               h = $\nrecv$ $\$$p2f'
               $\$$a2z.send ;
               $\nsend$ $\$$a2z P2A2Z(pid, RHash(h))
\end{lstlisting}
The resuling hash $h$ is sent back to the environement whtout any import (line 12).

\paragraph{Simulating the commitment}
We complete the inner case match, for \inline{msg} in the above example, with \Z sending a message from the corrupt committer to the receiver.
\simcom searches through a list of saved preimages \inline{$\$$l} (line 15-16) and looks for an existing hash table entry (line 17-19). 
If the commitment exists, extract the bit from the pre-image and instruct the committer in the ideal world to commit (line 25).

\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, mathescape, frame=single, numbers=left, xleftmargin=2em, xrightmargin=2em, firstnumber=13]
Send(pid, d) =>
  b = sample rng 1 ;
  forSeq_ $\$$l \p ->
    withdrawtoken K K1 1 ;
    $\$$p2f'.hash ; $\nsend$ $\$$p2f' 1 ; $\nsend$ $\$$p2f' p ;
    $\npay$ {1} K1 $\$$p2f' ;
    $\ncase$ $\$$p2f'( 
      shash => $\nrecv$ $\$$p2f' ; h = $\nrecv$ $\$$p2f' ;
        $\nif$ h == d $\nthen$
          (b: n) = h  $\tg{(*parse bit and nonce *)}$
          break
        $\nelse$ ())
  $\$$a2s.commit ; send $\$$a2s b ;
\end{lstlisting}
When the commitment is opened by \Z, if no bit $b$ was found above on line 21, then the open is ignored and no output is received by \Z from \Fcom.
If a $b$ was found, \simcom simply instructs the sender to open (\inline{$\$$a2s.open}) and, iteself, terminates.  

We offload the full code of \simcom to the appendix, but it should be clear that in such full-information protocols, simulting the real world (in this case just the random oracle), suffices to create an identical view to the environment.





