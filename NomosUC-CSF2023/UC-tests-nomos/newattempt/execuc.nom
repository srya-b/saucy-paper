
stype EtoZ[a] = +{ init: a ^ list[Int] -> &{start: exec} }
stype exec = &{ pump: out }
stype out = +{ reset: exec, 
					 		 output: Bit -> 1 } ;

stype execout{n} = <{n}| &{ exec: +{ out: Bit -> 1 }} ;

proc wait_for_terminate : (#z: EtoZ) |- ($d: execout) =
{
	$z <- acquire #z ;
	case $z (
		output => 
			b = recv $z ;
			$d.output ; send $d b ;
		reset => (* this is the pump operation releasing control to the environment *)
			#z <- release $z ;
	    $d <- wait_for _terminate #z ;
	)
}


proc execUC[K][K1][p2f,f2p][z2p,p2z][a2p,p2a],[f2a,a2f]{p2fn,f2pn}{z2pn,p2zn}{a2pn,p2an}{f2an,a2fn}{n}:
	(k: Int), (rng: [Bit]) |- ($d: execout{n}) =
{
	case $d (
		exec => get $d {n} ;
	    #z_to_pw <- channel_init[K][z2p]{z2pn} ; 
	    #pw_to_z <- channel_init[K][p2z]{p2zn} ; 

	    #pw_to_f <- channel_init[K][p2f]{p2fn} ; 
	    #f_to_pw <- channel_init[K][f2p]{f2pn} ; 

	    #a_to_pw <- channel_init[K][a2p] ; 
	    #pw_to_a <- channel_init[K][p2a] ; 

	    #a_to_f <- channel_init[K][a2f][K] ; 
	    #f_to_a <- channel_init[K][f2a][K] ; 
	    
	    #z_to_a <- channel_init[K][z2a][K] ; 
	    #a_to_z <- channel_init[K][a2z][K] ; 

	    #z <- PS.env <- k rng #z_to_pw #pw_to_z #z_to_a #a_to_z ;
	    case #z (
	    	init =>
	    		sid = recv #z ;
	    		clist = recv #z ;
	    )
	    
	    $pw <- party_wrapper[K][K1][p2z,z2p][p2f,f2p][p2a,a2p] <- 
	    				k rng sid clist #pw_to_z #z_to_pw #pw_to_f #f_to_pw #pw_to_a #a_to_pw #z ;

	    $f <- f_wrapper[K][K1][f2p,p2f][f2a,a2f] <-
	    				k rng sid clist #f_to_pw #pw_to_f #f_to_a #a_to_f #z ;

	    $a <- PS.adv[K] <- k rng sid clist #a_to_z #z_to_a #a_to_pw #pw_to_a #a_to_f #f_to_a #z ;

      #z.start ;
	
	--$d <- wait_for_terminate #z ;	
}

	
