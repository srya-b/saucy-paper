(* TODO: need some kind of functor here, but we can't give processes as parameters *)

proc compose[z][p][s]:
	(k: Int), (rng: [Bit]), (sid: SID[s]), (pid: Int),
	($z2p: z) |- ($p2f: p) =
{
	$ch <- PS.rho <- k rng sid pid $z2p ;
	$p2f <- PS.pi <- k rng sid pid $ch 
}


proc compose[K][s][z2rho][rho2z][pi2f][f2pi][rho2f][f2rho]{rho2fn}{f2rhon}
	(k: Int), (rng: [Bit]), (sid: SID[s]), (pid: PID),
	(#z2p: comm[K][z2rho]{z2rhon}), (#p2z: comm[K][rho2z]{rho2zn}), (#p2f: comm[K][pi2f]{pi2fn})
	(#f2p: comm[K][f2pi]{f2pin}) |- ($ch: 1) =
{
	#rho2pi <- channel_init[K][rho2f]{rho2fn} ;
	#pi2rho <- channel_init[K][f2eho]{f2rhon} ;

	<- rho <- k rng sid pid #z2p #p2z #rho2pi #pi2rho ;
	<- pi <- k rng sid pid #rho2pi #pi2rho #p2f #f2p ; 
}


(* for coin flip *)

proc prot[K] :
	(k: Int), (rng: [Bit]), (sid: session[coms]), (pid: PID),
	(#z2p: comm[K][comp2f][1]), (#p2z: comm[K][comf2p][1]),
	(#
