In this section we expand on the real world protocol that realizes \Fcom in the \Fropp-hybrid model.
The type of \Fropp in Figure~\ref{fig:fropptype} builds on the \Fro type presented in Section~\ref{sec:commitment}. 
Because the receiver must receive a message \Fropp and potentially send it a hash query, we split communication between two uni-directional channels.
The adversary type with the functionality which that lets it query hashes isn't shown but requires 1 unit of import to be sent along with a query. 

\begin{figure}
\begin{center}
	\parbox{0cm}{
	\begin{tabbing}
		$\m{sender}[a] =  \ichoice{ $\=$ \mb{query}: \textcolor{red}{\paypot^2} \m{PID} \product \tgr{\m{Int}} \product \m{sender}[a],$ \\
		\>$\mb{sendmsg}: \textcolor{red}{\paypot^1} \m{ PID} \product \m{a} \product \m{sender}[a]}$ \\
		$\m{shash} = \echoice{ \mb{hash}: \m{ PID} \arrow \tgr{\m{Int}} \arrow \m{hash}}$ \\
		$\m{rquery} =  \ichoice{ \mb{query}: \textcolor{red}{\paypot^1} \m{PID} \product \tgr{\m{Int}} \product \m{rquery} }$ \\
		$\m{receive}[a] = \echoice{ $\=$\mb{hash}: \m{PID} \arrow \tgr{\m{Int}} \arrow \m{receive}[a],$ \\
		\>$\mb{msg}: \textcolor{red}{\getpot^1} \m{PID} \arrow \m{a} \arrow \m{receive}[a]}$
	\end{tabbing}}
\end{center}
\caption{The two types for each of the committer and receiver. The first to types are the senders type to \Fropp and the next is received from \Fropp, and the same holds for the next two and the receiver. Two units of import are sent with a message from the committer. One is sent to the receiver so that it has enough import to query the oracle and check the commitment.}
\label{fig:fropptype}
\end{figure}

Due to the fact that there is a single channel connectig the \partywrapper and the functionality, the amount of import send from the \partywrapper to the wrapped \F is constant. Similarly, a constant amount of import is sent back from \F to the \partywrapper.
Recall from Section~\ref{sec:basic}, that as a result of this construction some messages may be sent with more import to the wrapped processes than required.
In general, despite the import on the session type, setting the parameters for that constant amount of import requires careful consideration in order to ensure that the \partywrapper has enough import to handle all messages parties may send out. 

In order to realize the communication attern where the receiver gets no input (and hence no import) from \Z, the type parameters to the providerless channels between, for example, \Z and \partywrapper need to be 4 units of import.  Similarly, as the session type of \Fropp indicates, 2 import is sent from \partywrapper to wrapped \Fropp and 1 import back. 

\begin{figure}
\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, frame=single, mathescape]
$\tg{(* committer code after receiving a 'commit'}$
        $\tg{message from the environment *)}$
b = $\nrecv$ $\$$z2p ;
$\nget$ $\$$z2p {2} ;
bits = sample (k-1) rng ;
$\$$p2f.query ;
$\npay$ K {2} $\$$p2f ;
$\nsend$ $\$$p2f pid ;
$\nsend$ $\$$p2f (b || bits) ;
$\ncase$ $\$$f2p (
  hash => pid = $\nrecv$ $\$$p2f ; 
    h = $\nrecv$ $\$$p2f ;
    $\$$p2f.sendmsg ;
    $\nsend$ $\$$p2f pid 2 hash;
	$\npay$ K {2} $\$$p2f ;
\end{lstlisting}
\caption{The code for the committer in $\prot{com}$ when it receives a \msf{commit} message from \Z. It obtains a hash of the message from \Fropp over \msf{p2f} and sends it to the receiver (pid=2) through the same functionality.}
\label{lst:committer}
\vspace{-2mm}
\end{figure}

\begin{figure}
\begin{lstlisting}[basicstyle=\footnotesize\BeraMonottFamily, frame=single, mathescape]
$\tg{(* receiver waiting for the commitment opening}$
        $\tg{from the random oracle channel *)}$
sender = $\nrecv$ $\$$f2p ;
p = $\nrecv$ $\tm{recv}$ $\$$f2p ;
b:hs = p
$\nget$ $\$$f2p {1} ; 
$\tg{...}$
$\tg{(* query the hash of b || hs with 1 import *)}$
$\tg{...}$
h = $\nrecv$ $\$$p2f ;
$\nif$ h == hash
$\nthen$
  $\$$z2p.open
$\nend$
\end{lstlisting}
\caption{The code for the receiver checks for a new message and receives the bit and nonce from the committer. If the hash of the bit and nonce matches the commitment it received, it returns \msf{open} to \Z to confirm the commitment.}
\label{lst:receiver}
\vspace{-3mm}
\end{figure}

In Figures~\ref{lst:committer} and \ref{lst:receiver} we see the code for the committer reacting to a $\mb{commit}$ message from \Z and the receiver reacting to an open commit from the committer, respectively. 

%\subsection{Simulation}
%Finally, we present a simulator \simcom, for the dummy adversary, for which the \Fcom is realized by \prot{com} in the \Fropp-hybrid world.
%Recall that the import requirements for the ideal world, in this case for \Fcom. Therefore, the simulator is parameterized by import parameters required in the real world for the parties of $\pi_\m{com}$ and \Fro.
%The simulator is straightforward and internally maintains a table like \Fro and responds to the environments queries for hashes. 
%When the receiver is corrupt:
%\begin{itemize}
%\item \simcom responds with \inline{P2A2Z(2, no)} to all messages by \Z to get a message from the functionality
%\item On \inline{Committed} by the ideal receiver, \simcom generates a random $r$ and sends \inline{P2A2Z(2, RHash(h))} with no import.
%\item On \inline{Open(b)} from the ideal receiver, \simcom generates a random nonce $x$ and stores \inline{b+x : h} in its \Fro table, and sends \inline{Yes(1, (b,x))} to \Z when asked for messages for the corrupt receiver.
%\end{itemize}
%
%The corrupt committer is not much different from the above case. In this case
%the simulator stores the bit $b$, the none $x$, the corresponding hash $h$, and the import that \Z uses to create a commitment.
%When the simulator receives the message to send the commitment to the receiver, it tells the ideal world committer to commit to $b$ along with 2 import given by \Z, and when it's told to open the commitment it opens it in the ideal world. 
%
%It is immediately clear that this simulator satisfied $\Fro \xrightarrow{\prot{com}} \Fcom$ for the dummy adversary.

