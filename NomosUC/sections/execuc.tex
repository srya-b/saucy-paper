In this section we describe how the UC experiment and composition theorem are defined in NomosUC.
We also express a critically important result in the UC framework: the dummy lemma, and a composition theorem.
An important part of our definition is using code-generation techniques~\cite{somecodegeneration} to constructs some processes in the UC experiment as well ass useful operators to achieve full composition in the sense of Canetti et al.~\cite{uc}.

We first introduce some convenient notation.
For the remainder of this section, when we refer to a protocol, we actually refer to a pair of ITMs as in Definition~\ref{def:protocol}.
\begin{definition}\label{def:protocol}
A \textit{protocol} is a pair of terms ($\pi$, $\mathcal{F}$) where $\pi$ is the protocol run by honest parties and \F is an ideal functionality that parties an access.
\end{definition}
In the ideal world, $\pi$ is replaced by an an ideal protocol, \idealP, which is a dummy protocol: it frorwards message between \Z to \F for honest parties  and between \A and \F for corrupt parties.
In the real world, \F is called the \textit{hybrid functionality} and stands in for a real protocol that emulates it.
For protocols that don't make calls to any hybrid functionality, \F is just the dummy protocol which does nothing on activation by any other ITM.
The dummy functionality accepts all messages, does nothing, and continues to wait for more messages.

\subsection{The UC Experiment}
The UC experiment is an execution of a main protocol, called the \textit{challenge protocol}, consisting of protocol parties and an ideal functionality, reacting to input by an adversary \A or the \Z.
The expeirment is created by an \inline{execUC} functio which spawns all the relevant processes: the environment, a \inline{protocol wrapper}, the adversary, the \inline{functionality wrapper}.
The protocol and functionality wrappers encapsulate the protocol parties and the ideal functionality, respectively, and are carefully constructed to enable correct composition in NomosUC.
We motivate their use and explain how they work later in this section, but point out that they enable greater flexibility in using session types.

The statically-typed nature of NomosUC requires generic process like \inline{execUC} to be parametric in the message and the import token types of the protocol and functionality being executed.
Despite this, we opt to generate a unique version of \inline{execUC}, for each set of \Z, \F, $\pi$, and \A, based the virtual token types it requires.
In general, a process in the execution can internally simulate any number of processes which, in turn, may simulate processes themselsves.
Therefore, \inline{execUC} needs to be generated to accept a variable number of virtual token types are parametes.
For the commitment example we've used throughout this work, the ideal world \inline{execUC} process definition looks like this:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape, caption={The process definition of the \msf{execUC} function.}]
$\tb{proc}$ $\tm{execUC}$[K][K1][z2p][p2z]...{z2pn}{p2zn}... :
  (k: $\tgr{int}$), (r: [Bit]) |- ($\$$d: Bit)
\end{lstlisting}
In this example, a virtual token type, \inline{K1}, is used because of the \emph{protocol wrapper} and the \emph{functionality wrapper}. \anote{Mention here that $k$ is a security parameter, $r$ is the for the random choices}
The protocol wrapper internally runs and manages all of the protocol parites and the functionality wrapper does the same with the ideal functionality.
For this reason, every execution in NomosUC that uses the protocol wrapper and/or the functionality wrapper will \emph{always} require at least one virtual token type.

%\begin{figure*}
%\input{listings/execuc}
%\caption{The \msf{execUC} function used for the two-party commitment example used througout this paper. Recall, the \msf{execUC} is customized insofar as it takes in some number of virtual token types (here, $K_1$) to enable machines that simulate other machines. In the commitment example, there is no such simulation happening at the protocol or functionality level, therefore only the real token type $K_1$ is used here. The funtion spawns all the necessary ITMs in the UC execution: the environment, the protocol wrapper, the functionalty (wrapped), and the adversary. Each is parameterized with the security parameter $k$ and a random bit sequence $\msf{rng} \in \{0,1\}^{poly(k)}$.
%At the end, the environment is started and it returns a bit $b$ which is its guess for which world it is in. The full code can be found in the Appendix.}
%\label{lst:execuc}
%\end{figure*}

We separate NomosUC into two modules: generic code and protocol-specific code. 
Therefore, the \inline{execUC} refers to user specified code through the \inline{PS} module which defines \inline{PS.env} for \Z, \inline{PS.func} for the functionality, \inline{PS.prot} for the protocol, and \inline{PS.adv} for the adversary.
All communication between these processes happens through communicators---introduced in Section~\ref{sec:nomosuc}.
Messages between the main machines: the protocol wrapper, \A, \Z, and \F happen with parameteric types
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
$\Type$ p2zmsg[a] = P2Z of pid ^ a ;
$\Type$ p2fmsg[a] = P2F of pid ^ a ;
$\Type$ f2pmsg[a] = F2P of pid ^ a ;
\end{lstlisting}
where \inline{a} is the protocol-specific message type.

\paragraph{The Environment}
The environment is the first machine that \inline{execUC} spawns and receives from it the session id and list of corrupted parties for this execution.
Its type specifies the interaction between \inline{execUC} and \Z:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, mathescape, frame=single]
$\Type$ EtoZ[a] = +{init: a ^ list[pid] -> exec} 
$\Type$ exec = &{start : output_bit} ;
$\Type$ output_bit = +{bit: Bit -> 1} ;

$\tb{proc}$ PS.env[K][z2p,...]{p2zn,...} : 
  (k: $\tgr{int}$), (r: [Bit]), 
  (#ztop: comm[z2pmsg[z2p]]{z2pn}),
  (#ptoz: comm[p2zmsg[p2z]]{p2zn})...
    |- ($\$$z : EtoZ)
\end{lstlisting}
The environment also accepts communicators, as parameters, for communication with the protocol parties and the adversaries (in both directions), and it must offer a channel of type \inline{EtoZ}.
The type (above) states \Z provides an \emph{sid} of some user-defined type \inline{a} and a list of the \emph{pid}s of corrupted parties. 
Finally, \inline{execUC} instructs it to \inline{start} (\emph{external choice}) and return a bit $b$ as its guess for which world it is in.

%The \inline{\{z2pn\}}, for example, specifies the amount of import that must be sent by \Z with every message to a protocol party.
%The rest of the processes---the adversary, protocol wrapper, and functionality--are declared in the same way except the type parameters they expect are different: the protocol wrapper would of course accept type parameters for communication between it and \F, \A, and \Z.
%Finally the type of the offered channel \inline{$\$$z} is the same for all environments and communicates the \inline{sid} and set of corrupt parties chosen by \Z to \inline{execUC}.
%The \inline{sid} and corrupt list are parameters to the rest of the processes that \inline{execUC} spawns. 

%The communicators created by \inline{execUC} always use the same parametric types. 
%For example, for communication with the protocol, the types look like:
%\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
%$\Type$ p2zmsg[a] = P2Z of pid ^ a ;
%$\Type$ p2fmsg[a] = P2F of pid ^ a ;
%$\Type$ f2pmsg[a] = F2P of pid ^ a ;
%\end{lstlisting}
%Subsequently, the channel from \Z to the protocol wrapper will be typed as: \inline{comm[z2pmsg[z2p]]\{z2pn\}} where \inline{z2p} is a protocol-specific message type.
%The protocol \inline{PS.prot} is not spawned by \inline{execUC}. Instead the process spawns the protocol wrapper (described below) which spawns parties with that run the code \inline{PS.prot}.
%When in the ideal world, the protocol is given as the ideal protocol: one where the protocol wrapper converts the message from type \inline{z2pmsg[a]} to type \inline{p2fmsg[a]} but forwards the contents unaltered.
%The protocol wrapper and functionality wrapper manage spawning the instance(s) of the functionality and protocol parties.
%Similarly, an environment \msf{PS.env} and adversary \msf{PS.adv} must be defined as well.
%The message types exchanged between the processes are provided directly to \msf{execUC} as type parameters of the form \msf{p2f}, \msf{f2p}, and so on. 
%The first thing \inline{execUC} does is create the communicators and the corresponding channels for the main processes of the execution. 

\todo{look at latex comment under this: do we need to mention that communicators use +1 import token?}
%A consequence of using communicators is that in the UC setting they require at least 1 unit of import, beacuse they are activated a potentially polynomial number of times. 
%Therefore, all communicators in NomosUC receive some amount of import $n$ and send out only $n-1$. 
%The user-specified protocol, environment, functionality, and adverasary must account for this to ensure suffiient import is given to them.
%\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
%#ptoz <- communicator_init[K][p2zmsg[p2z]]
%           {p2zn+1} ;
%#ztop <- communicator_init[K][z2pmsg[z2p]]
%           {z2pn+1} ;
%...
%\end{lstlisting}
%This is strictly a design decision where user-defined protocols only specify import token requirements for the protocol not taking communicators into account. 
%The processes that they write, though, must conform to this standard and send an import token in addition to the amount they need.
%An alternate design would be that all import type parameters take the additional import token into account and communicators send one less than they receive.
%The drawback of the latter approach is that that when communicating with a process directly rather than through communicators (say, when simulating), you're sending one extra token for no reason.

%Next, the environment \msf{PS.env} is spawned, \inline{execUC} receives the \inline{sid} and corrupt list from \Z, and, finally, the remainder of the processes are spawned with these inputs. 
%Finally, the environment executes its own code when activated by \msf{\$z.start}, given the initial amoutn of import \inline{n}, and returns a bit through \inline{$\$$z.output_bit} which is its guess whether it's in the real or ideal world:
%\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
%$\$$z.start
%$\tb{pay}$ $\$$z {n}
%$\$$d <- $\$$z
%\end{lstlisting}

\subsection{The Protocol Wrapper}
NomosUC introduces a new construct called the \textit{protocol wrapper}, that spawns and runs the protocol parties internally.
It is a necessary construct to enable a certain class of functionalities that accept input from a dynamic set of parties. One such functionality is the random oracle \Fro, an ideal hash function, which we use to realize \Fcom in the next section.
For functionalities like \Fcom which accept only a fixed number of parties, all ITMs can be directly connected without wrappers, however, for all executions in NomosUC, the protocol and functionality wrappers are always used.

Like \inline{execUC}, the protocol and functionality wrappers are generated based on the protocol and functionality being executed.
We illustrated the internals of the protocol wrapper for a protocol with two spawned parties in Figure~\ref{fig:blanpartywrapper}.
In order to use session types, the each protocol party is internally connected to two processes \inline{z2p} and \inline{f2p} over with session-typed channels for their communication with \Z and \F, respectively.
\inline{z2p} is connected to party-specific virtual communicators so that \inline{z2p} and \inline{f2p} can read/send messages from. It can not read/write directly to/from the actual communicators connecting the protocol wrapper because, being simulations inside the protocol wrapper, they do not use the same token type.
In the case of the ideal world with \Fcom, the both of the sender's ($\pi_1$) channel with \inline{z2p} channels with \inline{z2p} and \inline{f2p} are typed as \inline{sender}, and the protocol party itself ($\pi_1$) just fowards messages from one channel to the other.

The processes \inline{Z2p} and \inline{f2p} are generated for each party based on their session-type, and they convert between them and functional messages for incoming/outgoing communcation with \Z, \F, or \A. 
For example in the commitment example, where the functional message typed is given by: 
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, mathescape]
$\yo{type}$ comp2f = Commit of Bit | Open ;
$\yo{type}$ comf2p = Committed | Open of Bit ;
\end{lstlisting}
the \inline{z2p} process does something like this: 
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
case msg (
  Commit(b) =>
    $\$$z2p.commit ;
    $\tb{send}$ $\$$z2p b ;
    $\tb{pay}$ {z2pn} $\$$z2p ;
\end{lstlisting}
For protocols were a dynamic set of parties can exist, the protocol wrapper simply spawns new ones along with their respective virtual communicators, \inline{z2p}, and \inline{f2p} processes.

\begin{figure}
\centering
\includegraphics[scale=0.5]{figures/blankpartywrapper2.pdf}
\caption{The internals of the protocol wrapper with two parties. The arrows indicates the client/provider relationship between each pair: provider $\rightarrow$ client. The wrapper creates \texttt{z2p} to offer a channel and convert from gunctional to message type---the \texttt{p2f} do the same. A communicator is used because \texttt{z2p} cannot send message to real one with differing token type. The types of the processes offered are (color): \tgr{comm[z2pmsg[comp2f]]}, \tb{sender}, \tr{party[Int]}, \tp{comm[p2fmsg[rop2f]]}. }
%The processes \texttt{z2p} offer linear channels to their respective protocol parties that are typed according to that party's protocol, and they receive messages from virtual communicators that hold messages specific to one \texttt{pid}. The protocol code for $\pi_1$ and $\pi_2$ are user-specified and offer a channel to the \texttt{p2f} process according to their protocol with the functionality. The \texttt{p2f}s convert outgoing messages to, and incoming messages from, functional message types to be sent to/from the functionality. The protocol wrapper gives messages to the virtual communicators and receives messages from \texttt{p2f}s.}
\label{fig:blankpartywrapper}
\vspace{-1.5em}
\end{figure}

%For the commitment example, if $\pi_1$ and $\pi_2$ ran the commitment protocol, \inline{z2p} would offer a channel of type \inline{sender} and \inline{receiver} to $\pi_1$ and $\pi_2$, respectively, and it converts between the functional messages for the commitment protocol and the session typed ones. 
%In the ideal world, the $\pi_1$ and $\pi_2$ run a dummy protocol where their offered channels are simply forwarded to their \inline{z2p} channels, i.e. the \inline{z2p} and \inline{f2p} channels have the same type: \inline{sender} and \inline{receiver}, respectively.
%In the style of Nomos, the protocol wrapper:
%\begin{itemize}
%	\item Attempts to read messages incoming from \Z, \A, or \F and forward them to the appropriate process depending on \inline{pid}.
%	\item Read from the internal communicators or the \inline{p2f} processes for outcoing messages.
%\end{itemize}
%For reference the functional messages typed for the commitment protocol are:

%Recall the session types for the sender and receiver, with \Fcom, introduced in Section \ref{subsec:idealcommitment}.
%%\begin{gather}
%%	\mi{stype} \; \m{sender} = \ichoice{\mb{commit} : \m{bit} \product \m{scommitted}} \\
%%	\mi{stype} \; \m{scommitted} = \ichoice{\mb{open} : 1} \\
%%	\mi{stype} \; \m{receiver} = \echoice{\mb{commit} : \m{rcommitted}} \\
%%	\mi{stype} \; \m{rcommitted} = \echoice{\mb{open} : \m{bit} \arrow \one}
%%\end{gather}
%At the beginning there are no parties. When the \A or \Z write to a party with some pid $p$ the protocol wrapper creates $p$ if it does not exist.
%It creates and stores the session-typed channels or all of the parties in channels corresponding to their type and moves channels between them as the type evolves.
%For example for parties' channel with \Z the protocol wrapper generates the following lists:
%\begin{gather}
%	\m{R1L1}[\m{sender}] \\
%	\m{R1L2}[\m{scommitted}] \\
%	\m{R2L1}[\m{receiver}] \\
%	\m{R2L2}[\m{rcommitted}] 
%\end{gather}
%At the beginning of the protocol, the committer's \msf{z2p} channel would be in \inline{R1L1} and the receiver's is in \inline{R2L1}.
%The channel's connection the protocol wrapper to the rest are still functionally typed. It's channel \inline{p2f} will still be typed \inline{#ptof: comm[p2fmsg[comp2f]]} where \inline{comp2f} is:
%Succinctly, the protocol wrapper functions as follows:
%\begin{itemize}
%\item When the protocol wrapper receives a message for some \msf{pid}, if the party doesn't exist the protocol wrapper creates all the party's channel parameterized by the correct session types (the role of the party is determined by the incoming message). The channels are stored and outgoing channels are waiting to be read from.
%\item The message sent to the party with the session type is determined by the functional type. The wrapper creates a session-typed message and forwards the contents of the message to the party.
%Despite accepting functionally typed messages, the protocol wrapper uses session types in this way to allow the type checker to catch invalid and out of order environments, adversaries and functionalities. 
%For example, in the commitment protocol when the committer tries to commit a bit in \Fcom like this:
%\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
%$\$$p2f.commit 
%$\tb{send}$ $\$$p2f b
%$\tb{pay}$ {p2fn} $\$$p2f
%\end{lstlisting}
%\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
%$\$$p2f.SEND 
%$\tb{send}$ $\$$p2f pid 
%$\tb{send}$ $\$$p2f Commit(b)
%$\tb{pay}$ {p2fn} $\$$p2f
%\end{lstlisting}
%The party wrapper intercepts and converts it to a functionally typed message:
%\item For outgoing messages, the protocol wrapper does a similar conversion where it reads the sesion typed channel output by the party and converts its message to the appropriate functional message type.
%\end{itemize}

\paragraph{Functionality Wrapper}
The functionality wrapper adopts a similar approach to except it only needs to handle one functionality.
Functionalities in NomosUC that allow a static set of parties generally accept one linear channel per party as parameters. For example, \Fcom takes in a separate channel for \inline{S} and \inline{R}.
The functionality wrapper, similar to the protocol wrapper, creates communicators for each party as well as a process that connects to the functionality and converts between functional and session-typed messages.
It also supports dynamic functionalities, but only those whose type is of a specific form: for every interaction with a party the session type returns to it's original value.
Consider the sessio type for \Fro below.
\begin{mathpar}
\m{party}[a] = \textcolor{red}{\getpot^1} \ichoice{\mb{hash} : \m{pid} \arrow \m{int} \product \m{hashing}[a]} \\
\m{hashing}[a] = \echoice{\mb{shash} : \m{pid} \arrow \m{int} \product \textcolor{red}{\paypot^0} \m{party}[a]} 
\end{mathpar}
When a party invokes \Fro, the type it expects is \inline{party[a]}, and when it has received its hash the type is again back at \inline{party[a]}. 
The wrapper handles such dynamic functionalities by channeling all party communication through one linear channel in the wrapper. 
Therefore, \Fro reads on one channel and responds to the specific party with some \inline{pid}, and the protocol wrapper remains unchanged. 

The constructions of the protocol wrapper and functionality wrapper enable users to write very simple ideal functionality and protocol code, as we will discuss in the next Section and in the Appedix.

%In the commitment example, \Fcom accepts two channels, one from each party, and two processes are created (call then \inline{p2f} for now) which offer channels of type \inline{sender} and \inline{receiver}, respectively. 
%The wrapper differs from the protocol wrapper for certain functionalities that accept a dynamic number of parties. 
%Continuing with our commitment example, the random oracle functionality, an idealized hash function, is used in the real world to realize \Fcom, and it allows a dynamic set of parties to inteact with it.
%Its session type with protocol parties is given below.
%The session type is special in that, for every interaction, the channels type always ends up back at \inline{party[a]} before any other party tries to use \Fro.
%NomosUC enables ideal functionalities whose types work like this by adding the \inline{pid} to the type, and having only one process in the functionality wrapper offering a channel of this type to \Fro.
%Unlike \Fcom where new communicator and \inline{p2f} process is created for each new party, messages from all parties pass through one such process.
%Additionally, moving the \inline{pid} into the session type means that the protocol wrapper can create arbitrarily many \inline{pid}s to communicate with \Fro.

\paragraph{The Adversary}
Like the environment and unlike the protocol parties and functionality, we don't require a wrapper around the adversary that lets it use session types directly.
The adverasry is user-defined, and it provides input to the protocol ITMs of the executio like the environment and their session types suffice to enforce protocol ordering in the type system.
In general, as we'll see when we discuss composition, it is only important that the functionalities and protocols use session types. 

\subsection{Polynomial Bound}
An important constribution of this work is supporting runtime analysis in UC with a notion of ``polynomial'' time.
The UC framework provides a way to define poylynomial time computation and resource-bounds through the import mechanism.
It ensures that a single ITM's execution is upper-bounded by some value $T(n)$ where $T$ is a poynomial and $n$ is the total units of import the ITM eve receives.
An suitable analogy for import are tokens: a machine can receive tokens, send them out, and is limited in capability by the net number of tokens it holds. 

In NomosUC, we build import into the type system and allow reasoning about ITMs being polynomial both locally and in the context of other ITMS (say, \F is polynomial locally and when connected an adversary \A).

\begin{definition}[PPT Term]\label{def:pptterm}
A \textit{PPT term} is a \textit{well-typed} term $e(k, r)$ that is \textit{closed} except for security parameter $k$, random bit sequence $r$.
\end{definition}

We first-define terms that are well-typed in the traditional session-types-sense in Definition~\ref{def:pptterm}, i.e. without any resource constraints~\cite{sessiontypes}.
Such terms are closed except for the security parameter $k$ and some uniformly random bit sequence $r$. 

However, we also want to reason about terms that are well-typed when connected to another Nomos terms.
We introduce the term \textit{well-matched} to mean a PPT term $e$ is well-typed when connected to another term $e'$.i
Simply put, the channels that $e$ and $e'$ share are of the same type. 
Specifically, we want to exclude processes that logically share a channel, say the channel from \inline{p} to \inline{f}, but send (their types message types don't match).
This new definition becomes important when we discuss UC emulation below as we want to reason about environments that are \textit{well-matched} for a protocol $\pi$ or a specific adversary \A.

\begin{definition}[Well-Matched]\label{def:wellmatched}
\begin{mathpar}
\footnotesize
\inferrule*[right=Well-matched]
{\Tokens_1, K \semi \Delta_1 \vdash C_1 :: \Delta_1' \semi 
\Tokens_2, K' \semi \Delta_2 \vdash C_2 :: \Delta_2' \\ \\
 S \equiv \Delta_1 \bigcap \Delta_2 \neq \emptyset}
{\Delta_1 \equiv_{S} \Delta_2 \semi K \equiv K'} 
\end{mathpar}
\end{definition}

Notice that in Definition~\ref{def:wellmatched} we are concerned with two terms that are \textit{open} even when connected. 
We only care about being well-matched, when connected to another term, on the channels over which they are connected.

Next we introduce our definition of a polynomial-bound in the security parameter $k$.
Terms that are PPT in $k$ are dubbed \textit{well-resource-typed}.
\begin{theorem}[PPT in $k$]\label{thm:ppt}
A \textit{PPT Term} $e(k, r)$ is well-resource-typed if, given initial import $n(k) \in poly(k)$, there exists a polynomial $T$ s.t. $\forall k, r, e(k, r) \{n(k)\}$ terminates in at most $T(n)$ steps. 
\end{theorem}

\begin{proof}
The Nomos type system only type checks programs for which a satisfying assignment of polynomial $T$ is possible.
Given an $n \in poly(k)$, all programs that type check must be \textit{well-resource-typed.}
%The Nomos type system guarantees that a satisfying assignment of $n$ and $T$ will correctly type-check.
%Therefore, given an initial amount of import $n(k) \in poly(k)$, the existence of some $T$ ensures that any process, regardless of its randomized execution according to the bit sequence $r$, $e$ is guarantees to be upper-bounded by $poly(k)$ satisfying the definition of probabilistic polynomial time in $k$.
\end{proof}

\subsection{Emulation}
A proof of security in the UC framework relies upon emulation of different executions.

In general, we say that a protocol $\pi$ posesses the same security properties as another protocol $\phi$ if no environment can distinguish between them for any adversary.
In most cases we compare a real protocol $\pi$ with an idealized protocol $(\idealP, \F)$ which is actually just an ideal functionality with dummy parties.
The ideal functionality is known to achieve the desired security processes because it acts like a simple, trusted third party.
%They are much simpler than protocols because they don't require any special code to handle mutually distrustful other processes, and they perform the given computation on behald of the ideal world parties.

Given the random choices ITMs in UC can make, it is clear that the outputs of \inline{execUC} produces and ensemble of distributions over all possible random bitstrings and security parameters.
Emulation, then, is about the ensembles created by two UC environments being indistinguishable from each other.
We define indistinguishabiliy between ensembles in a standard way using \textit{statistical distance} in Definition~\ref{def:distance}.

\begin{definition}[Indisinguishability]\label{def:distance}
Two ensembles $\mathcal{D}_{1,k}, \mathcal{D}_{2,k}$ are indistinguishable, $\mathcal{D}_{1,k} \sim \mathcal{D}_{2,k}$, if their statistical distance is at most $negl(k), \forall k$.
\end{definition}

\paragraph{Validity}
For the remainder of this section we refer to \emph{valid} adversaries and simulators given a particular protocol, functionality, or environment.
We refer to adversaries that type-check when connected to \Z, \F, or $\Pi$ by \inline{execUC}, and that are \emph{well-matched} as defined above. 


%\paragraph{Valid Protocols}
%We want to make a clarification to what are considered \textit{valid} functionalities, protocols, and environments.
%When we talk about a valid functionality, we expect it to take as parameters channels to/from \A, \Z, and the protocol wrapper.
%We also care about what it means for an entity, say an adversary, to be well matched with the functionality or protocol.
%It means that the types of the channels they expect are the same.
%Clearly, an adversary for protocol $\pi_1$ may not be well-matched with some other protool $\pi_2$.
%When talking about emulation we care about ensuring well-matchedness between adversaries and environments/protocols.
%We use the notation $\msf{validP}$ and $\msf{validF}$ to denote valid protocols and functionalities, and we use the notation $\A \leftrightarrow \F$ to denote that that the two processes are well-matched.

%Before we introduce the emulation definition, we first define valid protocols, valid functionalities, and what it means for protocols, functionalities, adversaries, and environments to be well-matched with each other.
%We shorten the communicator type \msf{comm} to \msf{c} in the following definitions.
%
%\todo{Ankush: The context of a valid functionality must contain channels typed with the type parameters given by \msf{execUC}. An the machine, parameterized with security parameter $k$ and random bit sequence $r$ are bounded by some polynomial $T_\F$. $\leftarrow$ the last part is meant to capture the well-resource-typed (from the well-matched definition), but maybe we can just say $\F$ is well-resource-typed given $k$,$r$}
%\begin{definition}[Valid Functionality]\label{def:validfunc}
%\begin{mathpar}to one of footnotesize
%\inferrule*[right=valid-F]
%{\exists c_1:c[\msf{p2f}], c_2:c[\msf{f2p}], c_3: c[\msf{f2a}], c_4:c[\msf{a2f}] \in \Delta_1 \\
%\Delta_1 \models (\F(k, r) : T_\F) :: \Delta_1'}
%{\msf{validF}\ \F \rightarrow \Delta_1'}
%\end{mathpar}
%\end{definition}
%
%\todo{The intent is the same as above here execpt for protocol having channels with the right types. Again here I could just say $\pi$ is well-resource-typed instead of the $\pi(k,r)$ that is there now.}
%\begin{definition}[Valid Protocol]\label{def:validprot}
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=valid-P]
%{\exists c_1: \msf{p2f}, c_2: \msf{f2p}, c_3: \msf{p2a}, c_4: \msf{a2p}, c_5: \msf{z2p}, c_6: \msf{p2z} \in \Delta_1 \\
%\Delta_1 \models (\pi(k, r) : T_\pi) :: \Delta_1' }
%{\msf{validP}\ \pi \rightarrow \Delta_1'}
%\end{mathpar}
%\end{definition}
%
%\todo{Ankush: this defines what it means for a protocol and functionality to be well-matched. Namely, they shared channels typed according to parameters given by execUc (p2f, f2p, ...) and have the same type and import parameters on their communicators}
%\begin{definition}[Well-Matched]
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=p2f match] 
%{\msf{validP}\ \pi \rightarrow \D_1 \semi \msf{validF}\ \F \rightarrow \Delta_2 \\
%\Delta_1:, (\msf{c}[K][\msf{f2p}]), (\msf{c}[K][\msf{p2f}]) \equiv \\
%\Delta_2, (\msf{c}[K][\msf{pid \textasciicircum f2p}]), (\msf{c}[K][\msf{pid \textasciicircum p2f}])}
%{\langle \pi \leftrightarrow \F \rangle}
%\end{mathpar}
%\end{definition}
%
%\todo{Ankush: same for this one and the rest, as above}
%\begin{definition}
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=p2a match] 
%{\msf{validP}\ \pi \rightarrow \Delta_1 \semi \A \rightarrow \Delta_2 \\
%\Delta_1:, (\msf{c}[K][\msf{a2p}]), (\msf{c}[K][\msf{p2a}]) \equiv \\ 
%\Delta_2, (\msf{c}[K][\msf{pid \textasciicircum a2p}]), (\msf{c}[K][\msf{pid \textasciicircum p2a}])}
%{\langle \pi \leftrightarrow \A \rangle}
%\end{mathpar}
%\end{definition}
%
%\begin{definition}
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=f2a match] 
%{\msf{validF}\ \F \rightarrow \Delta_1 \semi \A \rightarrow \Delta_2 \\
%\Delta_1:, (\msf{c}[K][\msf{a2f}]\{a2fn\}), ( \msf{c}[[K]\msf{f2a}]\{0\}) \equiv \\
% \Delta_2, (\msf{c}[K][\msf{a2f}]\{a2fn\}), ( \msf{c}[K][\msf{f2a}]\{0\})}
%{\langle \F \leftrightarrow \A \rangle}
%\end{mathpar}
%\end{definition}
%
%\begin{definition}
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=p2z match] 
%{\msf{validP}\ \pi \rightarrow \Delta_1 \semi \Z \rightarrow \Delta_2}
%{\Delta_1:, (\msf{c}[K][\msf{z2p}]), (\msf{c}[K][\msf{p2z}]) \equiv \\
% \Delta_2, (\msf{c}[K][\msf{pid \textasciicircum z2p]}), (\msf{c}[K][\msf{pid \textasciicircum p2z}])}
%\end{mathpar}
%\end{definition}

Indisintiguishability between two protocols is defined as follows (we shorten the communicator type \msf{comm} to \msf{c}):

\begin{definition}[Emulation]\label{def:emulation}
Given two protocols $(\pi, \F_1), (\phi, \F_2)$ that are well-resource-typed then if $\forall \A$ well-matched with $(\pi, \F_1)$, $\exists \Sim$ s.t. $\forall \Z$ well-matched with \A and $(\pi, \F_1)$: \Sim is well-matched with $(\phi, \F_2)$, \Z is well-matched with $(\phi, \Sim)$, and $\msf{execUC}(\pi, \F_1, \Z, \A) \approx \msf{execUC}(\phi, \F_2, \Z, \Sim)$:

\begin{mathpar}
\footnotesize
	\inferrule*[right=emulate]
	{
		. \models \msf{execUC}[\Tokentypes][\alpha] :: \Delta[\Tokentypes][\alpha] \\ \\ \\
		% Protocols that are well-matched with their functionalities
		%\pi \rightarrow \Delta_1' \semi \phi \rightarrow \Delta_2' \semi \\
		\pi : \Delta_1' \semi \phi : \Delta_2' \semi \\
		%\langle \pi \leftrightarrow \F_2 \rangle, \langle \phi \leftrightarrow \F_1 \rangle \\
		% Type of execUC[DELTA_pi] and execUC[DELTA_phi]
		\Delta_1'[\Tokentypes][\mathrm{T}_{\pi}] \equiv_{\Z} \Delta_1\ 
		\semi \Delta_2'[\Tokentypes][\mathrm{T}_{\phi}] \equiv_\Z \Delta_2 \\
		% For all A if exists well-typed A that is well-matched with real world
		%\forall \A, (\exists (\Delta_4, \Delta_4') | \Delta_4 \vdash \A :: \Delta_4', \langle \A \leftrightarrow \pi \rangle, \langle \A \leftrightarrow \F_1 \rangle \\
		\forall \A | \Delta_4 \vdash \A :: \Delta_4', \langle \A \leftrightarrow \pi \rangle, \langle \A \leftrightarrow \F_1 \rangle \\
		% implies simulator that is well-matched for ideal world
		\Rightarrow \exists (\Delta_3,\Delta_3') | \Delta_3 \vdash \Sim_\A :: \Delta_3', \\ % \langle \Sim_\A \leftrightarrow \phi \rangle, \langle \Sim_\A \leftrightarrow \F_2 \rangle \\
		% for all Z they that's well-matched for the real world => Z is well-matched with S and ideal world
		%\forall \Z (\langle \Z \leftrightarrow \A \rangle, \langle \Z \leftrightarrow \pi \rangle \Rightarrow \langle \Z \leftrightarrow \Sim_\A \rangle, \langle \Z \leftrightarrow \phi \rangle \\
		% and emulation has to hold
		\forall \Z \; \msf{execUC} \ \pi\ \Z\ \F_1\ \A \approx\ \msf{execUC} \ \phi\ \Z\ \F_2\ \Sim_\A))
	}
	{
		% EMULATION DEFINITION
		\lambda \A . \Sim_\A \vdash (\pi, \F_1) \sim (\phi, \F_2) % \F_1 \xrightarrow{\pi} \F_2
		%\lambda \A . \Sim_\A \vdash (\pi, \F_1) \sim (\phi, \F_2)
	}
\end{mathpar}
\end{definition}
The emulation definition above is quite straightforward. It starts with defining the protocols in question and their type under the type parameters passed to \inline{execUC}.
It then states that for all adversaries that are well-matched with $\pi$ and $\F_1$, there exists a simulator such that the two executions are indistinguishable. 
%The emulation definition above starts with two processes $\pi$ and $\phi$ that must conform to the type-parametric definition of all protocols and that they are respectively well-matched to two functionalities $\F_1$ and $\F_2$.
%It states that for all adversaries that are well-matched to both the protocol (real world) and the functionality (ideal world), there exists a well-matched simulator such that the two are indistinguisable for all environments. 
The definition ensures that for emulation to hold, the constructed simulator must be well-matched everywhere \A is well-matched: for all environments \A is well-matched with the \Sim must also be well-matched with.

\paragraph{UC Realize}
When we talk about emulation, we particularly care about emulation with respect to an ideal protocol $\phi$ which is really just $(\idealP, \F)$ where \idealP is the protocol which forwards all messages to/from \Z and \F.
We say the protocol $\pi$ (potentially with a hybrid functionality $\F_1$) UC-realizes an ideal functionality $\F_2$ if Definition~\ref{def:emulation} holds for $(\pi, \F_1)$ and  $\phi = (\idealP, \F_2)$

\begin{definition}[UC-Realize]
A protocol $\pi$ UC-realized an ideal functionality $\F_1$ if $(\pi, \F_2) \sim (\idealP, \F_1)$ for some $\F_2$.

\begin{mathpar}
\footnotesize
\inferrule*[right=UC-Realize]
{ (\pi, \F_1) \sim (\idealP, \F_2) }
{ \F_1 \xrightarrow{\pi} \F_2 }
\end{mathpar}
\end{definition}

\subsection{Dummy Lemma}
The Dummy Lemma is an important lemma in the UC framework that requires only one simulator to work with a dummy adversary in order to prove emulation with respect to any adversary.
The Lemma states that if a simulator exists for the dummy adversary, the dummy simulator \DS, then there exists a simulator for any other adversary \A. 
The simulator constructed in this lemma uses virtual tokens to internally run \DS and \A.

The intuition behind the proof of this lemma is that emulation with respect to the dummy adverasary holds even for environments that run the real world adversary internall and pass its output to \DS. 
Therefore, moving \A into the execution in both the real and ideal worlds should maintain emulation.

\begin{theorem}[Dummy Lemma]\label{thm:dummy}
If $\exists \DS$ s.t. $ \DA, \DS \vdash \F_2 \xrightarrow{\pi} \F_1$ then $\forall \A \ \exists \Sim_\A$ s.t. $\Sim_{\A} \vdash  \F_2 \xrightarrow{\pi} \F_1)$ 
\end{theorem}

\begin{proof}
The constructed simulator $\Sim_\A$ internally simulates \DS and \A through a virtual token type $K'$. 
We describe the simulation pattern below to simulate messages to \DS and \A.

On \inline{Z2A2P} input from \Z on channel \msf{z2a}, \Sim fowards the message to the internal \A with the same type but virtual tokens instead of real ones:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape, label={lst:sim}]
msg = $\nrecv$ $\$$z2a ;
$\nget$ $\$$z2a {z2an : K} ;
$\tm{withdrawTokens}$ f K K1 z2an ;
$\nsend$ $\$$a_z2a msg ;
$\npay$ {z2an : K1} $\$$a_z2a ; 
\end{lstlisting}

Similarly, on \inline{A2P(pid,msg)} output from \A to a protocol party on channel \msf{a2p}, \Sim sends the message to \DS as input from \Z (type: \inline{Z2A2P(pid, msg)}:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape]
pid = $\tb{recv}$ $\$$a_a2p ;
msg = $\tb{recv}$ $\$$a_a2p ;
$\tb{get}$ K1 $\$$aa2p {a2pn} ;
$\tb{send}$ $\$$sd_z2a A2P(pid, msg) ;
$\npay$ $\$$sd_z2a {z2an : K1} ;
\end{lstlisting}

$\Sim_\A$ accepts input from \Z and forwards it to the internal \A, which outputs to either the protocol parties or the ideal functionality. 
\Sim forwards this output to \DS acting as input from the environment  and forward any outputs \DS creates to the intended recipients.
Our main proof obligation here is to ensure that $\SIM{\A}$ in NomosUC is well-resource-typed for all well-resource-typed \A.
The $\Sim_\A$ performs constant overhead on the simulattion of \A and \DS. Therefore, a sufficient bounding polynomial on the runtime of $\Sim_\A$ can be given as:
\[
T(n) = T_{\A,\DS}(n) + T_{\A,\DS}(n) + O(n)
\]
where $T_{\A,\DS}(n)$ is the greater of the two bounding polynomials for \DS and \A evaluated at $n$, and $n$ is the import that \Z sends to \A and \Sim. 
We must also reason about the use of virtual tokens.
Given that \A and \DS are well-resource-typed we can conclude that the virtual import tokens generated for activating \A and \DS never exceeds a polynomial in the number of real import tokens received by \Sim. 
\end{proof}

\subsection{Single Composition}
In this section we present a simplified composition theorem and a second theorem we call the \textit{squash theorem}.
These two theorems combine later in the section to prove the full UC composition theorem as it appears in the UC framework~\cite{uc}.

Briefly the composition operator allows substitution of a functionality for a protocol that realized is. 
The theorem states that a protocol that uses some functionaliy \F can replace with a protocol $\pi$ that realizes it along with any hybrid functionality $\pi$ uses.
More specifically, in NomosUC, say a protocol $(\pi, \F_1)$ realizes some functionality $\F_2$.
A protocol $\rho$ that uses $\F_2$ can replace is with instances of $\pi$ directly connected to the corresponding instances of $\rho$ \emph{within} the protocol wrapper, and the ideal functionality $\F_2$ being replaced by $\F_1$ in the functionality wrapper.

We highlight first, that our protocol wrapper construction illustrated in \ref{fig:blankpartywrapper}, connects the internal process in that specific way to enable composition.
Recal that the Nomos language has the concept of clients and providers for a give linear channel. Given to processes, the type of the channel changes depending on which process \emph{offers} the channel, i.e. is the provider, and who is the client.
The arrows in Figure~\ref{fig:blankpartywrapper} illustrate the \emph{client} $\rightarrow$ \emph{provider} relationship.
We illustrate how protocol replacement works in NomosUC in Figure~\ref{fig:replacement}.

\begin{figure}
\centering
\includegraphics[scale=0.5]{figures/replacement2.pdf}
\caption{When we compose protocols we replace the \emph{p2f} process of $\rho$ with the corresponding instance of $\pi$ and its \emph{p2f} processes. By the emulation theorem, the channel offered by $\rho$ and accepted by $\pi$ have the same type.}
\label{fig:replacement}
\end{figure}

Given our code generation technique, the composition operator consists of the code in Figure~\ref{fig:compose} as well as the protocol specification of $\pi$ and $\rho$ that ensures the correct \inline{z2p} and \inline{f2p} are spawned for $\rho$ and $\pi$, respectively.
\begin{figure}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
$\tb{proc}$ compose[K][z][r][p]:
  (pid: Int), (rng: [Bit]), (sid: session[1]),
  (pid: Int), ($\$$z2p: z) |- ($\$$c: p) =
{
  $\$$ch <- PS.rho <- k rng sid pid $\$$z2p ;
  $\$$c <- Ps.pi <- k rng sid pid $\$$ch 
}
\end{lstlisting}
\caption{The composition operator accepts the same parameters as any other protocol party and offers the channel of type $p2f$ of the realizing protocol $\pi$. All protocols in NomosUC accept type parameters for the channel types, and here, we connect an instance of $\rho$ with an instance of $\pi$. In the same way that regular protocols require separate code for each ``role'' within a protocol (sender and receiver in the commitment example, for example), here we require the same be done for composing the protocol for each ``role'' of $\rho$.}
\label{lst:compose}
\end{figure}
%\begin{figure*}
%\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape]
%$\tb{proc}$ compose[K][z2r][r2z][f2r][r2f][p2f][f2p] : 
%    (pid: Int), ($\$$z_to_p: c[K][z2p]), ($\$$p_to_z: c[K][r2z]), 
%    ($\$$f_to_p: c[K][f2r]), ($\$$p_to_f: c[K][r2f])  |- ($\$$D : 1) =
%{
%	$\$$rho_to_pi <- $\tm{createchan}$[K][p2f];
%	$\$$pi_to_rho <- $\tm{createchan}$[K][f2p];
%
%	 <- pi  <-                 $\$$rho_to_pi $\$$pi_to_rho $\$$p_to_f $\$$f_to_p ;
%	 <- phi <- $\$$z_to_p $\$$p_to_z $\$$rho_to_pi $\$$pi_to_rho ; 
%}
%\end{lstlisting}
%\caption{Composition operator in Nomos that connects a protocol $\rho$ to a protocol $\pi$ that uses some functionality $\F$. The operators creates new channels to connect the realizing $\pi$ and it's hybrid \F. Output from $\rho$ intended for the replace functionality are actually send to parties of $\rho$, and channels outgoing from the parties to the functionality are given to $\pi$.}
%\label{lst:compose} 
%\end{figure*}

\begin{theorem}[Composition]\label{thm:singlecomp}
\begin{mathpar}
\inferrule*[right=single-compose]
{
	\F_1 \xrightarrow{\pi} \F_2 \semi \F_2 \xrightarrow{\rho} \F_3 \\
}
{
	\F_1 \xrightarrow{\rho \circ \pi} \F_3
}
\end{mathpar}

If \textit{well-typed} $(\pi, \F_1$) realizes $\F_2$ and ($\rho$, $\F_2$) realizes some $\F_3$, then $(\rho \circ \pi, \F_2)$ is \textit{well-typed} and realizes $\F_3$ when $\circ$ is defined as in Figure~\ref{lst:compose}.
\end{theorem}

\begin{proof}
The pre-condition ensures the existence of \textit{well-resource-typed} simulators $\Sim_\rho$ for $\F_2 \xrightarrow{\rho} \F_3$ and $\Sim_\pi$ for $\F_1 \xrightarrow{\pi} \F_2$, and, it is obvious that the composed protocol is also well-resource-typed.
We construct a simulator \Sim' for the dummy adversary to show
\[
	\msf{execUC}\ (\rho \circ \pi)\ \F_1\ \Z\ \A \approx \msf{execUC}\ \idealP\ \F_3\ \Z\ \Sim''
\]	

The simulator $\Sim'$ relies only simulating \SIM{\pi} and \SIM{\rho}.
Note that \SIM{\pi} can accept messages for $\pi$ or $\F_1$, simulate them, and generate input for $\F_2$. 
Similarly, \SIM{\rho} can take inputs for $\rho$ or $\F_2$, simulate them, and generate input for $\F_3$.
Therefore, we connect the two simulators in the natural way:
\begin{itemize}
\item Inputs from \Z of \inline{Z2A2P(msg)} are passed to \SIM{\rho}, and inputs of \inline{Z2A2F(msg)} are passed to \SIM{\pi}.  
\item \inline{P2A2Z(pid, msg)} outputs from \SIM{\rho} are forwarded to \Z unaltered.
\item \inline{A2F(msg)} and \inline{A2P(pid, msg)} messages from \SIM{\pi} for $\F_2$ are sent to \SIM{\rho} as \inline{Z2A2F(msg)} and \inline{Z2A2P(pid, msg)}, respectively. 
\item In the reverse direction, \inline{F2A2Z(msg)} messages from \SIM{\rho} are sent to \SIM{\pi} as \inline{F2A(msg)}, and, finally, \inline{F2A2Z(msg)} output generated by \SIM{\pi} is forwarded to \Z.
\item \inline{A2P(pid,msg)}, \inline{A2F(msg)} messages from \SIM{\rho}, and \inline{P2A(pid,msg)} and \inline{F2A(msg)} from $\F_3$, are forwarded unaltered. 
\end{itemize}
It is clear that \Sim' is able to emulate inputs from \Z to both parties of $\rho$ and the ideal functionalty $\F_1$.
\Sim' performs constant over head in simulating two \emph{well-resource-typed}, and therefore it is clear that \Sim' is \emph{well-resource-typed}.
When combined with the \emph{dummy lemma}, a well-resource-typed simulator exists for composition for any adverasry \A. 
The dummy lemma presented above ensures that a simulator for any \A can be constructed that is well-resource-typed for all wel-resource-typed \A.
\end{proof}

We give a simpler, high-level idea of the forst step of the proof proof here which can be understood visually:
\begin{align}
& \msf{execUC} \: \Z \, (\rho \circ \pi) \, \F_1 \, \DA \\
\equiv \; & \msf{execUC} \: (\Z \circ \rho) \, \pi \, \F_1 \, \DA \\
\approx \; & \msf{execUC} \: (\Z \circ \rho) \, \idealP \, \F_2 \, \SIM{\pi} \\
\equiv \; & \msf{execUC} \: \Z \, \rho \, \F_2 \, \SIM{\pi} 
%\approx \; & \msf{execUC} \: (\Z \circ \Sim{\pi}) \, \idealP \, \F_3 \, \Sim{\rho} \\
%\equiv \; & \msf{execUC} \: \Z \, \idealP \, \F_3 \, (\Sim{\pi} \circ \Sim{\rho}) 
\end{align}
The $\equiv$ operator is a result of moving around ITMs (some from within other ITMs into the main UC execution) and $\sim$ refers to indistinguishability.
In line (13) above, $\rho$ is moved into the execution environment with an unchanged simulator as no additional simulation is required: the simulator allows unfettered communication between parties of $\rho$ and \Z.

\subsection{Multisession}
The multi-session extension of a protocol or functionality, specified by the $!$ operator (such as $!\rho$ or $!\F$), allows multiple instances to be run within a sinlge ITM.
The ITM simulates multiple instances of the protocol/functionality intnerally and multiplexes input/output to/from them in same way as the party wrapper for protocol parties.
In keeping with our previous constructions, the multisession functionality runs a given protocol in the same was as the protocol wrapper, or a functionality as the functionality wrapper does, and spawns multiple instances of them on-demand.

In keeping with our previous constructions, the multisession also has a session type given by
\begin{mathpar}
\mi{stype} \; \m{{P2MS}[a][b]\{n,m\}} = \textcolor{red}{\getpot^n} \ichoice{\mb{Inp}: ssid \product a \arrow \m{MS2P[a][b]\{n,m\}}} \\
\mi{stype} \; \m{{MS2P}[a][b]\{n,m\}} = \echoice{\mb{Ok}: \textcolor{red}{\paypot^0} \; \m{P2MS[a][b]\{n,m\}}, \mb{Out}: ssid \product b \arrow \textcolor{red}{\paypot^m} \; \m{P2MS[a][b]\{n,m\}}}  
\end{mathpar}
and the functional types that are send to the wrapper surrounding it are given by
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, mathescape]
$\yo{type}$ p2ms[a] = P2MS of ssid ^ a ;
$\yo{type}$ ms2p[b] = MS2P of ssid ^ b ;
\end{lstlisting}
It is important to note that we require a session type here instead of allowing !\F act as the functionality wrapper because, when composed it must communicate directly communicate, over a session-typed channel, to another protocol.
Furthermore, the construction of !\F is the same as in the \Fro example: one session typed channel for all parties.
In Figure~\ref{fig:multisession} illustrated the functionality wrapper (right) and the multisession extension (left) for \Fcom. 
\begin{figure}
\centering
\includegraphics[scale=0.5]{figures/multisession.pdf}
\caption{The multisession extension of \Fcom (right) with only two instances, creates the same processes $S$ and $R$ (offering the session typed channel to \Fcom) for every created instance. A communicator per session buffers messages for the $S$ and $R$ processes to consume and forward along their session-typed channel to \Fcom.}
\label{fig:multisession}
\end{figure}

As a generic construction provided by NomosUC, the multisession operator requires some code generation but only to accept an arbitrary number of virtual token types if the underlying \F simulators other processes. 
Furthermore, similar to the functionality wrapper, the multisession operator constructs the processes around \F in the same way and spawns them on-demand.
The process definition for $!\F_\msf{com}$ is shown in Figure \ref{lst:bangf} accepting two token types: the real token type $K$ and the virtual token type $K_1$ for instances of $\F_\msf{com}$.

\begin{figure}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
$\tb{proc}$ bangF[K,K1][p2f,...] :
  (k: $\tgr{Int}$), (rng: [Bit]), (sid: session[a]), 
  ($\$$p: P2MS[p2f][f2p]) |- ($\$$ch: 1) =
\end{lstlisting}
\caption{The type definition for the multisession operator for functionalities and the correspond message type and import parameters. The operator for protocol parties is identical in code but differens in that the parameters to the \texttt{P2MS} type are for \texttt{Z2P} interaction.}
\label{lst:bangf}
\end{figure}

\begin{theorem}[PPT !]\label{thm:bangppt}
If a functionality $\F$ is well-resource-typed, then it's multisession extension $!\F$ is well-resource-typed.
\end{theorem}

\begin{proof}
A \textit{well-resource-typed} \F guarantees a polynomial $T_{\F}$ bounding its execution.
In the worse-case, the multisession operator must spawn a new instance of $\F$ an every activation. 
Let $N_{\F}$ denote the total number of instances (and, hence, number of activations) of $\F$ created by the operator.
Note that $N_{\F}$ is polynomial in the security parameter $k$ for all well-typed environments, protocols, and adversary.
Therefore, there always exists a bounding polynomial to bound a polynomial number of simulated instances of \F.
The polynomial can be given as:
$$ P_{!\F}(n) = N_{\F} P_{\F}(n) + \mathcal{O}(N_{\F}) $$
where the $\mathcal{O}(N_{\F})$ is due to the overhead of maintaining and accessing the set of all instances.

Similarly, \F being \textit{well-resource-typed} ensures a valid token context for all processes it may simulate. 
Therefore, it is clear that there exists a global connecting poltnomial $f$ that ensures a valid token context for $!\F$.
\end{proof}

\begin{theorem}[Squash Theorem]\label{thm:squash}
%If a functionality \F is well-resource-typed, then $!\F$ and $!!\F$ are well-resource-typed (by Theorem~\ref{thm:bangppt}) and $(\idealP, !!\F) \sim (\msf{squash}, !\F)$.
%\textit{Well-resource-typed} \F $\Rightarrow$ $!\F \xrightarrow{\msf{squash}} !!\F$%  $(\idealP, !!\F) \sim (\msf{squash}, !\F)$
\begin{mathpar}
\inferrule*[right=squash]
{
\textit{well-resource-typed} \; \F
}
{
!\F \xrightarrow{\msf{squash}} !!\F
}
\end{mathpar}
\end{theorem}

%\begin{figure}
%\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, mathescape, frame=single]
%$\yo{type}$ p2bFmsg[a] = P2bF of ssid ^ a ;
%$\yo{type}$ p2bbFmsg[a] = P2bbF of ssid ^ ssid ^ a ;
%$\tg{(* z2p : comm[z2pmsg[p2bbf[a]]] *)}$
%$\tg{(* p2f : comm[p2fmsg[P2bf[a]]] *)}$
%pid = recv $\$$z2p ;
%m = recv $\$$z2p ;
%case m (
%  P2bbF(ssid1, ssid2, m) =>
%    send $\$$p2f P2bF(ssid1 + ssid2, m) ;
%)
%\end{lstlisting}
%\caption{The \textit{squash protocol} accepts a message intended intended for $!!\F$ of type \inline{P2MS[p2ms[a]][ms2p[b]]}, i.e. of the form $(\msf{ssid}_1, (\msf{ssid}_1, msg))$.
%It ``flattens'' it into a single $\msf{ssid}_3 = \msf{ssid}_1 + \msf{ssid}_2$ that can be passed to $!\F$. The result is the same number of instances of \F but behind only a single $!$ operator.}
%\label{fig:squash}
%\end{figure}

\begin{proof}
First we describe the \msf{squash} protocol where $!!\F$ are nested $!$ operators.
The protocol accepts messages intended for $!!\F$ of type \inline{P2MS[p2ms[a]][ms2p[b]]}, i.e. of the form $(\msf{ssid}_1, (\msf{ssid}_2, msg))$, and ``flattens'' them into a single message of type $\inline{P2MS[a][b]}$, i.e. of the form $(\msf{ssid}_3, msg)$.

In $(\idealP, !!\F)$, \idealP~expects to receive messages of the form $(\msf{ssid}_1, (\msf{ssid}_2, m))$ where $\msf{ssid_2}$ is a sub-session of $\F$ (i.e. instance) inside some $!\F$ with sub-session id $\msf{ssid}_1$ inside of $!!\F$ (the message accesses functionality $\F[\msf{ssid}_1][\msf{ssid}_2]$).
The \msf{squash} protocol flattens the indexing of instances of \F and combines session ids $\msf{ssid}_1$ and $\msf{ssid}_2$ into a single \msf{ssid}: $\msf{ssid}_3 := \msf{ssid}_1 \cdot \msf{ssid}_2$.
If follows intuitively that the view for the environment remains the same. 

We construct a simulator such that:
\[
\msf{execUC} \, \Z \, \idealP \, !!\F \, \SIM{\msf{squash}} \approx \msf{execUC} \, \Z \, \msf{squash} \, !\F \DA 
\]
The simulator is very simple. 
Inputs to/from parties/\Z for a corrupt party is forwarded unmodified.
Input intended for $!\F$ of the form $(\msf{ssid}_1 \cdot \msf{ssid}_2, msg)$ is sent as $(\msf{ssid}_1, (\msf{ssid}_2, msg))$ to $!!\F$. 
Output from $!!\F$ is modified inversely and sent to \Z.

The proposed simulator is trivially analyzed to be \textit{well-resource-typed}.
It performs constant work per activation and does ``real'' simulation other than message modification to/from $!!\F$.
\end{proof}

\subsection{UC Composition}
Composition in the UC setting is not limited to replacement of a single instance of a protocol.
Instead, it permits replacement of any number of instances of a protocol $\phi$, each with their own session id, with instances of a realizing protocol $\pi$.
This generalized form of composition follows directly from Theorems \ref{thm:singlecomp} and \ref{thm:squash}.

\begin{theorem}[Composition]\label{thm:composition}
\begin{mathpar}
\inferrule*[right=compose]
{
	%(\pi, !\F_1) \sim (\idealP, F_2) \semi (\rho, !\F_2) \sim (\idealP, \F_3) \\ 
	!\F_1 \xrightarrow{\pi} \F_2 \semi !\F_2 \xrightarrow{\rho} \F_3 \\
	%\Rightarrow \exists \Sim(\A) \vdash (\rho^{!\F_2 \rightarrow (!\pi \, \circ \, \msf{squash})}, !\F_1) \sim (\idealP, \F_3)
}
{
	!\F_1 \xrightarrow{\rho \, \circ !\pi \circ \, \msf{squash}} \F_3
	%(\rho \, \circ \, !\pi \circ \msf{squash}, !\F_1) \sim (\idealP, \F_3)
}
\end{mathpar}
\end{theorem}

\begin{proof}
The proof of full composition follows directly from the single composition Theorem~\ref{thm:singlecomp} and the Squash Theorem~\ref{thm:squash}.
By Theorem~\ref{thm:singlecomp} we can construct a simulator \SIM{1} for $!!\F_1 \xrightarrow{\rho \, \circ \, !\pi} \F_3$.
Theorem~\ref{thm:squash} then allows us to ``squash'' $!!\F_1$ and construct a simulator using \SIM{1} for $!\F_1 \xrightarrow{\rho \, \circ \, !\pi \, \circ \, \msf{squash}} \F_3$
\end{proof}
