In this section we introduce the UC experiment in Nomos and the resulting emulation definition.
We continue on to state the dummy lemma theorem as well as a composition theorem for Nomos UC.
An important part of our definition is using code-generation techniques~\cite{somecodegeneration} to constructs some processes in the UC experiment as well ass useful operators to achieve full composition in the sense of Canetti et al.~\cite{uc}.


We first introduce some convenient notation.
For the remainder of this section, when we refer to a protocol, we actually refer to a pair of ITMs as in Definition~\ref{def:protocol}.
\begin{definition}\label{def:protocol}
A \textit{protocol} is a pair of terms ($\pi$, $\mathcal{F}$) where $\pi$ is the protocol run by honest parties and \F is an ideal functionality that parties an access.
\end{definition}
In the ideal world, $\pi$ is replaced by an an ideal protocol, \idealP, which is a dummy protocol: it frorwards message between \Environment to \F for honest parties  and between \Adversary and \F for corrupt parties.
In the real world, \F is called the \textit{hybrid functionality} and stands in for a real protocol that emulates it.
For protocols that don't make calls to any hybrid functionality, \F is just the dummy protocol which does nothing on activation by any other ITM.

\subsection{The UC Experiment}
The UC experiment is an execution of a main protocol, called the \textit{challenge protocol}, consisting of protocol parties and an ideal functionality, reacting to input by an adversary \Adversary or the \Environment.
The experiment is created by an \msf{execUC} function which spawns the environment, a special construction called the \textit{protocol wrapper}, the adversary, and any functionalities (wrapped by the \textit{functionality wrapper}: a simplified version of the \textit{protocolwrapper}).

The design of \msf{execUC} is constrained by our use of virtual tokens.
In our definition all token types must be statically initialized in order to be used.
Therefore, \msf{execUC} and, in fact, the protocol wrapper rely on code generation to create unique process definitions for a specific protocol we wish to express.
For example a protocl that simulates another protocol, which in turn might simulate other protocols, needs more virtual token types than a simple functionality like \Fcom.
In Figure~\ref{fig:execuc}, we illustrate what \msf{execUC} looks like for the commitment protocol example we've used throughout the paper.

%% EXEC UC FIGURE 
\begin{figure*}
\input{listings/execuc}
\caption{The \msf{execUC} function used for the two-party commitment example used througout this paper. Recall, the \msf{execUC} is customized insofar as it takes in some number of virtual token types (here, $K_1$) to enable machines that simulate other machines. In the commitment example, there is no such simulation happening at the protocol or functionality level, therefore only the real token type $K_1$ is used here. The funtion spawns all the necessary ITMs in the UC execution: the environment, the protocol wrapper, the functionalty (wrapped), and the adversary. Each is parameterized with the security parameter $k$ and a random bit sequence $\msf{rng} \in \{0,1\}^{poly(k)}$.
At the end, the environment is started and it returns a bit $b$ which is its guess for which world it is in. The full code can be found in the Appendix.}
\label{lst:execuc}
\end{figure*}

An obvious omission from the \msf{execUC} process definition is the protocol, functionality, adversary, and environments as function parameters.
The reason for the omission is that passing process definitions as parameter is not supported yet in the Nomos impementation.
Therefore, we rely on importing modules which define the relevant processes and define them in scope for \msf{execUC}.

A module representing the protocol, for example,  must define a process called \msf{PS.prot} and \msf{PS.func} for the protocol and the functionality, respectively.
The protocol wrapper and functionality wrapper manage spawning the instance(s) of the functionality and protocol parties.
Similarly, an environment \msf{PS.env} and adversary \msf{PS.adv} must be defined as well.
The message types exchanged between the processes are provided directly to \msf{execUC} as type parameters of the form \msf{p2f}, \msf{f2p}, and so on. 

The environment is spawned first and selects the session id, or \msf{sid}, for the execution and determines the corrupted parties, \msf{clist}.
The rest of the ITMs are then spawned with this \msf{sid} and are given the list of corrupt parties.
Recall that in the UC framework, corrupt parties accept input and give output to the adversary instead of the environment, and the protocol wrapper runs dummy parties in their place that forward messages between \Adversary and \F.

Finally, the environment executes its own code when activated by \msf{\$z.start} and returns a bit that indicates its guess as to which world it is operatin in: real or ideal.
Over all possible environments, security parameters $k$, and random bit sequences $r$, the output of \msf{execUC} represents an ensemble of distributions for the output bit. 

\subsection{The Protocol Wrapper}
The \msf{execUC} definition introduces a new construct called the \textit{protocol wrapper}. 
In the UC experiment, the environment can create protocol parties on the fly and none exist until the first message is written to them.
Thefeore the wrapper is intended to create new parties on demand.

The necessity of a protocol wrapper leads to an interesting problem in how channels and session typed can be used.
All communciation between protocol parties and \Environment, \F, and \Adversary is managed by the protocol wrapper, and the need to multiplex and de-multiplex communication between parties and other machines makes session types between them impossible.
It isn't possible to use multiple session-typed channels through a single communicator either, because parties can have different roles within a protocol so not even the same code is being executed (hence different session types governing the protocol) for each party.
Therefore, we define a new approach to creating protocol-specific party wrappers, but with a generic construction that can be used for any protocol.
We use the two-party commitment protocol as an example to demonstrate how the construction works and show that it is generic enough to allow code generation of a wrapper for any protocol.

Recall the session type governing the committer and receiver in the commitment protocol:
\begin{gather}
	\mi{stype} \; \m{sender} = \ichoice{\mb{commit} : \m{bit} \product \m{scommitted}} \\
	\mi{stype} \; \m{scommitted} = \ichoice{\mb{open} : 1} \\
	\mi{stype} \; \m{receiver} = \echoice{\mb{commit} : \m{rcommitted}} \\
	\mi{stype} \; \m{rcommitted} = \echoice{\mb{open} : \m{bit} \arrow \one}
\end{gather}

The commitment protocol has multiple roles, the committer and receiver, with different session types. 
The wrapper instantiates its internal channels to the parties with the appropriate session types and maintains lists that hold the channels for each possible session types.
For commitment the lists for the \msf{z2p} channels are the following:
\begin{gather}
	\m{R1L1}[\m{sender}] \\
	\m{R1L2}[\m{scommitted}] \\
	\m{R2L1}[\m{receiver}] \\
	\m{R2L2}[\m{rcommitted}] 
\end{gather}
At the start of the commitment UC execution, the \msf{z2p} channels for the committer and receiver will be in $\msf{R1L1}$ and $\msf{R2L1}$, respectively.
Recall this is an auto-generated wrapper, hence the lists are named generically: $\msf{R1L1}$ stands for list 1 or role 1 (role 1: committer. role 2: receiver). 

The channels between the protocol wrapper and the rest of the machines are still limited to functional types through a communicator. 
For example, as shown in the \msf{execUC} definition, the protocol wrapper's channel from \Environment is typed as \inline{comm[K1][Z2Pmsg[z2p]]} where \inline{z2p} is a type parameter to \msf{execUC} which is
\begin{gather}
\mi{type} \; \m{comz2p} = \m{Commit} \; \mi{of} \; \m{bit} \; | \; \m{Open}
\end{gather}
for commitment.

When the protocol wrapper receives a message for some \msf{pid}, if the party doesn't exist the protocol wrapper creates all the party's channel parameterized by the correct session types (the party's role and session types are determined by functional type of the incoming message).
The channels are stored in the appropriate lists corresponding to their type.
The session type of the message is determined by the functional type, and the session-typed message is sent along that channel.
This we can still make use of session types and environments, adversaries, or protocols that send messages out of order (i.e. are incorrect) will still \textit{fail to type check}.
After delivering the message, the channel is moved to the next list corresponding to its new type.

For outgoing messages, the party wrapper does a similar conversion where it reads the sesion typed message output by the party and converts it to the appropriate functional message type.
For the commitment example, at the beginning the type of the \inline{p2f} channel the committer has is typed as (1). 
When the party \inline{PID} sends a bit with
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
$\$$f2p.commit 
$\tb{send}$ $\$$f2p b
$\tb{pay}$ {p2fn} $\$$f2p 
\end{lstlisting}
the party wrapper does
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
$\$$z2p.SEND 
$\tb{send}$ $\$$z2p pid 
$\tb{send}$ $\$$z2p Commit(b)
$\tb{pay}$ {p2fn} $\$$f2p
\end{lstlisting}
sending a functional message type to the functionality.
For outgoing messages, a new process per party channel waits to read and does the inverse conversion: from session type to funtional type and attaches the party's \msf{pid} to it.

\paragraph{Functionality Wrapper}
Similar to protocol parties, we want to write functionalities using session types.
However, as described for the protocol wrapper, a static definition does not suffice to capture the UC features: dynamic number of parties and different roles (hence, different session types) per party.
For the same reasons, we also create a functionality wrapper around the ideal functionaltiy (in both the real and ideal worlds).
The key difference between the functionality wrapper and the protocol wrapper is that there is only one instance of the functionality running.
We also want to retain the the design of \Fcom presented earlier, where a functionality can be written to interact specifically with each party on separate channels. 
Therefore, the functionality wrapper also generates lists for each session type for each party role (the roles are committer and receiver in \Fcom), and de-multiplexes incoming messages.
Like the protocol wrapper code, the functionality wrapper searches for the channel of the sending \inline{PID} and attempts to send the session typed messages accross it.
The full code of the functionality wrapper for the commitment ideal world is given, in full, in the appendix. 

\subsection{Polynomial Bound}
The UC import mechanism provides a way to define polynomial time computation and resource-bounds by ensuring that a single ITM's execution is upper-bounded by some value $T(n)$ where $T$ is a polynomial and $n$ the total units of import the ITM ever receives.
In UC, it is important to reason about polynomial bounds in the security parameters $k$. Hence, the UC execution relies on an initial amount of import that is give as a polynonial in $k$. 
In NomosUC, we take advantage of the import built into the type system to ensure ITMs are PPT in the security parameter. 

\begin{definition}[PPT Term]\label{def:pptterm}
A \textit{PPT term} is a \textit{well-typed} term $e(k, r)$ that is \textit{closed} except for security parameter $k$, random bit sequence $r$.
\end{definition}

We first-define terms that are well-typed in the traditional session-types-sense in Definition~\ref{def:pptterm}, i.e. without any resource constraints~\cite{sessiontypes}.
Such terms are closed except for the security parameter $k$ and some uniformly random bit sequence $r$.

However, we also want to reason about terms that are well-typed when connected to another Nomos terms.
We introduce the term \textit{well-matched} to mean a PPT term $e$ is well-typed when connected to another term $e'$.
Simply put, the channels that $e$ and $e'$ share channels of the same type. 
Specifically, we want to exclude processes that logically share a channel, say the channel from \inline{p} to \inline{f}, but belong to different protocols (their types message types don't match).
This new definition becomes important when we discuss UC emulation below as we want to reason about environments that are \textit{well-matched} for a protocol $\pi$ or a specific adversary \Adversary.

\begin{definition}[Well-Matched]\label{def:wellmatched}
\begin{mathpar}
\footnotesize
\inferrule*[right=Well-matched]
{\Tokens_1, K \semi \Delta_1 \vdash C_1 :: \Delta_1' \semi 
\Tokens_2, K' \semi \Delta_2 \vdash C_2 :: \Delta_2' \\ \\
 S \equiv \Delta_1 \bigcap \Delta_2 \neq \emptyset}
{\Delta_1 \equiv_{S} \Delta_2 \semi K \equiv K'} 
\end{mathpar}
\end{definition}

Notice that in Definition~\ref{def:wellmatched} we are concerned with two terms that are \textit{open} even when connected. 
We only care about being well-matched, when connected to another term, on the channels over which they are connected.

Next we introduce our definition of a polynomial-bound in the security parameter $k$.
Terms that are PPT in $k$ are dubbed \textit{well-resource-typed}.
\begin{theorem}[PPT in $k$]\label{thm:ppt}
A \textit{PPT Term} $e(k, r)$ is well-resource-typed if, given initial import $n(k) \in poly(k)$, there exists a polynomial $T$ s.t. $\forall k, r, e(k, r) \{n(k)\}$ terminates in at most $T(n)$ steps. 
\end{theorem}

\begin{proof}
The Nomos type system only type checks programs for which a satisfying assignment of polynomial $T$ is possible.
Given an $n \in poly(k)$, all programs that type check must be \textit{well-resource-typed.}
%The Nomos type system guarantees that a satisfying assignment of $n$ and $T$ will correctly type-check.
%Therefore, given an initial amount of import $n(k) \in poly(k)$, the existence of some $T$ ensures that any process, regardless of its randomized execution according to the bit sequence $r$, $e$ is guarantees to be upper-bounded by $poly(k)$ satisfying the definition of probabilistic polynomial time in $k$.
\end{proof}

\subsection{Emulation}
A proof of security in the UC framework relies upon emulation of different executions.

In general, we say that a protocol $\pi$ posesses the same security properties as another protocol $\phi$ if no environment given them inputs can distinguish between them for any adversary.
In most cases we compare a real protocol $\pi$ with an idealized protocol $(\idealP, \F)$ which is actually just an ideal functionality with dummy parties.
The ideal functionality is known to achieve the desired security processes because it acts like a simple, trusted third party.
They are much simpler than protocols because they don't require any special code to handle mutually distrustful other processes, and they perform the given computation on behald of the ideal world parties.

Given the random choices ITMs in UC can make, it is clear that the outputs of \inline{execUC} in Figure~\ref{lst:execuc} produces and ensemble of distributions over all possible random bitstrings and security parameters.
Emulation, then, is about the ensembles created by two UC environments being computationally indistinguishable from each other.
We define indistinguishabiliy between ensembles in a standard way using \textit{statistical distance} in Definition~\ref{def:distance}.

\begin{definition}[Indisinguishability]\label{def:distance}
Two ensembles $\mathcal{D}_{1,k}, \mathcal{D}_{2,k}$ are indistinguishable, $\mathcal{D}_{1,k} \sim \mathcal{D}_{2,k}$, if their statistical distance is at most $negl(k), \forall k$.
\end{definition}

Before we introduce the emulation definition, we first define valid protocols, valid functionalities, and what it means for protocols, functionalities, adversaries, and environments to be well-matched with each other.
We shorten the communicator type \msf{comm} to \msf{c} in the following definitions.

\todo{Ankush: The context of a valid functionality must contain channels typed with the type parameters given by \msf{execUC}. An the machine, parameterized with security parameter $k$ and random bit sequence $r$ are bounded by some polynomial $T_\F$. $\leftarrow$ the last part is meant to capture the well-resource-typed (from the well-matched definition), but maybe we can just say $\F$ is well-resource-typed given $k$,$r$}
\begin{definition}[Valid Functionality]\label{def:validfunc}
\begin{mathpar}to one of footnotesize
\inferrule*[right=valid-F]
{\exists c_1:c[\msf{p2f}], c_2:c[\msf{f2p}], c_3: c[\msf{f2a}], c_4:c[\msf{a2f}] \in \Delta_1 \\
\Delta_1 \models (\F(k, r) : T_\F) :: \Delta_1'}
{\msf{validF}\ \F \rightarrow \Delta_1'}
\end{mathpar}
\end{definition}

\todo{The intent is the same as above here execpt for protocol having channels with the right types. Again here I could just say $\pi$ is well-resource-typed instead of the $\pi(k,r)$ that is there now.}
\begin{definition}[Valid Protocol]\label{def:validprot}
\begin{mathpar}
\footnotesize
\inferrule*[right=valid-P]
{\exists c_1: \msf{p2f}, c_2: \msf{f2p}, c_3: \msf{p2a}, c_4: \msf{a2p}, c_5: \msf{z2p}, c_6: \msf{p2z} \in \Delta_1 \\
\Delta_1 \models (\pi(k, r) : T_\pi) :: \Delta_1' }
{\msf{validP}\ \pi \rightarrow \Delta_1'}
\end{mathpar}
\end{definition}

\todo{Ankush: this defines what it means for a protocol and functionality to be well-matched. Namely, they shared channels typed according to parameters given by execUc (p2f, f2p, ...) and have the same type and import parameters on their communicators}
\begin{definition}[Well-Matched]
\begin{mathpar}
\footnotesize
\inferrule*[right=p2f match] 
{\msf{validP}\ \pi \rightarrow \D_1 \semi \msf{validF}\ \F \rightarrow \Delta_2 \\
\Delta_1:, (\msf{c}[K][\msf{f2p}]), (\msf{c}[K][\msf{p2f}]) \equiv \\
\Delta_2, (\msf{c}[K][\msf{pid \textasciicircum f2p}]), (\msf{c}[K][\msf{pid \textasciicircum p2f}])}
{\langle \pi \leftrightarrow \F \rangle}
\end{mathpar}
\end{definition}

\todo{Ankush: same for this one and the rest, as above}
\begin{definition}
\begin{mathpar}
\footnotesize
\inferrule*[right=p2a match] 
{\msf{validP}\ \pi \rightarrow \Delta_1 \semi \Adversary \rightarrow \Delta_2 \\
\Delta_1:, (\msf{c}[K][\msf{a2p}]), (\msf{c}[K][\msf{p2a}]) \equiv \\ 
\Delta_2, (\msf{c}[K][\msf{pid \textasciicircum a2p}]), (\msf{c}[K][\msf{pid \textasciicircum p2a}])}
{\langle \pi \leftrightarrow \Adversary \rangle}
\end{mathpar}
\end{definition}

\begin{definition}
\begin{mathpar}
\footnotesize
\inferrule*[right=f2a match] 
{\msf{validF}\ \F \rightarrow \Delta_1 \semi \Adversary \rightarrow \Delta_2 \\
\Delta_1:, (\msf{c}[K][\msf{a2f}]\{a2fn\}), ( \msf{c}[[K]\msf{f2a}]\{0\}) \equiv \\
 \Delta_2, (\msf{c}[K][\msf{a2f}]\{a2fn\}), ( \msf{c}[K][\msf{f2a}]\{0\})}
{\langle \F \leftrightarrow \Adversary \rangle}
\end{mathpar}
\end{definition}

\begin{definition}
\begin{mathpar}
\footnotesize
\inferrule*[right=p2z match] 
{\msf{validP}\ \pi \rightarrow \Delta_1 \semi \Environment \rightarrow \Delta_2}
{\Delta_1:, (\msf{c}[K][\msf{z2p}]), (\msf{c}[K][\msf{p2z}]) \equiv \\
 \Delta_2, (\msf{c}[K][\msf{pid \textasciicircum z2p]}), (\msf{c}[K][\msf{pid \textasciicircum p2z}])}
\end{mathpar}
\end{definition}

Indisintiguishability between two protocols is defined as follows (we shorten the communicator type \msf{comm} to \msf{c}):

\begin{definition}[Emulation]\label{def:emulation}
Given two protocols $(\pi, \F_1), (\phi, \F_2)$ that are well-resource-typed then if $\forall \Adversary$ well-matched with $(\pi, \F_1)$, $\exists \Simulator$ s.t. $\forall \Environment$ well-matched with \Adversary and $(\pi, \F_1)$: \Simulator is well-matched with $(\phi, \F_2)$, \Environment is well-matched with $(\phi, \Simulator)$, and $\msf{execUC}(\pi, \F_1, \Environment, \Adversary) \approx \msf{execUC}(\phi, \F_2, \Environment, \Simulator)$:

\begin{mathpar}
\footnotesize
	\inferrule*[right=emulate]
	{
		. \models \msf{execUC}[\Tokentypes][\alpha] :: \Delta[\Tokentypes][\alpha] \\ \\
		% Protocols that are well-matched with their functionalities
		\msf{validP}\ \pi \rightarrow \Delta_1' \semi
		\msf{validP} \phi \rightarrow \Delta_2' \semi
		\langle \pi \leftrightarrow \F_2 \rangle, \langle \phi \leftrightarrow \F_1 \rangle \\
		% Type of execUC[DELTA_pi] and execUC[DELTA_phi]
		\Delta_1'[\Tokentypes][\mathrm{T}_{\pi}] \equiv_{\Environment} \Delta_1\ 
		\semi \Delta_2'[\Tokentypes][\mathrm{T}_{\phi}] \equiv_\Environment \Delta_2 \\
		% For all A if exists well-typed A that is well-matched with real world
		\forall \Adversary, (\exists (\Delta_4, \Delta_4') | \Delta_4 \vdash \Adversary :: \Delta_4',\ \langle \Adversary \leftrightarrow \pi \rangle, \langle \Adversary \leftrightarrow \F_1 \rangle \\
		% implies simulator that is well-matched for ideal world
		\Rightarrow \exists (\Delta_3,\Delta_3') | \Delta_3 \vdash \Simulator_\Adversary :: \Delta_3', \langle \Simulator_\Adversary \leftrightarrow \phi \rangle, \langle \Simulator_\Adversary \leftrightarrow \F_2 \rangle \\
		% for all Z they that's well-matched for the real world => Z is well-matched with S and ideal world
		\forall \Environment (\langle \Environment \leftrightarrow \Adversary \rangle, \langle \Environment \leftrightarrow \pi \rangle \Rightarrow \langle \Environment \leftrightarrow \Simulator_\Adversary \rangle, \langle \Environment \leftrightarrow \phi \rangle \\
		% and emulation has to hold
		\msf{execUC} \ \pi\ \Environment\ \F_1\ \Adversary \approx\ \msf{execUC} \ \phi\ \Environment\ \F_2\ \Simulator_\Adversary))
	}
	{
		% EMULATION DEFINITION
		\lambda \Adversary . \Simulator_\Adversary \vdash (\pi, \F_1) \sim (\phi, \F_2)
	}
\end{mathpar}
\end{definition}
The definition ensures that for emulation to hold, the constructed simulator must be well-matched everywhere \Adversary is well-matched: for all environments \Adversary is well-matched with the \Simulator must also be well-matched with.

\paragraph{UC Realize}
When we talk about emulation, we particularly care about emulation with respect to an ideal protocol $\phi$ which is really just $(\idealP, \F)$ where \idealP is the protocol which forwards all messages to/from \Environment and \F.
We say the protocol $\pi$ (potentially with a hybrid functionality $\F_1$) UC-realizes an ideal functionality $\F_2$ if Definition~\ref{def:emulation} holds for $(\pi, \F_1)$ and  $\phi = (\idealP, \F_2)$

\begin{definition}[UC-Realize]
A protocol $\pi$ UC-realized an ideal functionality $\F_1$ if $(\pi, \F_2) \sim (\idealP, \F_1)$ for some $\F_2$.
\end{definition}

\subsection{Dummy Lemma}
The Dummy Lemma is an important lemma in the UC framework that requires only one simulator to work with a dummy adversary in order to prove emulation with respect to any adversary.
The proof of the lemma makes use of the \msf{withdrawTokens} program definition from Section~\ref{sec:nomosuc}.
The instruction allows for re-use of existing machines and make simulator construction to use the real-world adversary, or other sub-simulators, in a black-box manner.

The Lemma states that if dummy simulator satisfies emulation with respect to the dummy adversary, then for any \Adversary a simulator can be constructed with the dummy simulator. 
The constructed simulator simply runs \Adversary and \Dummysim internally, and it sends messages from \Environment to \Adversary and outputs of \Adversary to \Dummysim.
At a high leve, the proof relies on the emulation definition where dummy emulation covers environments that run \Adversary internally. Here, we are only moving \Adversary into the execution

\begin{theorem}[Dummy Lemma]\label{thm:dummy}
If $\exists \Dummysim$ s.t. $ \DummyAdv, \Dummysim \vdash (\pi, \F_2) \sim (\phi, \F_1)$ then $\forall \Adversary \ \exists \Simulator_\Adversary$ s.t. $\Simulator_{\Adversary} \vdash  (\pi, \F_2) \sim (\phi, \F_1)$ 
\end{theorem}

\begin{proof}
The constructed simulator $\Simulator_\Adversary$ internally simulates \Dummysim and \Adversary through a virtual token type $K'$. 
We describe the simulation pattern below to simulate messages to \Dummysim and \Adversary.
Recall that the virtual tokens consturction is a tool to make witing complex protocols easier, and has no impact on the import token requirements of the simulating machine.
Simply put, simulating as a block-box should be equivalent, with respect to import, as \Simulator running the code natively. 
The only different in running a simulation internally is additional potential usage in using \inline{$\tm{withdrawToken}$} and routing messages.

On input from \Environment on channel \msf{z2p}, \Simulator:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape, label={lst:sim}]
msg = $\nrecv$ $\$$z2a ;
$\nget$ $\$$z2a {z2an : K} ;
$\tm{withdrawTokens}$ f K K1 z2an ;
$\nsend$ $\$$a_z2a msg ;
$\npay$ {z2an : K1} $\$$a_z2a ; 
\end{lstlisting}

Similarly, on output from \Adversary to a protocol party on channel \msf{a2p}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape]
pid = $\tb{recv}$ $\$$a_a2p ;
msg = $\tb{recv}$ $\$$a_a2p ;
$\tb{get}$ K1 $\$$aa2p {a2pn} ;
$\tb{send}$ $\$$sd_z2a A2P(pid, msg) ;
$\npay$ $\$$sd_z2a {z2an : K1} ;
\end{lstlisting}

$\Simulator_\Adversary$ forwards input from \Environment and forwards it to the internal \Adversary. 
\Adversary output to either the protocol parties or the ideal functionality. 
\Simulator forwards this output to \Dummysim acting as input from the environment (here we fallback to the notion that \Adversary can be run internally by \Environment) and forward any outputs it creates to the intended machines.
The proof oblication here is to ensure that the constructed simulator $\Simulator_\Adversary$ is well-resource-typed for all well-resource-typed and well-matched, with \Environment, \Adversary.
The $\Simulator_\Adversary$ performs constant overhead on the simulattion of \Adversary and \Dummysim. Therefore, a sufficient bounding polynomial on the runtime of $\Simulator_\Adversary$ can be given as:
\[
T(n) = T_{\Adversary,\Dummysim}(n) + T_{\Adversary,\Dummysim}(n) + O(n)
\]
where $T_{\Adversary,\Dummysim}(n)$ is the greater of the two bounding polynomials for \Dummysim and \Adversary evaluated at $n$, and $n$ is the import that \Environment sends to \Adversary. 
The same \textit{well-resource typed} reasoning extends to the token context where amount of virtual tokens created are polyomial in number and generate potential that is bounded by the above bounding polynomial for $\Simulator_\Adversary$.
\end{proof}

\subsection{Single Composition}
In this section we present a simplified composition theorem and another theorem, which we call the \textit{squash theorem}.
These two theorems combine to prove the full generalized composition theorem as it appears in the UC framework~\cite{uc}.

The composition operator defines a way for some protocol $\rho$ that uses a functionality $\F$ to swap $\F$ for a procol $(\pi, \F')$, which realizes $\F$, such that $(\rho, \F) \sim (\phi, \F'') \Rightarrow (\rho \circ \pi, \F') \sim (\phi, \F'')$.
The $\circ$ composition operator is defined in Nomos in Figure~\ref{lst:compose}.

Recall that the Nomos language currently does not support passing processes as arguments to other processes even though the theory allows it. 
In the $\circ$ code the protocols $\pi$ and $\phi$ exist globally.

\begin{figure*}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape]
$\tb{proc}$ compose[K][z2r][r2z][f2r][r2f][p2f][f2p] : 
    (pid: Int), ($\$$z_to_p: c[K][z2p]), ($\$$p_to_z: c[K][r2z]), 
    ($\$$f_to_p: c[K][f2r]), ($\$$p_to_f: c[K][r2f])  |- ($\$$D : 1) =
{
	$\$$rho_to_pi <- $\tm{createchan}$[K][p2f];
	$\$$pi_to_rho <- $\tm{createchan}$[K][f2p];

	 <- pi  <-                 $\$$rho_to_pi $\$$pi_to_rho $\$$p_to_f $\$$f_to_p ;
	 <- phi <- $\$$z_to_p $\$$p_to_z $\$$rho_to_pi $\$$pi_to_rho ; 
}
\end{lstlisting}
\caption{Composition operator in Nomos that connects a protocol $\rho$ to a protocol $\pi$ that uses some functionality $\F$. The operators creates new channels to connect the realizing $\pi$ and it's hybrid \F. Output from $\rho$ intended for the replace functionality are actually send to parties of $\rho$, and channels outgoing from the parties to the functionality are given to $\pi$.}
\label{lst:compose} 
\end{figure*}

\todo{Include a graphical illustration of wtf is going on, and going on inside the party wrapper as}

\begin{theorem}[Composition]\label{thm:singlecomp}
\begin{mathpar}
\inferrule*[right=single-compose]
{
	\F_1 \xrightarrow{\pi} \F_2 \semi \F_2 \xrightarrow{\rho} \F_3 \\
}
{
	\F_1 \xrightarrow{\rho \circ \pi} \F_3
}
\end{mathpar}

If \textit{well-typed} $(\pi, \F_1$) realizes $\F_2$ and ($\rho$, $\F_2$) realizes some $\F_3$, then $(\rho \circ \pi, \F_2)$ is \textit{well-typed} and realizes $\F_3$ when $\circ$ is defined as in Figure~\ref{lst:compose}.
\end{theorem}

\begin{proof}
The pre-condition ensures the existence of a \textit{well-resource-typed} simulator $\Simulator_\pi$ for $(\pi, \F_1) \sim (\idealP, \F_2)$. 
We construct a simulator $S$ which relies only on $\Simulator_\pi$ for:
\[
	\msf{execUC}\ (\rho \circ \pi)\ \F_1\ \Environment\ \Adversary \approx \msf{execUC}\ \idealP\ \F_3\ \Environment\ \Simulator
\]	
We don't need to perform simulation on any inputs by \Environment to the main parties of $\rho$ (it's the same protocol in both worlds).
The constructed simulator \Simulator simulates \Sim{\pi} internally and passes messages intended for the parties of $\pi$, or for $\F_2$, to \Sim{\pi} and simulates its computation.
Similariy, \Simulator sends any message from $\F_3$ to \Sim{\pi} for simulation.  
Input to any party of the main protocol $\rho$ from \Environment, or outout from them to \Simulator, are forwarded without any modification or simulation.
The constructed simulator performs constant overhead in routing messages to the simulated \Sim{\pi} and forwrading messages to/from parties of $\rho$/\Environment. 
Given that \Sim{\pi} is \textit{well-resource-typed}, with bounding polynomial $T_{\Sim{\pi}}$, it suffices to show that an additional linear term is sufficient to create a bounding polynomial for \Simulator.

\end{proof}

We give a simpler, high-level idea of the proof here which can be understood visually:
\begin{align}
& \msf{execUC} \: \Environment \, (\rho \circ \pi) \, \F_1 \, \DummyAdv \\
\equiv \; & \msf{execUC} \: (\Environment \circ \rho) \, \pi \, \F_1 \, \DummyAdv \\
\approx \; & \msf{execUC} \: (\Environment \circ \rho) \, \idealP \, \F_2 \, \Sim{\pi} \\
\equiv \; & \msf{execUC} \: \Environment \, \rho \, \F_2 \, \Sim{\pi} 
%\approx \; & \msf{execUC} \: (\Environment \circ \Sim{\pi}) \, \idealP \, \F_3 \, \Sim{\rho} \\
%\equiv \; & \msf{execUC} \: \Environment \, \idealP \, \F_3 \, (\Sim{\pi} \circ \Sim{\rho}) 
\end{align}
The $\equiv$ operator is a result of moving around ITMs (some from within other ITMs into the main UC execution) and $\sim$ refers to indistinguishability.
In line (13) above, $\rho$ is moved into the execution environment with an unchanged simulator as no additional simulation is required: the simulator allows unfettered communication between parties of $\rho$ and \Environment.

\subsection{Multisession}
The multi-session extension of a protocol or functionality, specified by the $!$ operator (such as $!\rho$ or $!\F$), allows multiple instances to be run within a sinlge ITM.
The ITM simulates multiple instances of the protocol/functionality intnerally and multiplexes input/output to/from them in same way as the party wrapper for protocol parties.
The channel from the protocol wrapper to the multisession operator can be typed as:
\begin{gather}
\mi{stype} \; \m{{P2MS}[a]\{n\}} = \echoice{\mb{push}: pid \textasciicircum ssid \textasciicircum a \arrow |\{n\}> \m{P2MS[a]\{n\}}}
\end{gather}
The operator accepts messages of the form $(\msf{ssid}, msg)$ from a particular \msf{pid}, where \msf{ssid} is a sub-session identifier.
If an instance of the functionality with $\msf{sid} := \msf{ssid}$ then $!\F$ creates one and forwards the message to it.
Additionally, $!\F$ listens for outgoing messages from each of the instances and forwards them to the outside execution.
The operator differs from the party wrapper in one crucial way: it only works with functional messages types and does not wrap around any session types like any other standalone functionality in Nomos UC.

The multisession behaves like the protocol wrapper in that we rely on code generation to create the operator for a particular functionality. 
The reason behind this is that the operator simulates many instances of a functionality and must use virtual tokens to communicate with them. 
For the commitment example we've used throughout this paper, the multisession needs only one virtual token type alongside the real token type.
The commitment functionality doesn't internally simulate any other machines and therefore does not need any virtual token type itself. 
The process definition for $!\F_\msf{com}$ is shown in Figure \ref{lst:bangf} accepting two token types: the real token type $K$ and the virtual token type $K_1$ for instances of $\F_\msf{com}$.

The communicators between \bangf and the other ITMs all use the real token type.
Only the internal channels that it creates use virtual token types.
The communication pattern between the operator and the simulated functionalities works in the same was as Listing \ref{lst:sim}.

\begin{figure*}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
type sid[a] = SID of String ^ a ;

proc bangF_1[K, K1][$p2f$][$f2p$][$a2f$][$f2a$]{$p2fn$}{$f2pn$}{$a2fn$} : 
    ($\$$pw_to_f: P2MS[K][p2f]), ($\$$f_to_pw: MS2P[K][f2p]), ($\$$f_to_a: MS2A[K][f2a]), ($\$$a_to_f: A2MS[K][a2f]),
	($\$\l1: list[sender] ), ($\$$l2: list[scommitted]), ($\$$l3: list[receiver]), ($\$$l4: list[rcommitted]) |- ($\$$ms: 1)
\end{lstlisting}
\caption{The type definition for the multisession operator for functionalities and the correspond message type and import parameters.}
\label{lst:bangf}
\end{figure*}

\begin{theorem}[PPT !]\label{thm:bangppt}
If a functionality $\F$ is well-resource-typed, then it's multisession extension $!\F$ is well-resource-typed.
\end{theorem}

\begin{proof}
A \textit{well-resource-typed} \F guarantees a polynomial $T_{\F}$ bounding its execution.
In the worse-case, the multisession operator must spawn a new instance of $\F$ an every activation. 
Let $N_{\F}$ denote the total number of instances (and, hence, number of activations) of $\F$ created by the operator.
Note that $N_{\F}$ is polynomial in the security parameter $k$ for all well-typed environments, protocols, and adversary.
Therefore, there always exists a bounding polynomial to bound a polynomial number of simulated instances of \F.
The polynomial can be given as:
$$ P_{!\F}(n) = N_{\F} P_{\F}(n) + \mathcal{O}(N_{\F}) $$
where the $\mathcal{O}(N_{\F})$ is due to the overhead of maintaining and accessing the set of all instances.

Similarly, \F being \textit{well-resource-typed} ensures a valid token context for all processes it may simulate. 
Therefore, it is clear that there exists a global connecting poltnomial $f$ that ensures a valid token context for $!\F$.
\end{proof}

\begin{theorem}[Squash Theorem]\label{thm:squash}
%If a functionality \F is well-resource-typed, then $!\F$ and $!!\F$ are well-resource-typed (by Theorem~\ref{thm:bangppt}) and $(\idealP, !!\F) \sim (\msf{squash}, !\F)$.
%\textit{Well-resource-typed} \F $\Rightarrow$ $!\F \xrightarrow{\msf{squash}} !!\F$%  $(\idealP, !!\F) \sim (\msf{squash}, !\F)$
\begin{mathpar}
\inferrule*[right=squash]
{
\textit{well-resource-typed} \; \F
}
{
!\F \xrightarrow{\msf{squash}} !!\F
}
\end{mathpar}
\end{theorem}

\begin{proof}
First we describe the \msf{squash} protocol in figure \ref{fig:squash}.
Note that $!!\F$ is nested $!$ operators. The top level process maintains multiple sessions of $!\F$ each with their own \msf{ssid}.
Functionalities in each $!\F[\msf{ssid}]$ have their own \msf{sid}. 

In $(\idealP, !!\F)$, \idealP~expects to receive messages of the form $(\msf{ssid}_1, (\msf{ssid}_2, m))$ where $\msf{ssid_2}$ is a sub-session of $\F$ (i.e. instance) inside some $!\F$ with sub-session id $\msf{ssid}_1$ inside of $!!\F$ (the message accesses functionality $!!\F[\msf{ssid}_1][\msf{ssid}_2]$).
The \msf{squash} protocol flattens the indexing of instances of \F and combines session ids $\msf{ssid}_1$ and $\msf{ssid}_2$ into a single \msf{ssid}: $\msf{ssid}_3 := \msf{ssid}_1 \cdot \msf{ssid}_2$.
If follows intuitively that the view for the environment remains the same. 

We construct a simulator such that:
\[
\msf{execUC} \, \Environment \, \idealP \, !!\F \, \Sim{\msf{squash}} \approx \msf{execUC} \, \Environment \, \msf{squash} \, !\F \DummyAdv 
\]
The simulator is very simple. 
Inputs to/from parties/\Environment for a corrupt party is forwarded unmodified.
Input intended for $!\F$ of the form $(\msf{ssid}_1 \cdot \msf{ssid}_2, msg)$ sends $(\msf{ssid}_1, (\msf{ssid}_2, msg))$ to $!!\F$. 
Output from $!!\F$ is modified inversely and sent to \Environment.

The simulator is clearly \textit{well-typed} 

\end{proof}

\subsection{UC Composition}
Composition in the UC setting is not limited to replacement of a single instance of a protocol.
Instead, it permits replacement of any number of instances of a protocol $\phi$, each with their own session id, with instances of a realizing protocol $\pi$.
This generalized form of composition follows directly from Theorems \ref{thm:singlecomp} and \ref{thm:squash}.

\begin{theorem}[Composition]\label{thm:composition}
\begin{mathpar}
\inferrule*[right=compose]
{
	%(\pi, !\F_1) \sim (\idealP, F_2) \semi (\rho, !\F_2) \sim (\idealP, \F_3) \\ 
	!\F_1 \xrightarrow{\pi} \F_2 \semi !\F_2 \xrightarrow{\rho} \F_3 \\
	%\Rightarrow \exists \Simulator(\Adversary) \vdash (\rho^{!\F_2 \rightarrow (!\pi \, \circ \, \msf{squash})}, !\F_1) \sim (\idealP, \F_3)
}
{
	!\F_1 \xrightarrow{\rho \, \circ !\pi \circ \, \msf{squash}} \F_3
	%(\rho \, \circ \, !\pi \circ \msf{squash}, !\F_1) \sim (\idealP, \F_3)
}
\end{mathpar}
\end{theorem}

\begin{proof}
The proof of full composition follows directly from the single composition Theorem~\ref{thm:singlecomp} and the Squash Theorem~\ref{thm:squash}.
By Theorem~\ref{thm:singlecomp} we can infer $!!\F_1 \xrightarrow{\rho \, \circ \, !\pi} \F_3$.
Theorem~\ref{thm:squash} allows us to ``squash'' $!!\F_1$ and construct a simulator for $!\F_1 \xrightarrow{\rho \, \circ \, !\pi \, \circ \, \msf{squash}} \F_3$
\end{proof}
