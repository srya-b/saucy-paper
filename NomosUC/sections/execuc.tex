In this section we describe how the UC experiment and composition theorem are defined in NomosUC.
We also express a critically important result in the UC framework: the dummy lemma.
An important part of our definition is using code-generation techniques~\cite{somecodegeneration} to constructs some processes in the UC experiment as well ass useful operators to achieve full composition in the sense of Canetti et al.~\cite{uc}.

We first introduce some convenient notation.
For the remainder of this section, when we refer to a protocol, we actually refer to a pair of ITMs as in Definition~\ref{def:protocol}.
\begin{definition}\label{def:protocol}
A \textit{protocol} is a pair of terms ($\pi$, $\mathcal{F}$) where $\pi$ is the protocol run by honest parties and \F is an ideal functionality that parties an access.
\end{definition}
In the ideal world, $\pi$ is replaced by an an ideal protocol, \idealP, which is a dummy protocol: it frorwards message between \Z to \F for honest parties  and between \A and \F for corrupt parties.
In the real world, \F is called the \textit{hybrid functionality} and stands in for a real protocol that emulates it.
For protocols that don't make calls to any hybrid functionality, \F is just the dummy protocol which does nothing on activation by any other ITM.
The dummy functionality accepts all messages, does nothing, and continues to wait for more messages.

\subsection{The UC Experiment}
The UC experiment is an execution of a main protocol, called the \textit{challenge protocol}, consisting of protocol parties and an ideal functionality, reacting to input by an adversary \A or the \Z.
The expeirment is created by an \inline{execUC} functio which spawns all the relevant processes: the environment, a \inline{protocol wrapper}, the adversary, the \inline{functionality wrapper}.
The protocol and functionality wrappers encapsulate the protocol parties and the ideal functionality, respectively. 
We motivate their use and explain how they work later in this section, but point out that they are necessary to make use of sesion types while capturing the full UC framework.

The statically-typed nature of NomosUC requires generic process like \inline{execUC} to be parametric in the message and import token types of the protocol and functionality being executed.
Though statically-typed the \inline{execUC} function is one that is generated uniquely based on the protocol being execute, and the reason for doing some comes down to our virtual tokens construction.
For any protocol where some process, say the ideal world adversary (the simulator), internally simulates an existing UC protocol, virtual tokens must be used.
The number of virtual tokens used, and therefore statically defined, varies based on the specific processes being used.
Therefore, \inline{execUC} needs to spawn processes with a variable number of import token types. 
We rely on code-generation to take a protocol specification and create \inline{execUC} that accepts the appropriate type parameters. 
For the commitment example we've used throughout this work, the ideal world \inline{execUC} process definition looks like this:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape, caption={The process definition of the \msf{execUC} function.}]
$\tb{proc}$ $\tm{execUC}$[K][z2p][p2z]...{z2pn}{p2zn}... :
  (k: $\tgr{int}$), (r: [Bit]) |- ($\$$d: Bit)
\end{lstlisting}
In the ideal world, none of the processes, including the simulator which we will present later, require any virtual tokens. Hence there is only one virtual token type: \inline{K}.
The input parameters to the function are all generic and are required as part of a UC execution: the security parameter $k$ selected by the user and the source of random bits $r$.
The security parameter $k$ is also selected by the user and the source of randomness $r$ is given to all the ITMs by \inline{execUC}.
The type of the channel that \inline{execUC} offers, \inline{$\$$d}, is \inline{Bit} because it returns the environment's output: a bit representing its guess as to which word it thinks it's in.

%\begin{figure*}
%\input{listings/execuc}
%\caption{The \msf{execUC} function used for the two-party commitment example used througout this paper. Recall, the \msf{execUC} is customized insofar as it takes in some number of virtual token types (here, $K_1$) to enable machines that simulate other machines. In the commitment example, there is no such simulation happening at the protocol or functionality level, therefore only the real token type $K_1$ is used here. The funtion spawns all the necessary ITMs in the UC execution: the environment, the protocol wrapper, the functionalty (wrapped), and the adversary. Each is parameterized with the security parameter $k$ and a random bit sequence $\msf{rng} \in \{0,1\}^{poly(k)}$.
%At the end, the environment is started and it returns a bit $b$ which is its guess for which world it is in. The full code can be found in the Appendix.}
%\label{lst:execuc}
%\end{figure*}

We separate NomosUC into these two modules: generic code and protocol specific code. 
Therefore, the  \inline{execUC} definition doesn't include process definitions as parameters and refers to them through a modue \inline{PS}.
The module \inline{PS} is must implement the processes \inline{PS.env} for \Z, \inline{PS.func} for the functionality, \inline{PS.prot} for the protocol, and \inline{PS.adv} for the adversary.
The environment \inline{PS.env} must have the following process definition generic to all environments:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, mathescape, frame=single]
$\tb{type}$ EtoZ[a] = +{init: a ^ list[pid] -> exec} 
$\tb{type}$ exec = &{start : output_bit} ;
$\tb{type}$ output_bit = +{bit: Bit -> 1} ;
$\tb{proc}$ PS.env[K][z2p][p2z]...{z2p}{p2zn} : 
  (k: $\tgr{int}$), (r: [Bit]), 
  (#ztop: comm[z2p]), (#ptoz: comm[p2z])...
    |- ($\$$z : EtoZ)
\end{lstlisting}
The type parameters specify the token type \inline{K}, and the types of the channels \Z has to others (only between \Z and protocol wrapper is shown). Similarly, there are type parameters specifying the import parameters as well (\inline{\{z2pn\}}).
The \inline{\{z2pn\}}, for example, specifies the amount of import that must be sent by \Z with every message to a protocol party.
The rest of the processes---the adversary, protocol wrapper, and functionality--are declared in the same way except the type parameters they expect are different: the protocol wrapper would of course accept type parameters for communication between it and \F, \A, and \Z.
Finally the type of the offered channel \inline{$\$$z} is the same for all environments and communicates the \inline{sid} and set of corrupt parties chosen by \Z to \inline{execUC}.
The \inline{sid} and corrupt list are parameters to the rest of the processes that \inline{execUC} spawns. 

The type parameters given to \inline{execUC} are not directly given to the corresponding processes. All message types are wrapped in generic parametric types that represent communication between two entitis in the UC execution. 
Messages between the main entities of the execution, for example \Z and \A, all have the same parameteric types such as:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
$\Type$ p2zmsg[a] = P2Z of pid ^ a ;
$\Type$ p2fmsg[a] = P2F of pid ^ a ;
$\Type$ f2pmsg[a] = F2P of pid ^ a ;
\end{lstlisting}
The channel from \Z to the protocol wrapper will typed as: \inline{comm[z2pmsg[z2p]]\{z2pn\}} where \inline{z2p} is a type parameter to \inline{execUC}.

%The protocol \inline{PS.prot} is not spawned by \inline{execUC}. Instead the process spawns the protocol wrapper (described below) which spawns parties with that run the code \inline{PS.prot}.
%When in the ideal world, the protocol is given as the ideal protocol: one where the protocol wrapper converts the message from type \inline{z2pmsg[a]} to type \inline{p2fmsg[a]} but forwards the contents unaltered.

%The protocol wrapper and functionality wrapper manage spawning the instance(s) of the functionality and protocol parties.
%Similarly, an environment \msf{PS.env} and adversary \msf{PS.adv} must be defined as well.
%The message types exchanged between the processes are provided directly to \msf{execUC} as type parameters of the form \msf{p2f}, \msf{f2p}, and so on. 
The first thing \inline{execUC} does is create the communicators and the corresponding channels for the main processes of the execution. 
Recall from the discussion on communicators in Section~\ref{sec:nomosus} that the communicators are typed as \inline{p2zn+1} because they need at least one unit of import to handle being activated a potentially polynomial numbers of times.
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
#ptoz <- communicator_init[K][p2zmsg[p2z]]
           {p2zn+1} ;
#ztop <- communicator_init[K][z2pmsg[z2p]]
           {z2pn+1} ;
...
\end{lstlisting}
This is strictly a design decision where user-defined protocols only specify import token requirements for the protocol not taking communicators into account. 
The processes that they write, though, must conform to this standard and send an import token in addition to the amount they need.
An alternate design would be that all import type parameters take the additional import token into account and communicators send one less than they receive.
The drawback of the latter approach is that that when communicating with a process directly rather than through communicators (say, when simulating), you're sending one extra token for no reason.

Next, the environment \msf{PS.env} is spawned, \inline{execUC} receives the \inline{sid} and corrupt list from \Z, and, finally, the remainder of the processes are spawned with these inputs. 
Finally, the environment executes its own code when activated by \msf{\$z.start}, given the initial amoutn of import \inline{n}, and returns a bit through \inline{$\$$z.output_bit} which is its guess whether it's in the real or ideal world:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
$\$$z.start
$\tb{pay}$ $\$$z {n}
$\$$d <- $\$$z
\end{lstlisting}

\subsection{The Protocol Wrapper}
The \msf{execUC} definition introduces a new construct called the \textit{protocol wrapper}. 
It is instantiated with the protocol that honest parties run, and spawns new ones on-demand.

We introduce the protocol wrapper when working with session types for the following reason.
First, in the UC execution we need \Z to be able to spawn any number of protocol parties. 
If instead there was a single channel through which all parties communicated with the functionality, the session type would the product of all possible sessions for each party.
Although possible, dealing with such session types is cumbersome, and they so not allow the type to change to add new parties.
Therefore, we optto have a protocol wrapper that sandboxes all protocol parties, communicates with them through their session type, but converts messages to/from them into functionally typed messages when communicating with \F, \A, and \Z.
The user defines both the functional and session types for the protocol and the protocol wrapper handles converting between them.
%The dynamic nature of parties in UC, leads to an interesting design choice for the protocol wrapper.
%All communciation between protocol parties and \Z, \F, and \A is managed by the protocol wrapper, and the need to multiplex and de-multiplex communication between parties and other machines makes session types between them tedious and difficult to use.
%Even for simple types, a type that is a product of all possible states of all parties becomes unweildy and cumbersone to deal with.
%Furthermore, the need for a dynamic set of parties means statically typed session types, even the product of types for all parties, only support a fixed number of parties.
%Therefore, we define the protocol wrapper which runs all spawned protocol parties internall in a sandbox. 
%It communicates with the functionalty, environment, and adversary through functional message typed but internall uses session types when interacting with the parties. 
We use the two-party commitment protocol as an example to demonstrate how the construction works and show that it is generic enough to allow code generation of a wrapper for any protocol.

Recall the session types for the sender and receiver, with \Fcom, introduced in Section \ref{subsec:idealcommitment}.
%\begin{gather}
%	\mi{stype} \; \m{sender} = \ichoice{\mb{commit} : \m{bit} \product \m{scommitted}} \\
%	\mi{stype} \; \m{scommitted} = \ichoice{\mb{open} : 1} \\
%	\mi{stype} \; \m{receiver} = \echoice{\mb{commit} : \m{rcommitted}} \\
%	\mi{stype} \; \m{rcommitted} = \echoice{\mb{open} : \m{bit} \arrow \one}
%\end{gather}
At the beginning there are no parties. When the \A or \Z write to a party with some pid $p$ the protocol wrapper creates $p$ if it does not exist.
It creates and stores the session-typed channels or all of the parties in channels corresponding to their type and moves channels between them as the type evolves.
For example for parties' channel with \Z the protocol wrapper generates the following lists:
\begin{gather}
	\m{R1L1}[\m{sender}] \\
	\m{R1L2}[\m{scommitted}] \\
	\m{R2L1}[\m{receiver}] \\
	\m{R2L2}[\m{rcommitted}] 
\end{gather}
At the beginning of the protocol, the committer's \msf{z2p} channel would be in \inline{R1L1} and the receiver's is in \inline{R2L1}.
The channel's connection the protocol wrapper to the rest are still functionally typed. It's channel \inline{p2f} will still be typed \inline{#ptof: comm[p2fmsg[comp2f]]} where \inline{comp2f} is:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily]
type comp2f = Commit of Bit | Open ;
type comf2p = Committed | Open of Bit ;
\end{lstlisting}

Succinctly, the protocol wrapper functions as follows:
\begin{itemize}
\item When the protocol wrapper receives a message for some \msf{pid}, if the party doesn't exist the protocol wrapper creates all the party's channel parameterized by the correct session types (the role of the party is determined by the incoming message). The channels are stored and outgoing channels are waiting to be read from.
\item The message sent to the party with the session type is determined by the functional type. The wrapper creates a session-typed message and forwards the contents of the message to the party.
Despite accepting functionally typed messages, the protocol wrapper uses session types in this way to allow the type checker to catch invalid and out of order environments, adversaries and functionalities. 
For example, in the commitment protocol when the committer tries to commit a bit in \Fcom like this:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
$\$$p2f.commit 
$\tb{send}$ $\$$p2f b
$\tb{pay}$ {p2fn} $\$$p2f
\end{lstlisting}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
$\$$p2f.SEND 
$\tb{send}$ $\$$p2f pid 
$\tb{send}$ $\$$p2f Commit(b)
$\tb{pay}$ {p2fn} $\$$p2f
\end{lstlisting}
The party wrapper intercepts and converts it to a functionally typed message:
\item For outgoing messages, the protocol wrapper does a similar conversion where it reads the sesion typed channel output by the party and converts its message to the appropriate functional message type.
\end{itemize}

\paragraph{Functionality Wrapper}
We adopt a similar construction for functionalities, in Nomos, with the functionality wrapper.
The wrappers enables functionalities to also use session types but interact with the other ITIs in the execution through shared channels and functional message types. 
It differs from the protocol wraper in that it only spawns a single instance of the functionality, and it is created by \inline{execUC} rather than dynamically like protocol parties.

\subsection{Polynomial Bound}
An important constribution of this work is supporting runtime analysis in UC with a notion of ``polynomial'' time.
The UC framework provides a way to define poylynomial time computation and resource-bounds through the import mechanism.
It ensures that a single ITM's execution is upper-bounded by some value $T(n)$ where $T$ is a poynomial and $n$ is the total units of import the ITM eve receives.
An suitable analogy for import are tokens: a machine can receive tokens, send them out, and is limited in capability by the net number of tokens it holds. 

In NomosUC, we build import into the type system and allow reasoning about ITMs being polynomial both locally and in the context of other ITMS (say, \F is polynomial locally and when connected an adversary \A).

\begin{definition}[PPT Term]\label{def:pptterm}
A \textit{PPT term} is a \textit{well-typed} term $e(k, r)$ that is \textit{closed} except for security parameter $k$, random bit sequence $r$.
\end{definition}

We first-define terms that are well-typed in the traditional session-types-sense in Definition~\ref{def:pptterm}, i.e. without any resource constraints~\cite{sessiontypes}.
Such terms are closed except for the security parameter $k$ and some uniformly random bit sequence $r$. 

However, we also want to reason about terms that are well-typed when connected to another Nomos terms.
We introduce the term \textit{well-matched} to mean a PPT term $e$ is well-typed when connected to another term $e'$.i
Simply put, the channels that $e$ and $e'$ share are of the same type. 
Specifically, we want to exclude processes that logically share a channel, say the channel from \inline{p} to \inline{f}, but send (their types message types don't match).
This new definition becomes important when we discuss UC emulation below as we want to reason about environments that are \textit{well-matched} for a protocol $\pi$ or a specific adversary \A.

\begin{definition}[Well-Matched]\label{def:wellmatched}
\begin{mathpar}
\footnotesize
\inferrule*[right=Well-matched]
{\Tokens_1, K \semi \Delta_1 \vdash C_1 :: \Delta_1' \semi 
\Tokens_2, K' \semi \Delta_2 \vdash C_2 :: \Delta_2' \\ \\
 S \equiv \Delta_1 \bigcap \Delta_2 \neq \emptyset}
{\Delta_1 \equiv_{S} \Delta_2 \semi K \equiv K'} 
\end{mathpar}
\end{definition}

Notice that in Definition~\ref{def:wellmatched} we are concerned with two terms that are \textit{open} even when connected. 
We only care about being well-matched, when connected to another term, on the channels over which they are connected.

Next we introduce our definition of a polynomial-bound in the security parameter $k$.
Terms that are PPT in $k$ are dubbed \textit{well-resource-typed}.
\begin{theorem}[PPT in $k$]\label{thm:ppt}
A \textit{PPT Term} $e(k, r)$ is well-resource-typed if, given initial import $n(k) \in poly(k)$, there exists a polynomial $T$ s.t. $\forall k, r, e(k, r) \{n(k)\}$ terminates in at most $T(n)$ steps. 
\end{theorem}

\begin{proof}
The Nomos type system only type checks programs for which a satisfying assignment of polynomial $T$ is possible.
Given an $n \in poly(k)$, all programs that type check must be \textit{well-resource-typed.}
%The Nomos type system guarantees that a satisfying assignment of $n$ and $T$ will correctly type-check.
%Therefore, given an initial amount of import $n(k) \in poly(k)$, the existence of some $T$ ensures that any process, regardless of its randomized execution according to the bit sequence $r$, $e$ is guarantees to be upper-bounded by $poly(k)$ satisfying the definition of probabilistic polynomial time in $k$.
\end{proof}

\subsection{Emulation}
A proof of security in the UC framework relies upon emulation of different executions.

In general, we say that a protocol $\pi$ posesses the same security properties as another protocol $\phi$ if no environment can distinguish between them for any adversary.
In most cases we compare a real protocol $\pi$ with an idealized protocol $(\idealP, \F)$ which is actually just an ideal functionality with dummy parties.
The ideal functionality is known to achieve the desired security processes because it acts like a simple, trusted third party.
%They are much simpler than protocols because they don't require any special code to handle mutually distrustful other processes, and they perform the given computation on behald of the ideal world parties.

Given the random choices ITMs in UC can make, it is clear that the outputs of \inline{execUC} produces and ensemble of distributions over all possible random bitstrings and security parameters.
Emulation, then, is about the ensembles created by two UC environments being indistinguishable from each other.
We define indistinguishabiliy between ensembles in a standard way using \textit{statistical distance} in Definition~\ref{def:distance}.

\begin{definition}[Indisinguishability]\label{def:distance}
Two ensembles $\mathcal{D}_{1,k}, \mathcal{D}_{2,k}$ are indistinguishable, $\mathcal{D}_{1,k} \sim \mathcal{D}_{2,k}$, if their statistical distance is at most $negl(k), \forall k$.
\end{definition}

\paragraph{Valid Protocols}
We want to make a clarification to what are considered \textit{valid} functionalities, protocols, and environments.
When we talk about a valid functionality, we expect it to take as parameters channels to/from \A, \Z, and the protocol wrapper.
We also care about what it means for an entity, say an adversary, to be well matched with the functionality or protocol.
It means that the types of the channels they expect are the same.
Clearly, an adversary for protocol $\pi_1$ may not be well-matched with some other protool $\pi_2$.
When talking about emulation we care about ensuring well-matchedness between adversaries and environments/protocols.
We use the notation $\msf{validP}$ and $\msf{validF}$ to denote valid protocols and functionalities, and we use the notation $\A \leftrightarrow \F$ to denote that that the two processes are well-matched.

%Before we introduce the emulation definition, we first define valid protocols, valid functionalities, and what it means for protocols, functionalities, adversaries, and environments to be well-matched with each other.
%We shorten the communicator type \msf{comm} to \msf{c} in the following definitions.
%
%\todo{Ankush: The context of a valid functionality must contain channels typed with the type parameters given by \msf{execUC}. An the machine, parameterized with security parameter $k$ and random bit sequence $r$ are bounded by some polynomial $T_\F$. $\leftarrow$ the last part is meant to capture the well-resource-typed (from the well-matched definition), but maybe we can just say $\F$ is well-resource-typed given $k$,$r$}
%\begin{definition}[Valid Functionality]\label{def:validfunc}
%\begin{mathpar}to one of footnotesize
%\inferrule*[right=valid-F]
%{\exists c_1:c[\msf{p2f}], c_2:c[\msf{f2p}], c_3: c[\msf{f2a}], c_4:c[\msf{a2f}] \in \Delta_1 \\
%\Delta_1 \models (\F(k, r) : T_\F) :: \Delta_1'}
%{\msf{validF}\ \F \rightarrow \Delta_1'}
%\end{mathpar}
%\end{definition}
%
%\todo{The intent is the same as above here execpt for protocol having channels with the right types. Again here I could just say $\pi$ is well-resource-typed instead of the $\pi(k,r)$ that is there now.}
%\begin{definition}[Valid Protocol]\label{def:validprot}
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=valid-P]
%{\exists c_1: \msf{p2f}, c_2: \msf{f2p}, c_3: \msf{p2a}, c_4: \msf{a2p}, c_5: \msf{z2p}, c_6: \msf{p2z} \in \Delta_1 \\
%\Delta_1 \models (\pi(k, r) : T_\pi) :: \Delta_1' }
%{\msf{validP}\ \pi \rightarrow \Delta_1'}
%\end{mathpar}
%\end{definition}
%
%\todo{Ankush: this defines what it means for a protocol and functionality to be well-matched. Namely, they shared channels typed according to parameters given by execUc (p2f, f2p, ...) and have the same type and import parameters on their communicators}
%\begin{definition}[Well-Matched]
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=p2f match] 
%{\msf{validP}\ \pi \rightarrow \D_1 \semi \msf{validF}\ \F \rightarrow \Delta_2 \\
%\Delta_1:, (\msf{c}[K][\msf{f2p}]), (\msf{c}[K][\msf{p2f}]) \equiv \\
%\Delta_2, (\msf{c}[K][\msf{pid \textasciicircum f2p}]), (\msf{c}[K][\msf{pid \textasciicircum p2f}])}
%{\langle \pi \leftrightarrow \F \rangle}
%\end{mathpar}
%\end{definition}
%
%\todo{Ankush: same for this one and the rest, as above}
%\begin{definition}
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=p2a match] 
%{\msf{validP}\ \pi \rightarrow \Delta_1 \semi \A \rightarrow \Delta_2 \\
%\Delta_1:, (\msf{c}[K][\msf{a2p}]), (\msf{c}[K][\msf{p2a}]) \equiv \\ 
%\Delta_2, (\msf{c}[K][\msf{pid \textasciicircum a2p}]), (\msf{c}[K][\msf{pid \textasciicircum p2a}])}
%{\langle \pi \leftrightarrow \A \rangle}
%\end{mathpar}
%\end{definition}
%
%\begin{definition}
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=f2a match] 
%{\msf{validF}\ \F \rightarrow \Delta_1 \semi \A \rightarrow \Delta_2 \\
%\Delta_1:, (\msf{c}[K][\msf{a2f}]\{a2fn\}), ( \msf{c}[[K]\msf{f2a}]\{0\}) \equiv \\
% \Delta_2, (\msf{c}[K][\msf{a2f}]\{a2fn\}), ( \msf{c}[K][\msf{f2a}]\{0\})}
%{\langle \F \leftrightarrow \A \rangle}
%\end{mathpar}
%\end{definition}
%
%\begin{definition}
%\begin{mathpar}
%\footnotesize
%\inferrule*[right=p2z match] 
%{\msf{validP}\ \pi \rightarrow \Delta_1 \semi \Z \rightarrow \Delta_2}
%{\Delta_1:, (\msf{c}[K][\msf{z2p}]), (\msf{c}[K][\msf{p2z}]) \equiv \\
% \Delta_2, (\msf{c}[K][\msf{pid \textasciicircum z2p]}), (\msf{c}[K][\msf{pid \textasciicircum p2z}])}
%\end{mathpar}
%\end{definition}

Indisintiguishability between two protocols is defined as follows (we shorten the communicator type \msf{comm} to \msf{c}):

\begin{definition}[Emulation]\label{def:emulation}
Given two protocols $(\pi, \F_1), (\phi, \F_2)$ that are well-resource-typed then if $\forall \A$ well-matched with $(\pi, \F_1)$, $\exists \Sim$ s.t. $\forall \Z$ well-matched with \A and $(\pi, \F_1)$: \Sim is well-matched with $(\phi, \F_2)$, \Z is well-matched with $(\phi, \Sim)$, and $\msf{execUC}(\pi, \F_1, \Z, \A) \approx \msf{execUC}(\phi, \F_2, \Z, \Sim)$:

\begin{mathpar}
\footnotesize
	\inferrule*[right=emulate]
	{
		. \models \msf{execUC}[\Tokentypes][\alpha] :: \Delta[\Tokentypes][\alpha] \\ \\
		% Protocols that are well-matched with their functionalities
		\msf{validP}\ \pi \rightarrow \Delta_1' \semi
		\msf{validP} \phi \rightarrow \Delta_2' \semi
		\langle \pi \leftrightarrow \F_2 \rangle, \langle \phi \leftrightarrow \F_1 \rangle \\
		% Type of execUC[DELTA_pi] and execUC[DELTA_phi]
		\Delta_1'[\Tokentypes][\mathrm{T}_{\pi}] \equiv_{\Z} \Delta_1\ 
		\semi \Delta_2'[\Tokentypes][\mathrm{T}_{\phi}] \equiv_\Z \Delta_2 \\
		% For all A if exists well-typed A that is well-matched with real world
		\forall \A, (\exists (\Delta_4, \Delta_4') | \Delta_4 \vdash \A :: \Delta_4',\ \langle \A \leftrightarrow \pi \rangle, \langle \A \leftrightarrow \F_1 \rangle \\
		% implies simulator that is well-matched for ideal world
		\Rightarrow \exists (\Delta_3,\Delta_3') | \Delta_3 \vdash \Sim_\A :: \Delta_3', \langle \Sim_\A \leftrightarrow \phi \rangle, \langle \Sim_\A \leftrightarrow \F_2 \rangle \\
		% for all Z they that's well-matched for the real world => Z is well-matched with S and ideal world
		\forall \Z (\langle \Z \leftrightarrow \A \rangle, \langle \Z \leftrightarrow \pi \rangle \Rightarrow \langle \Z \leftrightarrow \Sim_\A \rangle, \langle \Z \leftrightarrow \phi \rangle \\
		% and emulation has to hold
		\msf{execUC} \ \pi\ \Z\ \F_1\ \A \approx\ \msf{execUC} \ \phi\ \Z\ \F_2\ \Sim_\A))
	}
	{
		% EMULATION DEFINITION
		\lambda \A . \Sim_\A \vdash \F_1 \xrightarrow{\pi} \F_2
		%\lambda \A . \Sim_\A \vdash (\pi, \F_1) \sim (\phi, \F_2)
	}
\end{mathpar}
\end{definition}
The emulation definition above starts with two processes $\pi$ and $\phi$ that must conform to the type-parametric definition of all protocols and that they are respectively well-matched to two functionalities $\F_1$ and $\F_2$.
It states that for all adversaries that are well-matched to both the protocol (real world) and the functionality (ideal world), there exists a well-matched simulator such that the two are indistinguisable for all environments. 
The definition ensures that for emulation to hold, the constructed simulator must be well-matched everywhere \A is well-matched: for all environments \A is well-matched with the \Sim must also be well-matched with.

\paragraph{UC Realize}
When we talk about emulation, we particularly care about emulation with respect to an ideal protocol $\phi$ which is really just $(\idealP, \F)$ where \idealP is the protocol which forwards all messages to/from \Z and \F.
We say the protocol $\pi$ (potentially with a hybrid functionality $\F_1$) UC-realizes an ideal functionality $\F_2$ if Definition~\ref{def:emulation} holds for $(\pi, \F_1)$ and  $\phi = (\idealP, \F_2)$

\begin{definition}[UC-Realize]
A protocol $\pi$ UC-realized an ideal functionality $\F_1$ if $(\pi, \F_2) \sim (\idealP, \F_1)$ for some $\F_2$.
\end{definition}

\subsection{Dummy Lemma}
The Dummy Lemma is an important lemma in the UC framework that requires only one simulator to work with a dummy adversary in order to prove emulation with respect to any adversary.
The proof of the lemma makes use of the \msf{withdrawTokens} definition from Section~\ref{sec:nomosuc}.
The instruction allows for re-use of existing machines and make simulator construction to use the real-world adversary, or other sub-simulators, in a black-box manner.

The Lemma states that if dummy simulator satisfies emulation with respect to the dummy adversary, then for any \A a simulator can be constructed with the dummy simulator. 
The constructed simulator simply runs \A and \DS internally, and it sends messages from \Z to \A and outputs of \A to \DS.
At a high leve, the proof relies on the emulation definition where dummy emulation covers environments that run \A internally. Here, we are only moving \A into the execution

\begin{theorem}[Dummy Lemma]\label{thm:dummy}
If $\exists \DS$ s.t. $ \DA, \DS \vdash \F_2 \xrightarrow{\pi} \F_1$ then $\forall \A \ \exists \Sim_\A$ s.t. $\Sim_{\A} \vdash  \F_2 \xrightarrow{\pi} \F_1)$ 
\end{theorem}

\begin{proof}
The constructed simulator $\Sim_\A$ internally simulates \DS and \A through a virtual token type $K'$. 
We describe the simulation pattern below to simulate messages to \DS and \A.
Recall that the virtual tokens consturction is a tool to make witing complex protocols easier, and has no impact on the import token requirements of the simulating machine.
Simply put, simulating as a black-box should be equivalent, with respect to import, as \Sim running the code natively. 
The only difference in running a simulation internally is additional potential usage in using \inline{$\tm{withdrawToken}$} and routing messages.

On input from \Z on channel \msf{z2p}, \Sim:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape, label={lst:sim}]
msg = $\nrecv$ $\$$z2a ;
$\nget$ $\$$z2a {z2an : K} ;
$\tm{withdrawTokens}$ f K K1 z2an ;
$\nsend$ $\$$a_z2a msg ;
$\npay$ {z2an : K1} $\$$a_z2a ; 
\end{lstlisting}

Similarly, on output from \A to a protocol party on channel \msf{a2p}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape]
pid = $\tb{recv}$ $\$$a_a2p ;
msg = $\tb{recv}$ $\$$a_a2p ;
$\tb{get}$ K1 $\$$aa2p {a2pn} ;
$\tb{send}$ $\$$sd_z2a A2P(pid, msg) ;
$\npay$ $\$$sd_z2a {z2an : K1} ;
\end{lstlisting}

$\Sim_\A$ accepts input from \Z and forwards it to the internal \A, which outputs to either the protocol parties or the ideal functionality. 
\Sim forwards this output to \DS acting as input from the environment (here we fallback to the notion that \A can be run internally by \Z) and forward any outputs it creates to the intended recipients.
The UC framework proves the emulation definition, however our proof oblication is to ensure that such a simulator in NomosUC is well-resource-typed for all well-resource-typed \A.
The $\Sim_\A$ performs constant overhead on the simulattion of \A and \DS. Therefore, a sufficient bounding polynomial on the runtime of $\Sim_\A$ can be given as:
\[
T(n) = T_{\A,\DS}(n) + T_{\A,\DS}(n) + O(n)
\]
where $T_{\A,\DS}(n)$ is the greater of the two bounding polynomials for \DS and \A evaluated at $n$, and $n$ is the import that \Z sends to \A and \Sim. 
We must also reason about the use of virtual tokens.
Given that \A and \DS are well-resource-typed we can conclude that the virtual import tokens generated for activating \A and \DS never exceeds a polynomial in the number of real import tokens received by \Sim. 
\end{proof}

\subsection{Single Composition}
In this section we present a simplified composition theorem and a second theorem we call the \textit{squash theorem}.
These two theorems combine later in the section to prove the full UC composition theorem as it appears in the UC framework~\cite{uc}.

The composition operator defines a way for a protocol $\rho$ that uses a functionality $\F_1$ to swap it for a protocol $(\pi, \F_2)$, which realizes $\F_1$, such that $\F_1 \xrightarrow{\rho} \F_3 \Rightarrow \F_2 \xrightarrow{\rho \circ \pi} \F_3$.
%$(\rho, \F) \sim (\phi, \F'') \Rightarrow (\rho \circ \pi, \F') \sim (\phi, \F'')$.
The $\circ$ composition operator is defined in Nomos in Figure~\ref{lst:compose}.

\begin{figure*}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape]
$\tb{proc}$ compose[K][z2r][r2z][f2r][r2f][p2f][f2p] : 
    (pid: Int), ($\$$z_to_p: c[K][z2p]), ($\$$p_to_z: c[K][r2z]), 
    ($\$$f_to_p: c[K][f2r]), ($\$$p_to_f: c[K][r2f])  |- ($\$$D : 1) =
{
	$\$$rho_to_pi <- $\tm{createchan}$[K][p2f];
	$\$$pi_to_rho <- $\tm{createchan}$[K][f2p];

	 <- pi  <-                 $\$$rho_to_pi $\$$pi_to_rho $\$$p_to_f $\$$f_to_p ;
	 <- phi <- $\$$z_to_p $\$$p_to_z $\$$rho_to_pi $\$$pi_to_rho ; 
}
\end{lstlisting}
\caption{Composition operator in Nomos that connects a protocol $\rho$ to a protocol $\pi$ that uses some functionality $\F$. The operators creates new channels to connect the realizing $\pi$ and it's hybrid \F. Output from $\rho$ intended for the replace functionality are actually send to parties of $\rho$, and channels outgoing from the parties to the functionality are given to $\pi$.}
\label{lst:compose} 
\end{figure*}

\todo{Include a graphical illustration of wtf is going on, and going on inside the party wrapper as}

\begin{theorem}[Composition]\label{thm:singlecomp}
\begin{mathpar}
\inferrule*[right=single-compose]
{
	\F_1 \xrightarrow{\pi} \F_2 \semi \F_2 \xrightarrow{\rho} \F_3 \\
}
{
	\F_1 \xrightarrow{\rho \circ \pi} \F_3
}
\end{mathpar}

If \textit{well-typed} $(\pi, \F_1$) realizes $\F_2$ and ($\rho$, $\F_2$) realizes some $\F_3$, then $(\rho \circ \pi, \F_2)$ is \textit{well-typed} and realizes $\F_3$ when $\circ$ is defined as in Figure~\ref{lst:compose}.
\end{theorem}

\begin{proof}
The pre-condition ensures the existence of a \textit{well-resource-typed} simulator $\Sim_\pi$ for $(\pi, \F_1) \sim (\idealP, \F_2)$. 
We construct a simulator $S$ which relies only on $\Sim_\pi$ for:
\[
	\msf{execUC}\ (\rho \circ \pi)\ \F_1\ \Z\ \A \approx \msf{execUC}\ \idealP\ \F_3\ \Z\ \Sim
\]	
We don't need to perform simulation on any inputs by \Z to the main parties of $\rho$ (it's the same protocol in both worlds).
The constructed simulator \Sim simulates \SIM{\pi} internally and passes messages intended for the parties of $\pi$, or for $\F_2$, to \SIM{\pi} and simulates its computation.
Similariy, \Sim sends any message from $\F_3$ to \SIM{\pi} for simulation.  
Input to any party of the main protocol $\rho$ from \Z, or outout from them to \Sim, are forwarded without any modification or simulation.
The constructed simulator performs constant overhead in routing messages to the simulated \SIM{\pi} and forwrading messages to/from parties of $\rho$/\Z. 
Given that \SIM{\pi} is \textit{well-resource-typed}, with bounding polynomial $T_{\SIM{\pi}}$, it suffices to show that an additional linear term is sufficient to create a bounding polynomial for \Sim.

\end{proof}

We give a simpler, high-level idea of the proof here which can be understood visually:
\begin{align}
& \msf{execUC} \: \Z \, (\rho \circ \pi) \, \F_1 \, \DA \\
\equiv \; & \msf{execUC} \: (\Z \circ \rho) \, \pi \, \F_1 \, \DA \\
\approx \; & \msf{execUC} \: (\Z \circ \rho) \, \idealP \, \F_2 \, \SIM{\pi} \\
\equiv \; & \msf{execUC} \: \Z \, \rho \, \F_2 \, \SIM{\pi} 
%\approx \; & \msf{execUC} \: (\Z \circ \Sim{\pi}) \, \idealP \, \F_3 \, \Sim{\rho} \\
%\equiv \; & \msf{execUC} \: \Z \, \idealP \, \F_3 \, (\Sim{\pi} \circ \Sim{\rho}) 
\end{align}
The $\equiv$ operator is a result of moving around ITMs (some from within other ITMs into the main UC execution) and $\sim$ refers to indistinguishability.
In line (13) above, $\rho$ is moved into the execution environment with an unchanged simulator as no additional simulation is required: the simulator allows unfettered communication between parties of $\rho$ and \Z.

\subsection{Multisession}
The multi-session extension of a protocol or functionality, specified by the $!$ operator (such as $!\rho$ or $!\F$), allows multiple instances to be run within a sinlge ITM.
The ITM simulates multiple instances of the protocol/functionality intnerally and multiplexes input/output to/from them in same way as the party wrapper for protocol parties.
The channel from the protocol wrapper to the multisession operator can be typed as:
\begin{gather}
\mi{stype} \; \m{{P2MS}[a]\{n\}} = \echoice{\mb{push}: pid \textasciicircum ssid \textasciicircum a \arrow |\{n\}> \m{P2MS[a]\{n\}}}
\end{gather}
The operator accepts messages of the form $(\msf{ssid}, msg)$ from a particular \msf{pid}, where \msf{ssid} is a sub-session identifier.
If an instance of the functionality with $\msf{sid} := \msf{ssid}$ then $!\F$ creates one and forwards the message to it.
Additionally, $!\F$ listens for outgoing messages from each of the instances and forwards them to the outside execution.
The operator differs from the party wrapper in one crucial way: it only works with functional messages types and does not wrap around any session types like any other standalone functionality in Nomos UC.

The multisession behaves like the protocol wrapper in that we rely on code generation to create the operator for a particular functionality. 
The reason behind this is that the operator simulates many instances of a functionality and must use virtual tokens to communicate with them. 
For the commitment example we've used throughout this paper, the multisession needs only one virtual token type alongside the real token type.
The commitment functionality doesn't internally simulate any other machines and therefore does not need any virtual token type itself. 
The process definition for $!\F_\msf{com}$ is shown in Figure \ref{lst:bangf} accepting two token types: the real token type $K$ and the virtual token type $K_1$ for instances of $\F_\msf{com}$.

The communicators between \bangf and the other ITMs all use the real token type.
Only the internal channels that it creates use virtual token types.
The communication pattern between the operator and the simulated functionalities works in the same was as Listing \ref{lst:sim}.

\begin{figure*}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
type sid[a] = SID of String ^ a ;

proc bangF_1[K, K1][$p2f$][$f2p$][$a2f$][$f2a$]{$p2fn$}{$f2pn$}{$a2fn$} : 
    ($\$$pw_to_f: P2MS[K][p2f]), ($\$$f_to_pw: MS2P[K][f2p]), ($\$$f_to_a: MS2A[K][f2a]), ($\$$a_to_f: A2MS[K][a2f]),
	($\$\l1: list[sender] ), ($\$$l2: list[scommitted]), ($\$$l3: list[receiver]), ($\$$l4: list[rcommitted]) |- ($\$$ms: 1)
\end{lstlisting}
\caption{The type definition for the multisession operator for functionalities and the correspond message type and import parameters.}
\label{lst:bangf}
\end{figure*}

\begin{theorem}[PPT !]\label{thm:bangppt}
If a functionality $\F$ is well-resource-typed, then it's multisession extension $!\F$ is well-resource-typed.
\end{theorem}

\begin{proof}
A \textit{well-resource-typed} \F guarantees a polynomial $T_{\F}$ bounding its execution.
In the worse-case, the multisession operator must spawn a new instance of $\F$ an every activation. 
Let $N_{\F}$ denote the total number of instances (and, hence, number of activations) of $\F$ created by the operator.
Note that $N_{\F}$ is polynomial in the security parameter $k$ for all well-typed environments, protocols, and adversary.
Therefore, there always exists a bounding polynomial to bound a polynomial number of simulated instances of \F.
The polynomial can be given as:
$$ P_{!\F}(n) = N_{\F} P_{\F}(n) + \mathcal{O}(N_{\F}) $$
where the $\mathcal{O}(N_{\F})$ is due to the overhead of maintaining and accessing the set of all instances.

Similarly, \F being \textit{well-resource-typed} ensures a valid token context for all processes it may simulate. 
Therefore, it is clear that there exists a global connecting poltnomial $f$ that ensures a valid token context for $!\F$.
\end{proof}

\begin{theorem}[Squash Theorem]\label{thm:squash}
%If a functionality \F is well-resource-typed, then $!\F$ and $!!\F$ are well-resource-typed (by Theorem~\ref{thm:bangppt}) and $(\idealP, !!\F) \sim (\msf{squash}, !\F)$.
%\textit{Well-resource-typed} \F $\Rightarrow$ $!\F \xrightarrow{\msf{squash}} !!\F$%  $(\idealP, !!\F) \sim (\msf{squash}, !\F)$
\begin{mathpar}
\inferrule*[right=squash]
{
\textit{well-resource-typed} \; \F
}
{
!\F \xrightarrow{\msf{squash}} !!\F
}
\end{mathpar}
\end{theorem}

\begin{figure}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, mathescape, frame=single]
type p2bFmsg[a] = P2bF of ssid ^ a ;
type p2bbFmsg[a] = P2bbF of ssid ^ ssid ^ a ;
$\tg{(* z2p : comm[z2pmsg[p2bbf[a]]] *)}$
$\tg{(* p2f : comm[p2fmsg[P2bf[a]]] *)}$
pid = recv $\$$z2p ;
m = recv $\$$z2p ;
case m (
  P2bbF(ssid1, ssid2, m) =>
    send $\$$p2f P2bF(ssid1 + ssid2, m) ;
)
\end{lstlisting}
\caption{The \textit{squash protocol} accepts a message intended intended for $!!\F$ of the form $(\msf{ssid}_1, (\msf{ssid}_1, msg))$ and ``flattens'' it into a single $\msf{ssid}_3 = \msf{ssid}_1 + \msf{ssid}_2$ that can be passed to $!\F$. The result is the same number of instances of \F but behind only a single $!$ operator.}
\label{fig:squash}
\end{figure}

\begin{proof}
First we describe the \msf{squash} protocol in figure \ref{fig:squash}.
Note that $!!\F$ is nested $!$ operators. The top level process maintains multiple sessions of $!\F$ each with their own \msf{ssid}.
Functionalities in each $!\F[\msf{ssid}]$ have their own \msf{sid}. 

In $(\idealP, !!\F)$, \idealP~expects to receive messages of the form $(\msf{ssid}_1, (\msf{ssid}_2, m))$ where $\msf{ssid_2}$ is a sub-session of $\F$ (i.e. instance) inside some $!\F$ with sub-session id $\msf{ssid}_1$ inside of $!!\F$ (the message accesses functionality $!!\F[\msf{ssid}_1][\msf{ssid}_2]$).
The \msf{squash} protocol flattens the indexing of instances of \F and combines session ids $\msf{ssid}_1$ and $\msf{ssid}_2$ into a single \msf{ssid}: $\msf{ssid}_3 := \msf{ssid}_1 \cdot \msf{ssid}_2$.
If follows intuitively that the view for the environment remains the same. 

We construct a simulator such that:
\[
\msf{execUC} \, \Z \, \idealP \, !!\F \, \SIM{\msf{squash}} \approx \msf{execUC} \, \Z \, \msf{squash} \, !\F \DA 
\]
The simulator is very simple. 
Inputs to/from parties/\Z for a corrupt party is forwarded unmodified.
Input intended for $!\F$ of the form $(\msf{ssid}_1 \cdot \msf{ssid}_2, msg)$ is sent as $(\msf{ssid}_1, (\msf{ssid}_2, msg))$ to $!!\F$. 
Output from $!!\F$ is modified inversely and sent to \Z.

The proposed simulator is trivially analyzed to be \textit{well-resource-typed}.
It performs constant work per activation and does ``real'' simulation other than message modification to/from $!!\F$.

\end{proof}

\subsection{UC Composition}
Composition in the UC setting is not limited to replacement of a single instance of a protocol.
Instead, it permits replacement of any number of instances of a protocol $\phi$, each with their own session id, with instances of a realizing protocol $\pi$.
This generalized form of composition follows directly from Theorems \ref{thm:singlecomp} and \ref{thm:squash}.

\begin{theorem}[Composition]\label{thm:composition}
\begin{mathpar}
\inferrule*[right=compose]
{
	%(\pi, !\F_1) \sim (\idealP, F_2) \semi (\rho, !\F_2) \sim (\idealP, \F_3) \\ 
	!\F_1 \xrightarrow{\pi} \F_2 \semi !\F_2 \xrightarrow{\rho} \F_3 \\
	%\Rightarrow \exists \Sim(\A) \vdash (\rho^{!\F_2 \rightarrow (!\pi \, \circ \, \msf{squash})}, !\F_1) \sim (\idealP, \F_3)
}
{
	!\F_1 \xrightarrow{\rho \, \circ !\pi \circ \, \msf{squash}} \F_3
	%(\rho \, \circ \, !\pi \circ \msf{squash}, !\F_1) \sim (\idealP, \F_3)
}
\end{mathpar}
\end{theorem}

\begin{proof}
The proof of full composition follows directly from the single composition Theorem~\ref{thm:singlecomp} and the Squash Theorem~\ref{thm:squash}.
By Theorem~\ref{thm:singlecomp} we can infer $!!\F_1 \xrightarrow{\rho \, \circ \, !\pi} \F_3$.
Theorem~\ref{thm:squash} allows us to ``squash'' $!!\F_1$ and construct a simulator for $!\F_1 \xrightarrow{\rho \, \circ \, !\pi \, \circ \, \msf{squash}} \F_3$
\end{proof}
