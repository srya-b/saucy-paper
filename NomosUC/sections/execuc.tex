In this section we introduce the UC experiment in Nomos and the resulting emulation definition.
We continue on to state the dummy lemma theorem as well as the composition theorem for Nomos UC.

We first introduce some convenient notation.
For the remainder of this section, when we refer to a protocol, we actually refer to a pair of ITMs as in Definition~\ref{def:protocol}.
\begin{definition}\label{def:protocol}
A \textit{protocol} is a pair of terms ($\pi$, $\mathcal{F}$) where $\pi$ is the local protocol code run by honest parties and \F is an ideal functionality parties can communcated with.
\end{definition}
In actual execution $\pi$ is encapsulated by a process called the partywrapper which handles dynamic creation of protocol party instances. 
It routes messages to internally running parties and spawns a new \msf{pid} when first activated with a message for it.
%The party wrapper is nothing more than a machine that encapsultaes all of the protocol parties and handles spawning new parties when activated with a previously unseed \msf{pid}.
%It internally runs copies of the challenge protocol and routes messages between them and the outside world.
%Additionally, it ensures that the protocol party's point of view is consistent with UC, i.e. parties are not aware of the party wrapper and do not include any ``id'' information with their messages.
Finally, protocols don't always have an associated functionality so those without one simply rely on an empty functionality which immediately releases the write token back to the environmnet when it receives it.

\subsection{The UC Experiment}
The UC experiment is an execution of a challenge protocol (protocol parties and an ideal functionality) in the presence of an adversary and an environment that gives input to both of them.
We define UC execution through an \msf{execUC}.

The \msf{ExecUC} function creates an execution of the UC experiment that spawns the environment and all of the other necessary machines: a protocol wrapper, the functionality, and the adverasry.
Figure~\ref{fig:execuc} illustrates the function in Nomos.

\begin{figure*}
\begin{lstlisting}[basicstyle=\small\ttfamily]
type sid[a] = SID of String ^ a ;

proc execUC[p2z][z2p][p2f][f2p][p2a][a2p][f2a][a2f][a2z][z2a]
           {p2zn}{z2pn}{p2fn}{f2pn}{p2an}{a2pn}{f2an}{a2fn}{a2zn}{z2an} : 
    (k: int), (rng: [Bit]) |- ($d : bit) = 
{
    $z <- PS.env[z2p][p2z][z2a][a2z] <- k r ;
    sid = recv $z ;
    clist = recv $z ;
    ...
    #pw_to_f <- communicator_init[p2f]{p2fn} <- ;
	#f_to_pw <- communicator_init[f2p]{f2pn} <- ;
	...
	send $z #pw_to_z ;
	send $z #z_to_pw ;
	$pw <- protocol_wrapper[p2z][z2p][p2f][f2p][p2a][a2p]
                           {p2zn}{z2pn}{p2fn}{f2pn}{p2an}{z2pn} 
             <- sid k rng clist #pw_to_f #f_to_pw #pw_to_a #a_to_pw #pw_to_z #z_to_pw ;
	...
	...
    $z.start ;
    $d <- $z ;
}
\end{lstlisting}
\caption{The \msf{execUC} function spawns all the necessary ITMs in the UC execution: the environment, the protocol wrapper, the functionality, and the adversary. Each is parameterized with a security parameter $k$ and a uniformly random bit string $\msf{rng} \in \{0,1\}^{poly(k)}$. At the end, the environment is initiated and it returns a bit $b$ which is its guess for which world it is in. The full code can be found in the Appendix.}
\label{lst:execuc}
\end{figure*}
A obvious omission from Figure~\ref{lst:execuc} is the code for the protocol, functionality, adversary, and environment code as inputs to the function.
The reason for this omission is that including process definitions as typed parameters is not simple in Nomos at the moment.
Therefore, we adopt a module-based representation where all the user-defined code exists in a module \msf{PS}.
The module must define the environnet, \msf{PS.env}, the functionality \msf{PS.func}, adversary \msf{PS.adv}, and protocol \msf{PS.prot}.
The message type parameters (\msf{p2f}, \msf{f2p}, ...) and import type paraemters (\msf{p2fn}, \msf{f2pn},...), however can be input as type parameters to the function.

The environment is spawned first and selects the \msf{sid} for the execution and determines the corrupted parties, \msf{clist}.
The rest of the ITMs are then spawned with this \msf{sid} and are given the list of corrupt parties.
Recall in the UC framework, corrupt parties accept input and give output to the adversary instead of the environment.
The party wrapper runs dummy parties in their place that forward messages between \Adversary and \F.

Finally, the environment executes its own code when activated by \msf{\$z.start} and returns a bit that indicates its guess as to which world it is operatin in.
Over all possible environments, security parameters $k$, and random bit sequences $r$, the output of \msf{execUC} represents an ensemble of distributions. 


%The only generic process spawned is the \msf{partyWrapper}.
%An environment may spawn any number of parties throughout its execution.
%Therefore, the \msf{partyWrapper} handle incoming message to protocol parties and spawns new processes for them on the fly.
%For existing parties, it intercepts incoming messages and routes them to the right party, and it intercepts outgoing messages and appends the ID of the writing party to them. 
%
%\todo{ Not sure if this is relevant, wait for better understanding from ankush/andrew. The total potential in the system is inferred by the Nomos type-system, and given to the first spawned process: \msf{execUC}.
%Therefore, well-typed programs are only those where the potential type parameters provide enough import for an execution.}

%\paragraph{Spawning Parties On-Demand}
%One feature of the UC framework that is not readily captured in code is spawning parties on-demand.
%When the environment writes to a protocol party for the first time, a new ITM is spawned that is an instance of the protocol code.
%The code, dubbed the \msf{protocolWrapper} in the code above, handles such behvaior and encapsulates all of the protocol parties.
%
%When protocol wrapper maintains a list of the parties that exist by their \msf{pid} and routes incoming messages directed at them, to them.
%\todo{The dictionary for storing and sending is not precise yet.}
%If the party doesn't exist, the partywrapper spawns communicators for the new party and spawns an instace of the user specified code.
%It then spawns a new process translate for each of the outgoing communicators from the new party:
%
%\begin{lstlisting}
%<- translate <- p $toF $pw_to_f ;
%\end{lstlisting}
%
%The transalte process shown in Figure~\ref{lst:translate}
%
%\begin{figure}
%\begin{lstlisting}[basicstyle=\small\ttfamily]
%proc translate[a]{an} :
%  (id: pid), (#to_inner: comm[a]{an}), 
%  (#to_outer: comm[pid ^ b]{an}) |- ($t: 1) =
%{
%  $ti <- acquire #to_inner ;
%  case $ti (
%    yes => msg = recv $ti ;
%           get {an} $ti ;
%           send $to id ^ msg ;
%           pay $to {an} ;
%           $t <- translate id #to_inner #to_outter ;
%  | no => $t <- translate id #to_inner #to_outter ;
%}
%\end{lstlisting}
%\caption{The translate function appends the ID of the sending party to all outgoing messages. The protocol code itself assumes it's writing to another ITM and does not need to both with it's own ID.}
%\label{lst:translate}
%\end{figure}

\subsection{The Protocol Wrapper}
The \msf{execUC} definition introduces a new cosntruct called the \textit{protocol wrapper}. 
In the UC experiment, the environment can create protocol parties on the fly and none exist until the first message is written to them.
Thefeore the wrapper is intended to create new parties on demand.

The necessity of a protocol wrapper leads to an interesting problem in how channels and session typed can be used.
All communciation between protocol parties and \Environment, \F, and \Adversary is managed by the protocol wrapper, and the need to multiplex and de-multiplex communication betwee parties and other machines made session types between them impossible.
It isn't possible to use multiple session-typed channels through a single communicator, parties can have different roles within a protocol so not even the same code is being executed (hence different session types governing the protocol) for each party.
Therefore, we define a new approach to creating protocol-specific party wrappers, but with a generic construction that can be used for any protocol.
We use the two-party commitment protocol as an example to demonstrate how the construction works and show that it is generic enough to allow code generation of a wrapper for any protocol.


Recall the session type governing the committer and receiver in the commitment protocol:
\begin{gather}
	\mi{stype} \; \m{sender} = \ichoice{\mb{commit} : \m{bit} \product \m{scommitted}} \\
	\mi{stype} \; \m{scommitted} = \ichoice{\mb{open} : 1} \\
	\mi{stype} \; \m{receiver} = \echoice{\mb{commit} : \m{rcommitted}} \\
	\mi{stype} \; \m{rcommitted} = \echoice{\mb{open} : \m{bit} \arrow \one}
\end{gather}

A protocol has multiple roles--for commitment it's a committer and a receiver.
The wrapper maintains a list for all of the session possible session types which hold the channels of tht type. 
For commitment the lists for the \msf{z2p} channels are the following:
\begin{gather}
	\m{R1L1}[\m{sender}] \\
	\m{R1L2}[\m{scommitted}] \\
	\m{R2L1}[\m{receiver}] \\
	\m{R2L2}[\m{rcommitted}] 
\end{gather}

The channels between the protocol wrapper and the rest of the machines are still limited to functional types through a communicator. The communicator is spawned with type \msf{z2p[z2pmsg]}.
\begin{gather}
\mi{type} \; \m{z2pmsg} = \m{Commit} \; \mi{of} \; \m{bit} \; | \; \m{Open}
\end{gather}
\[
	\mi{stype} \; \m{z2p}[a] = \m{Z2P} \; \mi{of} \; \msf{pid} \; \hat{ } \; a
\]

When receiving a message for \msf{pid}, if the party doesn't exist the protocolwrapper creates all the party's channel parameterized by the correct session types (the party's role and session types are determined by functional type of the incoming message).
The channels are stored in the appropriate lists corresponding to their type.
The session type of the message is determined by the functional type, and the session-typed message is sent along that channel.
If a message is sent out of order, \textit{the program fails to type check} due to the type mismatch between the channel at the message.
After delivering the message, the channel is moved to the next list corresponding to its new type.

For outgoing messages, a new process per party channel waits to read and does the inverse conversion: from session type to funtional type and attaches the party's \msf{pid} to it.
\todo{Does the wrapper have to use the simulation of parties? I don't think so it can just generate enough potential $T(0)$ to do constant work of routing}.


\subsection{Polynomial Bound}
The UC import mechanism provides a way to define polynomial time computation and resource-bounds by ensuring that a single ITM's execution is upper-bounded by some value $T(n)$ where $T$ is a polynomial and $n$ the total units of import the ITM ever receives.
This is enough to reason about polynomial-time, however when reasoning about security we care specifically of ITMs whose computation is bounded by some poynomial in the security parameter $k$. 
In NomosUC, we take advantage of the import built into the type system to ensure ITMs are PPT in the security parameter. 

\begin{definition}[PPT Term]\label{def:pptterm}
A \textit{PPT term} is a \textit{well-typed} term $e(k, r)$ that is \textit{closed} except for security parameter $k$, random bit sequence $r$.
\end{definition}

We first-define terms that are well-typed in the traditional session-types-sense in Definition~\ref{def:pptterm}, i.e. without any resource constraints~\cite{sessiontypes}.
Such terms are closed except for the security parameter $k$ and some uniformly random bit sequence $r$.

However, we also want to reason about terms that are well-typed when connected to another Nomos terms.
We introduce the term \textit{well-matched} to mean a PPT term $e$ is well-typed when connected to another term $e'$.
Simply put, the types that $e$ uses to communicate on its outgoing channels match those expected by $e'$ and vice versa.
This new definition becomes important when we discuss UC emulation below as we want to reason about environments that are \textit{well-matched} for a protocol $\pi$ or a specific adversary \Adversary.

\begin{definition}[Well-Matched]\label{def:wellmatched}
\begin{mathpar}
\footnotesize
\inferrule*[right=Well-matched]
{\Delta1 \vdash C_1 :: \Delta1' \semi \Delta2 \vdash C_2 :: \Delta2' \\ \\
 S \equiv \Delta_1 \bigcap \Delta \neq \emptyset}
{\Delta_1 \equiv_{S} \Delta_2}
\end{mathpar}
\todo{whats the way to express this point that they are equivalent only over the pairs $(x, \tau)$ which they share?}
\end{definition}

Notice that in Definition~\ref{def:wellmatched} we are concerned with two terms that are \textit{open} even when connected. 
We only reason about being well-matched, when connected to another term, on the channels over which they are connected.

Next we introduce our definition of a polynomial-bound in the security parameter $k$.
Terms that obey PPT in $k$ are dubbed \textit{well-resource-typed}.
\begin{theorem}[PPT in $k$]\label{thm:ppt}
A \textit{PPT Term} $e(k, r)$ is well-resource-typed if, given initial import $n(k) \in poly(k)$, there exists a polynomial $T$ s.t. $\forall k, r, e(k, r) \{n(k)\}$ terminates in at most $T(n)$ steps. 
\end{theorem}

\begin{proof}
The Nomos type system guarantees that a satisfying assignment of $n$ and $T$ will correctly type-check.
Therefore, given an initial amount of import $n(k) \in poly(k)$, the existence of some $T$ ensures that any process, regardless of its randomized execution according to the bit sequence $r$, $e$ is guarantees to be upper-bounded by $poly(k)$ satisfying the definition of probabilistic polynomial time in $k$.
\end{proof}

%In UC we care about emulation between systems of ITMs when reasoning about protocol security. 
%Therefore, we must define the notion of PPT at the ITM sytem level as well.
%First we define the \msf{execUC} function parameterized by a security parameter $k$ and a sequence of random bits $r$.
%Additionally, it has implicit parameters: protocol $\pi$, an adversary $\Adversary$, and an environment $\Environment$ that are referenced through a user-defined module \msf{PS}.
%The system of ITMs $\msf{execUC}(\pi, \Adversary, \Environment)$ is a closed term except for security parameter $k$, random bit sequence $r$, initial import $n$, and a function $T$.
%Thus, \msf{execUC} is a \textit{PPT term} and, by Theorem~\ref{thm:ppt} it is PPT in $k$ if $n \in poly(k)$.


\subsection{Emulation}
A proof of security in the UC framework relies upon emulation.

In general, we say that a protocol $\pi$ exhibits some desired security properties if no environment providing inputs to protocol parties (and the adversary) can distinguish between the $\pi$ and another pprotocol $\phi$ that possesses the desired properties.
In most cases we compare a real protocol $\pi$ with an idealized protocol $\phi$ which encapsulated by a single ideal functionality $\F$.
The ideal functionality is a trusted third party that executes the entire protocol on behalf of all of the participants.
Therefore, it is much simpler than a real protocol where mutually distrustful parties communicate with each other, and its security properties are easily proven.

It is clear from Figure~\ref{lst:execuc} that its output is a distribution induced by the random bit string $r$ (note that without any randonmess \msf{execUC} is entirely deterministic for any environment).
When we reason about emulation between two protocols what we really means is the indistinguishability between the ensembles that represent the outputs of \msf{execUC}.
We define indistinguishabiliy between ensembles in a standard way using \textit{statistical distance} in Definition~\ref{def:distance}.

\begin{definition}[Indisinguishability]\label{def:distance}
Two ensembles $\mathcal{D}_{1,k}, \mathcal{D}_{2,k}$ are indistinguishable, $\mathcal{D}_{1,k} \sim \mathcal{D}_{2,k}$, if their statistical distance is at most $negl(k), \forall k$.
\end{definition}

Indisintiguishability between two protocols is defined as follows:

\begin{definition}[Valid Functionality]\label{def:validfunc}
\begin{mathpar}
\footnotesize
\inferrule*[right=valid-F]
{\msf{p2f}, \msf{f2p}, \msf{f2a}, \msf{a2f} \in \Delta_2 \\
\Delta_2 \models (\F(clist, sid, k, r) : T_\F) :: \Delta_2'}
{\msf{validF}\ \F \rightarrow \Delta_1'}
\end{mathpar}
\end{definition}

\begin{definition}[Valid Protocol]\label{def:validprot}
\begin{mathpar}
\footnotesize
\inferrule*[right=valid-P]
{\msf{p2f}, \msf{f2p}, \msf{p2a}, \msf{a2p}, \msf{z2p}, \msf{p2z} \in \Delta_1 \\
\Delta_1 \models (\pi(sid, pid, k, r) : T_\pi) :: \Delta_1' }
{\msf{validP}\ \pi \rightarrow \Delta_1'}
\end{mathpar}
\end{definition}

\begin{definition}[Well-Matched]
\begin{mathpar}
\footnotesize
\inferrule*[right=p2f match] 
{\msf{validP}\ \pi \rightarrow \D_1 \semi \msf{validF}\ \F \rightarrow \Delta_2 \\
\Delta_1:, (\msf{ftop}: \msf{c}[\msf{f2p}]), (\msf{ptof}: \msf{c}[\msf{p2f}]) \equiv \\
\Delta_2, (\msf{ftop}: \msf{c}[\msf{pid \textasciicircum f2p}]), (\msf{ptof}: \msf{c}[\msf{pid \textasciicircum p2f}])}
{\langle \pi \leftrightarrow \F \rangle}
\end{mathpar}
\end{definition}

\begin{definition}
\begin{mathpar}
\footnotesize
\inferrule*[right=well match] 
{\msf{validP}\ \pi \rightarrow \Delta_1 \semi \Adversary \rightarrow \Delta_2 \\
cDelta_1:, (\msf{atop}: \msf{c}[\msf{a2p}]), (\msf{ptoa}: \msf{c}[\msf{p2a}]) \equiv \\ 
\Delta_2, (\msf{atop}: \msf{c} [\msf{pid \textasciicircum a2p}]), (\msf{ptoa}: \msf{c} [\msf{pid \textasciicircum p2a}])}
{\langle \pi \leftrightarrow \Adversary \rangle}
\end{mathpar}
\end{definition}

\begin{definition}
\begin{mathpar}
\footnotesize
\inferrule*[right=f2a match] 
{\msf{validF}\ \F \rightarrow \Delta_1 \semi \Adversary \rightarrow \Delta_2 \\
\Delta_1:, (\msf{atof}: \msf{c}[\msf{a2f}]\{a2fn\}), (\msf{ftoa}: \msf{c}[\msf{f2a}]\{0\}) \equiv \\
 \Delta_2, (\msf{atof}: \msf{c}[\msf{a2f}]\{a2fn\}), (\msf{ftoa}: \msf{c}[\msf{f2a}]\{0\})}
{\langle \F \leftrightarrow \Adversary \rangle}
\end{mathpar}
\end{definition}

\begin{definition}
\begin{mathpar}
\footnotesize
\inferrule*[right=p2z match] 
{\msf{validP}\ \pi \rightarrow \Delta_1 \semi \Environment \rightarrow \Delta_2}
{\Delta_1:, (\msf{ztop}: \msf{c}[\msf{z2p}]), (\msf{ptoz}: \msf{c}[\msf{p2z}]) \equiv \\
 \Delta_2, (\msf{ztop}: \msf{c}[\msf{pid \textasciicircum z2p]}), (\msf{ptoz}: \msf{c}[\msf{pid \textasciicircum p2z}])}
\end{mathpar}
\end{definition}


\begin{definition}[Emulation]\label{def:emulation}
Given two protocols $(\pi, \F_1), (\phi, \F_2)$ that are well-resource-typed then if $\forall \Adversary$ well-matched with $(\pi, \F_1)$, $\exists \Simulator$ s.t. $\forall \Environment$ well-matched with \Adversary and $(\pi, \F_1)$: \Simulator is well-matched with $(\phi, \F_2)$, \Environment is well-matched with $(\phi, \Simulator)$, and $\msf{execUC}(\pi, \F_1, \Environment, \Adversary) \approx \msf{execUC}(\phi, \F_2, \Environment, \Simulator)$:

\begin{mathpar}
\footnotesize
	\inferrule*[right=emulate]
	{
		. \models \msf{execUC}[\alpha] :: \Delta [\alpha] \\ \\
		% Protocols that are well-matched with their functionalities
		\msf{validP}\ \pi \rightarrow \Delta_1' \semi
		\msf{validP} \phi \rightarrow \Delta_2' \semi
		\langle \pi \leftrightarrow \F_2 \rangle, \langle \phi \leftrightarrow \F_1 \rangle \\
		% Type of execUC[DELTA_pi] and execUC[DELTA_phi]
		\Delta[\mathrm{T}_{\pi}] \equiv_{\Environment} \Delta_1\ 
		\semi \Delta[\mathrm{T}_{\phi}] \equiv_\Environment \Delta_2 \\
		% For all A if exists well-typed A that is well-matched with real world
		\forall \Adversary, (\exists (\Delta_4, \Delta_4') | \Delta_4 \vdash \Adversary :: \Delta_4',\ \langle \Adversary \leftrightarrow \pi \rangle, \langle \Adversary \leftrightarrow \F_1 \rangle \\
		% implies simulator that is well-matched for ideal world
		\Rightarrow \exists (\Delta_3,\Delta_3') | \Delta_3 \vdash \Simulator_\Adversary :: \Delta_3', \langle \Simulator_\Adversary \leftrightarrow \phi \rangle, \langle \Simulator_\Adversary \leftrightarrow \F_2 \rangle \\
		% for all Z they that's well-matched for the real world => Z is well-matched with S and ideal world
		\forall \Environment (\langle \Environment \leftrightarrow \Adversary \rangle, \langle \Environment \leftrightarrow \pi \rangle \Rightarrow \langle \Environment \leftrightarrow \Simulator_\Adversary \rangle, \langle \Environment \leftrightarrow \phi \rangle \\
		% and emulation has to hold
		\msf{execUC} \pi\ \Environment\ \F_1\ \Adversary \approx\ \msf{execUC} \phi\ \Environment\ \F_2\ \Simulator_\Adversary))
	}
	{
		% EMULATION DEFINITION
		\lambda \Adversary . \Simulator_\Adversary \vdash (\pi, \F_1) \sim (\phi, \F_2)
	}
\end{mathpar}
\end{definition}


Particularly, we care about emulation with respect to an ideal protocol $\phi$ which is really just $(\idealP, \F)$ where \idealP is the ideal protocol which forwards all messages to/from \Environment and \F.
We say the protocol $\pi$ UC-realizes an ideal functionality $\F_2$ if Definition~\ref{def:emulation} holds for $(\pi, \F_1)$ and  $\phi = (\idealP, \F_2)$

\begin{definition}[UC-Realize]
A protocol $\pi$ UC-realized an ideal functionality $\F_1$ if $(\pi, \F_2) \sim (\idealP, \F_1)$ for some $\F_2$.
\end{definition}

This definition does not explicitly mention the import requirements of the types of the channels in the context in each of the two protocols. 
We elide this point in the definition because the type system already provides this guarantee given the UC execution model.
The same environment \Environment is run for both protocols (and both worlds), and, therefore, the UC execution type checks when \Environment is well-matched for both worlds (i.e. gives the same messages and the same import along all channels).

%\paragraph{Simulation Proofs}
%Simulation proofs in Nomos UC rely heavily on the type system to ensur that the constructed simlation is well-matched with the protocols in the ideal world and that it is locally polynomially-bound.
%Showing that a simulator is well-matched with $\phi$ and environments \Environment that are well-matched with \Adversary requires ensuring that \Simulator is well-typed under the type parameters \msf{z2a}, \msf{p2a}, \msf{f2a} and their analogues for the opposite direction of communication. 
%Well-typed, though, only captures the fact that the import sent with messages to \Simulator has \textit{enough} import to perform all of its computation on activation. 
%To show  polynomial in PPT it suffices to provide a bounding polynomial $T$ such that the import \Simulator receives, $n$, is sufficient to bound its run-time by $T(n)$. 
%
%Finally, indistinguishability of the distributions of \msf{execUC} requires standard UC reasoning about the message sent by \Simulator, when they are sent and their affect on the output received by \Environment.

\subsection{Dummy Lemma}
The dummy lemma makes use of the \msf{runInSandbox} and \msf{withdrawTokens} program definisions defined in Section~\ref{sec:nomosuc}.
These to programs enable process re-use to simplify complicated protocols, such as a simulator, which can refer to existing processes as black boxes.
Virtual tokens are required to satisfy the message and import types of the processes being simulated and exists only to enable this behavior.
The actual import usage required by a machine simulating another is no more than if all code was run natively within one process.

The Lemma states that if dummy simulator satisfies emulation with respect to the dummy adversary, then for any \Adversary a simulator can be constructed with the dummy simulator. 
The constructed simulator runs \Adversary and \Dummysim internally. It sends messages from \Environment to \Adversary and outputs of \Adversary to \Dummysim.
At a high level the proof asserts that the constructed simulator is the same as \Environment running \Adversary internally and sending its output to \Dummysim -- an environment for which dummy emulation is already guaranteed.


\begin{theorem}[Dummy Lemma]\label{thm:dummy}
If $\exists \Dummysim^{K}$ s.t. $ \DummyAdv^K, \Dummysim^K \vdash (\pi, \F_2) \sim (\phi, \F_1)$ then $\forall \Adversary \ \exists \Simulator_\Adversary^K$ s.t. $\Simulator_{\Adversary} \vdash  (\pi, \F_2) \sim (\phi, \F_1)$ 
%For protocols $\pi$ and $\phi$, $\msf{execUC}(\pi, \Environment, \DummyAdv) \sim \msf{execUC}(\phi, \Environment, \Simulator_{\mathcal{D}}) \forall \Environment \Rightarrow \exists$ \textit{well-resource-typed, PPT} $\Simulator_{\mathcal{D}}$ s.t. $\msf{execUC}(\pi, \Environment, \Adversary') \sim \msf{execUC}(\phi, \Environment, \Simulator')$ for any other \textit{well-resource-typed} $\Adversary'$.
\end{theorem}

\begin{proof}
The constructed simulator $\Simulator_\Adversary^K$ internally simulates \Dummysim and \Adversary with respected virtual token types $K_1$ and $K_1$. 
We use the internal simulation pattern described above to simulat messages to \Dummysim and \Adversary through virtual tokens.
Recall that the virtual tokens consturction is a tool to make witing complex protocols easier.
In fact it has no impact on the amount of import that the simulating machine requires or receives.
The only difference in running all code natively is the potential usage is higher in managing the simulated processes and messages between them.

On input from \Environment on channel \msf{z2p}, \Simulator:
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape]
msg = $\nrecv$ $\$$z2a ;
$\nget$ K $\$$z2a {z2an} ;
$\tm{withdrawTokens}$ f K K1 z2an ;
$\nsend$ $\$$a_z2a msg ;
$\nsimpay$ K1 {z2an} $\$$a_z2a ; 
\end{lstlisting}

Similarly, on output from \Adversary to a protocol party on channel \msf{a2p}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape]
pid = $\tb{recv}$ $\$$a_a2p ;
msg = $\tb{recv}$ $\$$a_a2p ;
$\tb{get}$ K1 $\$$aa2p {a2pn} ;
$\tm{withdrawTokens}$ f K K2 z2an ;
$\tb{send}$ $\$$sd_z2a A2P(pid, msg) ;
$\tm{simpay}$ K2 $\$$sd_z2a {z2an} ;
\end{lstlisting}

$\Simulator_\Adversary$ forwards input from \Environment and forwards it to the internal \Adversary. 
\Adversary output to either the protocol parties or the 

The construction provided is identical to the original dumy lemma in the UC framework~\cite{uc}, however, we must show that the constructed simulator $\Simulator_\Adversary$ is well-resource-typed for all well-resource-typed \Adversary.
By the assumption that \Adversary and \Dummysim are well-resource-typed, $\Simulator_\Adversary^K$ is well-resource-typed because it performs consatnt work routing messages internally. 
It suffices to find a suitable polynomial bound.

We provide a polynomial bound to bound the execution of $\Simulator_\Adversary^K$:
\[
T(n) = T_{\Adversary,\Dummysim}(n) + T_{\Adversary,\Dummysim}(n) + O(n)
\]
where $T_{\Adversary,\Dummysim}(n)$ is the greater of the two bounding polynomials for \Dummysim and \Adversary evaluated at $n$, and $n$ is the import that \Environment sends to \Adversary. 
The constant factor accounts for the a constant overhead for routing messages between \Dummysim and \Adversary.


%The construction is identical to the original dummy lemma in the UC framework, however, it remains to be shown that this construction maintains the polynomial time constraint.
%Proving this claim involves reasoning that such a machine remains polynomial time, even with new virtual tokens, assuming the simulated machines \Adversary and \Dummysim are well-resource-typed.
%
%As mentioned in Section~\ref{sec:nomosuc}, the virtual tokens definition is purely a tool to enable reuse of process in a way that satisfies their types. 
%It allows message passing to other process, namely from the construced simulator \Simulator to the internal \Adversary.
%Effectively, the definition of virtual tokens ensures that the import token usage of simulating a machine $M$ versus simply running the code of the machine natively are no different in their import usage. 
%	With constant overhead, the potential used by the constructed simulator as a function of its import tokens can be bounded by 
%
%
%Let $P_\Adversary$ and $P_{\Dummysim}$ be the bounding polynomials for \Adversary and \Dummysim.
%We set the maximum of the two bounding polynomials to be the polynomial through which new tokens of type $K_\Adversary$ and $K_{\Dummysim}$. 
%
%We provide the construction of $\Simulator_\Adversary^K$.
%The constructed simulator internally runs the real world adversary \Adversary with a virtual token type $K_1$ and the \Dummysim with a virtual token type $K_2$.
%
%It internally runs the real-world adversary \Adversary and the dummy simulator \Dummysim. 
%
%$\Simulator_\Adversary$ 
%It is trivial to notice that $(\Adversary, \pi), (\Adversary, \F_2)$ well-matched $\Rightarrow$ $(\Simulator_\Adversary, \phi), (\Simulator_\Adversary, \pi)$ well-matched, and that $\forall \Environment, (\Environment, \Adversary), (\Environment, \pi)$ well-matched $\Rightarrow$ $(\Environment, \Simulator_\Adversary), (\Environment, \phi)$ well-matched.



%We provide a construction of a simulator \Simulator' for any adversary \Adversary that is well-matched to $\pi$ s.t. \Simulator' is well-matched for all \Environment where \Adversary is well-matched with \Environment.
%Finally, we prove the validity of the construction in order to prove 
%\[
%\forall Z \msf{execUC} (\phi, \F_1, \Environment, \Simulator') \sim \msf{execUC}(\pi, \F_2, \Environment, \Adversary)
%\]
%
%The constructed \Simulator' internally simulates \Adversary and routes messages from \Environment to \Adversary.
%Thus \Simulator' is well-matched with \Environment everywere \Adversary is.
%Secondly, it runs a simulatio of \Dummysim which accepts input from \Adversary and backdoor input from $\phi$ and $\F_2$.
%
%Theorem~\ref{thm:dummy} can be broken up into smaller parts to prove individually.
%
%By our construction, \Simulator' runs \Adversary internally, therefore \Adversary well-matched with \Environment $\Rightarrow$ \Simulator' well-matched with \Environment.
%Similarly, $(\pi, \F_1) \sim (\idealP, \F_2) \Rightarrow \Dummysim$ well-matched with $(\idealP, \F_2) \Rightarrow \Simulator'$ well-matched with $(\idealP, \F_2)$.
%
%Our definition of \textit{well-matched} form our emulation definition also requires that \Simulator' be well-matched with all such \Environment even in the import type parameters. 
%We provie this by providing a simple polynomial bound for \Simulator that satisfies the definition of \textit{well-resource-typed}.
%As \Simulator' only accepts import from \Environment it suffices that a satisfying poynomial bound be: 
%\[
%T(n) = T_{\Adversary,\Dummysim}(n) + T_{\Adversary,\Dummysim}(n) + O(n)
%\]
%where $T_{\Adversary,\Dummysim}(n)$ is the greater of the two bounding polynomials for \Dummysim and \Adversary evaluated at $n$, and $n$ is the total amount of import received by \Simulator'.
%\Simulator' performs constant overhead in routing messages between \Adversary and \Dummysim, therefore we can concude that with $T(n)$ defined above, \Simulator' is \textit{well-resource-typed} and satisfies Definition~\ref{def:emulation} for all pre-conditions but indistinguishability.
%
%\todo{Can we rely on he validity proof from the UC paper or do we need to state it here with a typed environment?}
\end{proof}

\subsection{Single Composition}
In this section we present a simplified composition theorem and another theorem, which we call the \textit{squash theorem}.
These two theorems combine to prove the full generalized composition theorem as it appears in the UC framework~\cite{uc}.

The composition operator defines a way for some protocol $\rho$ that uses a functionality $\F$ to swap $\F$ for a procol $(\pi, \F')$, which realizes $\F$, such that $(\rho, \F) \sim (\phi, \F'') \Rightarrow (\rho \circ \pi, \F') \sim (\phi, \F'')$.
The $\circ$ composition operator is defined in Nomos in Figure~\ref{lst:compose}.

Recall that the Nomos language currently does not support passing processes as arguments to other processes even though the theory allows it. 
In the $\circ$ code the protocols $\pi$ and $\phi$ exist globally.

\begin{figure*}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single,  mathescape]
$\tb{proc}$ compose[z2r][r2z][f2r][r2f][p2f][f2p] : 
	(pid: Int),
	($\$$z_to_p: z2p), ($\$$p_to_z: r2z), ($\$$f_to_p: f2r), ($\$$p_to_f: r2f) |- ($\$$D : 1) =
{
	$\$$rho_to_pi <- $\tm{createchan}$[p2f];
	$\$$pi_to_rho <- $\tm{createchan}$[f2p];

	 <- pi  <-                 $\$$rho_to_pi $\$$pi_to_rho $\$$p_to_f $\$$f_to_p ;
	 <- phi <- $\$$z_to_p $\$$p_to_z $\$$rho_to_pi $\$$pi_to_rho ; 
}
\end{lstlisting}
\caption{Composition operator in Nomos that connects a protocol $\rho$ to a protocol $\pi$ that uses some functionality $\F$.}
\label{lst:compose} 
\end{figure*}

\todo{Include a graphical illustration of wtf is going on, and going on inside the party wrapper as}

\begin{theorem}[Composition]\label{thm:composition}
\begin{mathpar}
\inferrule*[right=single-compose]
{
	(\pi, \F_1) \sim (\idealP, \F_2) \semi (\rho, \F_2) \sim (\idealP, \F_3) \\
	\Rightarrow \exists \Simulator(\Adversary) \vdash (\rho^{\F_2 \rightarrow \pi}, \F_1) \sim (\idealP, \F_3)
}
{
	(\rho \circ \pi, \F_1) \sim (\idealP, \F_3)
}
\end{mathpar}

If \textit{well-typed} $(\pi, \F_1$) realizes $\F_2$ and ($\rho$, $\F_2$) realizes some $\F_3$, then $(\rho \circ \pi, \F_2)$ is \textit{well-typed} and realizes $\F_3$ when $\circ$ is defined as in Figure~\ref{lst:compose}.
\end{theorem}

\begin{proof}
By Theorem~\ref{thm:dummy}, it suffices to prove emulation with respect to the dummy adversary:
\[
	\msf{execUC}\ \rho^{\phi \rightarrow \pi} 
\]	


The proof proceeds in a similar way to the proof of the Dummy Lemma in Theorem~\ref{thm:dummy}. 
The Composition opreator $\circ$ combines parties of $\rho$ with parties of $\pi$ within the party wrapper (defined previously). 
Parties running protocl $\rho$ send messages to parties of $\pi$ which then communicate with the functionality $\F_1$.
UC emulation states that the functionality $(\idealP, \F_2)$ replaced by a realizing protocol $(\pi, \F_1)$ is indistinguishable even from parties of $\rho$.

The proof is in the form of a simulator that internally runs simulates the real-world \Adversary and the simulator $\Simulator_\pi$ for $(\pi, \F_2)$.
The simualator uses the same simulation construction as used by the Dummy Lemma simulator. 
The inputs from \Environment are passed to the \Adversary, and outputs by the adversary for $\F_3$ are sent to $\Simulator_pi$.
Outputs from \Adversary to the protocol parties is sent to the 

The simulation in \Simulator proceeds like the code listings for the Dummy Lemma.
Messages from \Environment are forwarded to the internal \Adversary. 
Outputs from \Adversary to protocol parties are forwarded to them, and all other outputs are forward to $\Simulator_\pi$ as \Environment.

Similar to the dummy lemma proof, a bouning polynomial for the new simulator \Simulator is easy to obtain because it simulates two well-resource-typed adversaries internally (\Adversary and $\Simulator_\pi$) with some constant communiation overhead for routing messeages between them and other ITMs. 
\end{proof}

\subsection{Multisession}
The multi-session extension of a protocol or functionality, specified by the $!$ operator (such as $!\rho$ or $!\F$), allows multiple instances to be run within a sinlge ITM.
The ITM simulates multiple instances of the protocol/functionality intnerally and multiplexes input/output to/from them in same way as the party wrapper for protocol parties.
The operator accepts messages of the form $(\msf{ssid}, msg)$ where \msf{ssid} is a sub-session identifier.
If an instance of the functionality with $\msf{sid} := \msf{ssid}$ then $!\F$ creates one and forwards the message to it.
Additionally, $!\F$ listens for outgoing messages from each of the instances and forwards them to the outside execution.
The operator differs from the party wrapper in one crucial way: it only works with functional messages types and does not wrap around any session types.
Like the single functionality, functionalities in this operator also only deal with functional message types.
The execution, instead, relies on the session types of the protocol parties to enforce message/protocol ordering.

%It accepts as type parameters the types of messages exchanges between protocol parties and the functionality (\msf{p2f} and \msf{f2p}) and between the adversary and \F (\msf{a2f} and \msf{f2a}). 
%The type of communicators between parties and $!\F$ need to reflect the change in interface. 
%All messages from \msf{p2f} must be typed with the \msf{pid} of the sending party and the \msf{ssid} of the instance of \F. 
%The same goes for \F. 
%For a generic multisession operator, the import type specify the import send to any instance of the functionality.
%As $!\F$ maintains an ever growing list of instaces of $\F$ it requires some import be given to it by the protocol parties. 
%Definitions of an instance of $\msf{execUC}(\Environment, \pi, !\F, \Adversary)$ that specfies the import parameter \msf{p2fn} as 0 will not suffice for emulation as it will not hold for all environments. 

\begin{figure*}
\begin{lstlisting}[basicstyle=\small\BeraMonottFamily, frame=single, mathescape]
type sid[a] = SID of String ^ a ;

proc bangF_1[$p2f$][$f2p$][$a2f$][$f2a$]{$p2fn$}{$f2pn$}{$a2fn$} : 
	(#pw_to_f: comm[pid ^ sid ^ $p2f$]{p2fn}), (#f_to_pw: comm[pid ^ sid ^ $f2p$]{f2pn}),
	(#a_to_f: comm[sid ^ $a2f$]{a2pn}), (#f_to_a: comm[sid ^ $f2a$]{0}),
	($\$$lf: list[comm[])  |- ($\$$ms: 1) =
\end{lstlisting}
\caption{The type definition for the multisession operator for functionalities and the correspond message type and import parameters.}
\label{lst:bangf}
\end{figure*}


\begin{theorem}[PPT !]\label{thm:bangppt}
If a functionality $\F$ is well-resource-typed, then it's multisession extension $!\F$ is well-resource-typed.
\end{theorem}

\begin{proof}

Let $P_{\F}$ be a bounding polynomial for $\F$ such that $\F$ is well-resource-typed. 
In the worse-case, the multisession operator must spawn a new instance of $\F$ an every activation. 
Let $N_{\F}$ be the total number of instances of $\F$ created by the operator.
Note that $N_{\F}$ is polynomial in the security parameter $k$ for all well-typed environments.
Therefore, a bounding polynomial for $!\F$ can be given as:
$$ P_{!\F}(n) = N_{\F} P_{\F}(n) + \mathcal{O}(N_{\F}) $$
where the $\mathcal{O}(N_{\F})$ is due to the overhead of maintaining and accessing the set of all instances.
Obviously, such a polynomial satisfies the definition of PPT in $k$ and is a sufficient bounding polynomial to ensure $!\F$ is well-resource-typed everywhere $\F$ is well-resource-typed.
\end{proof}

\begin{theorem}[Squash Theorem]
If a functionality \F is well-resource-typed, then $!\F$ and $!!\F$ are well-resource-typed (by Theorem~\ref{thm:bangppt}) and $(\idealP, !!\F) \sim (\msf{squash}, !\F)$.
\end{theorem}

\begin{proof}
First we describe the \msf{squash} protocol in figure \ref{fig:squash}.
Note that $!!\F$ is nested $!$ operators. The top level process maintains multiple sessions of $!\F$ wach with their own \msf{sid}, \msf{ssid}. 
Functionalities in each $!\F[\msf{ssid}]$ have their own \msf{sid}. 

At a high-level:
In $(\idealP, !!\F)$, \idealP~expects to receive messages of the form $(\msf{ssid}_1, (\msf{ssid}_2, m))$ where $\msf{ssid_2}$ is a sub-session of $\F$ (i.e. instance) inside some $!\F$ with sub-session id $\msf{ssid}_1$ inside of $!!\F$. 
A two dimensional array is the best analogy for this construction.
The \msf{squash} protocol flattens the indexing of instances of \F and combines session ids $\msf{ssid}_1$ and $\msf{ssid}_2$: $\msf{ssid}_3 := \msf{ssid}_1 \cdot \msf{ssid}_2$ 
It follow logically that the two worlds are indistinguishable from the part of the environment.

\textit{Well-resource-typed}:
When reasoning about well-resource-typed, we want that every well-typed environment for $(\msf{squash}, !F)$ should be well-typed for $(\idealP, !!F)$.
\todo{need to specify the terminology here and get ankush's input about what to say about being well-typed for certain ITMs (F , A, etc.), partial well-typed }
Multiplexing performed in $\msf{squash}$ is a constant-time overhead per activation and $!\F$ overhead of accessing a set of instances of $\F$ is grows lineraly with new instances.
As described above, a multisession operator defined like this requires some import to be provided by the calling protocol parties.
The ideal world of $(\idealP, !!\F)$ moves the multiplexing performed by \msf{squash} into the functionality. 
Therefore given the same import as the real world, it is clear that all well-typed environments for $(\msf{squash}, !\F)$ are also well-typed for $(\idealP, !!\F)$.

As the underlying functionality in in both worlds is $\F$, the \msf{squash} simulator for the dummy adversary need only route messages between the functionality and the environment and perform multiplexing on behalf of corrupted parties.
Therefore, it is clear that $(\idealP, !!\F) \sim (\msf{squash}, !\F)$.

\todo{ Below is what I wrote first and i don't like it but it's there for all to see }
It is clear from our construction, that \msf{squash} is well-resource-typed as it performs a constant amount of work per activation.
Therefore, for well-typed environments, \msf{squash} is always PPT in $k$.
Similarly, by Theorem~\ref{thm:bangppt}, if $!\F$ is well-resource-typed then so is $!\F$.

The dummy simulator we construct $\Simulator_{\msf{squash}}$ is also well-resource-typed for any environment that is well-typed in the real world with the dummy adversary. 
This is clear from the constant amount of computation performed by it per activation.

For any well-typed environment with $(\msf{squash}, !\F)$, $(\idealP, !!\F)$ is also well-resource typed.
both $!!\F$ and $!\F$ spawn the same number of instances of \F internally with 


It is clear from our construction that \msf{squash} is well-resource-typed as performs a constant amount of work per activation (\todo{Need to say more like "well-resource-typed for well-resource-typed environments/functionalities/adversaries"?})
By the previous theorem, both $!\F$ and $!!\F$ are well-resource-typed because $\F$ is well-resource-typed.
\end{proof}

%%
%Notes
%%

% It should be okay that we have one global T because processes can't depend on the type T,n basically. 
% We can just have T as part of the type and then we should be good to go.
% Composition theorem  
w


%\begin{definition}
%For any term $e$ that is \textit{well-typed}, $\exists n \in \mathbb{N}$ and a poynomial $T$ s.t. $e$ halts in $\leq T(n) steps$.
%
%Given some potential T(n) where n in poly(k) 
%
%Poised state a configuration of processes ==> saying that it has terminated to a value. For any configuration $e$ within $T(n)$ step it will reach a poised state.
%Every exeution step it takes its potential goes down and the sum of that is always a constant. 
%In the end the potential will be non-negative <= T(n).
%
%only closed and only well-typed
%security parameter has to be present
%
%1. givne polynomial import 
%
%2. dependent on some paramter $k$ then it is still PPT then it is well-typed
%
%3. random strings: it's necessar to just talk about distributions associated with closed terms
%
%\end{definition}
%
%\begin{definition}
%For all $k \in \mathbb{N}$ and $r \in \{0,1\}^{poly(k)}$ the term $\msf{execUC}_{k,r,n,T}(\Environment, \phi, \F, \Adversary)$ is \textit{well-typed} if $\exists n, T$ s.t. $\msf{execUC}_{k,r,n,T}$ executes in $\leq T(n)$ steps.
%\end{definition}
%
%\begin{definition}\label{def:emulation}
%Given well-typed protocols $\pi = (\mathcal{P}(\pi_1), \mathcal{F}_1)$, $\phi = (\mathcal{P}(\phi_2), \mathcal{F}_2)$, adversary $\mathcal{A}$, and simulator $\mathcal{S}$, $\pi$ and $\phi$ securely emulate each other if for all environments $\mathcal{Z}$, security parameters $k$ $\msf{execUC}_{k,r,n,T} (\mathcal{Z}, \phi_2, \mathcal{F}_2, \mathcal{S})$ and  $\msf{execUC}_{k,r} (\mathcal{Z}, \pi_1, \mathcal{F}_1, \mathcal{A})$ are \textit{well-typed}  and $\msf{execUC}_k (\mathcal{Z}, \phi_2, \mathcal{F}_2, \mathcal{S}) \sim \msf{execUC}_k (\mathcal{Z}, \pi_1, \mathcal{F}_1, \mathcal{A})$.
%\end{definition}
%
%\begin{theorem}
%If there exists a well-typed \msf{PPT} simulator $\mathcal{S}_d$ as in Definition~\ref{def:emulation} such that $\forall \mathcal{Z}, \msf{execUC}_{k,r,n,T}(\mathcal{Z}, \phi, \F_2, \mathcal{S}_d) \sim \msf{execUC}_{k,r,n,T}(\mathcal{Z}, \pi, \F_1, \mathcal{A}_d)$, where $\mathcal{A}_d$ is the dummy adversary, $\Rightarrow \exists \mathcal{S}$ s.t. $\msf{execUC}_{k,r}(\mathcal{Z}, \phi, \F_2, \mathcal{S}) \sim \msf{execUC}_{k,r}(\mathcal{Z}, \pi, \F_1, \mathcal{A}$ for any well-typed PPT $\mathcal{A}$.
%
%swap the quanitifers for any A there exists an S
%all Z needs to be present for all of them.
%
%\end{theorem}
%
%\begin{figure}
%
%\end{figure}
