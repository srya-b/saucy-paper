\subsection{Universal Composability}
The universal composability framework~\cite{uc} proposes a new framework for proving the security of cryptographic and distributed protocols.
It builds on compositional guarantees attemted by previous works and provides a security under arbitrary composition with any other, arbitrary protocols running concurrently in the same environment.
The framework relies probabilistic polynomial time (PPT) interactive turing machines (ITMs) providing input and output to each other by means of multipe tapes as its model of computation. 

Its compositional security relies on the real/ideal paradign defined by the real world with its protocol $\pi$ and real adversary \A, and by the ideal world with the ideal functionality $\F$ and a simulator, \Sim.
The ideal functionaity is a trusted party which accepts inputs from dummy parties~\footnote{Dummy parties do nothing but forward input from the environment (if they are honest) or the adversary (if they are corrupt) to the functionality and vice versa.} and performs the intended computation. Due to it's trusted, or ``ideal'', nature, the functionality is simple and rarely requires any cryptography or networking. 
The real world protocol is code run locally by mutually distrustful protocol parties (ITMs) which can communicate each other and interact with an ideal functionality called the hybrid functionality.
An environment \Z, meant to capture all possible concurrently running protocols, gives input to the honest parties of the protocol and input to the adverasary who controls the corrupt protocol parties. 
Based on the output it receives, \Z outputs a bit as its guess as to which world it is in. 

Proving the security of a protocol in UC relies on creating a simulator in the ideal world to simulate a given adversary in the real world and making the two worlds computationally indistinguishable to all possible environments. 
Full emulation requires that for each real world adversary there is a such a simulator for all environments. We define emulation as follows, where \msf{execUC} is encapsulates a UC execution consisting of the component parts:
\[ \forall \A \; \exists \Sim \; \forall \Z \; \; \msf{execUC} \; \Z \, \phi \, \F \, \Sim \sim \msf{execUC} \; \Z \, \pi \, \F' \, \A \]

The security definition above guarantees compositional security as well.
Notice that the real world can also have a ``hydbrid'' functionality in it which the protocol parties can access.
The UC framework ensures that if there exists a real world protocol that \emph{realizes} a functionality according to the emulation definition, then replacing the ideal functionality with it preserves the security properties of the protocol it is used by. 
Composition makes the framework modular and allows large protocols to be specified succintly by relying on an ideal functionalities instead of complex sub-protocols.

%\paragraph{GUC-Framework}
%A limitation of the standard UC framework is that it fails to capture scenarios where multiple protocol sessions share state through some ideal functionality.
%The cannonical example used to insipire a more unconstrained environments is the signing of certificates. 
%In the real world, a protocol party $p_i$ controlling some private key may sign messages that an adverasry could replay in other protocols $p_i$ takes part in.
%The standard UC formulation, however, is incapable of modelling such an adversarial strategy as protocol sessions are completely distinct and can not share any state with each other---namely, an ideal functionality that stores signed certificates is bound only to the current protocol session.
%\todo{Is is worth motivting the GUC framework rather than just introducing what it is and that the environment can also interact with a shared functionality?}


\subsection{The Import Mechanism}
A notion of resource-bound computation is necessary for the UC framework to reason about computationally efficient algorithms as well as the capabilities of ITIs under a particular resource constraint.
Often we would like to reason about adversarial capabilities under such constraints and perform efficient transformations (transforming an real-world adversary into an ideal-world simulator).


Existing definitions of polynomial-time usually center around the lengths of input and output messages. In GNUC~\cite{gnuc} consideres a function of the sum of all inputs a machine receives as a bound on its runtime. Previous versions of the UC framework similarly rely on functions of the difference between the lengths of a machine's inputs and outputs
The latest iteration of UC overcomes some drawbacks in polytime notions around ```input lenghts''~\footnote{Namely, the \emph{infinite runs} problem identified in \cite{uc}.} and introduces the import mechanism.
The import mechanism allocates the first ITI, the environment with a number of import ``tokens'', that is poynomial in the the security parameter $k$. 
This makes up the runtime budget of the entire UC execution, and the environment can give import tokens along with inputs to other machines in the execution. Any ITM in the execution can pass import to another if it possesses enough.
The polynomial time definition in the import mechanism takes the following form:

\begin{center} {\small An ITM is considered PPT if there exists a polynomial $T$ such that its runtime is bounded by $T(n)$ where $n$ is the net amount of tokens it ever holds.} \end{center}

This notion of poynomial time directly provides a guarantee on the entire UC execution by limited the entire import in a sytem to be polynomial in $k$. Therefore, we avoid pitfalls of existing input length-based local polynomial notions.
%The UC paper defines an import mechanism where the first ITI, the environment, is spawned with a polynomial amount of import which can be thought of as tokens or coins.
%The environment can then activate other ITIs with some import tokens allowing them to run for as long as their import token balance permits. 
%In this new definition, an ITI that is $T$-bounded takes at most $T(n')$ steps where $n'$ is the difference between the import it has received from incoming messages and outgoing import it's given to other machines.
%Any ITI can write to any other ITI in it's communication set and send it import tokens until the balance of import is exhausted.
%Eventually, the system of ITMs must halt when it runs out of import until it receives more from the environment.

%\paragraph{Realizing Import in saUCy} \label{sec:realizeimport}
%\todo{Need to add potentia in Nomos here}
%The import mechanism in the UC framework describes at a high level how to reason about resource bounded computation in the import model.
%However, for our purposes it is necessary to instantiate it concretely and make explicit the conditions under which a machine halts as we care about an implementation the UC framework in our proposed Nomos language. 
%
%In order to do this we must introduce a new concept called \textit{potential}. 
%Potential is the basic unit of computation and machines must explicitly \textit{consume} their available import balance and convert it into usable potential through a bounding polynomial $T$.
%
%Concretely, every ITM $\mu$ is spawned with a set of variables:
%\begin{itemize}
%\item $\msf{in}_t$: the total amount of import received as input by $\mu$.
%\item $\msf{out}_t$: the total amount of import sent by $\mu$ to other machines.
%\item $\msf{marked}_t$: the number of import tokens that have been consumed and used to generate potential through an input polynoial $T$.
%\item $\msf{generate\_pot}(T, n)$: a function that marks $n$ available import tokens and creates $T(n)$ units of potential.
%\end{itemize}
%
%Over the lifetime of $\mu$ it will need to generate potential multiple times as it needs to perform more computation.
%Eventually, thought, we can guarantee that every machine $\mu$ will \textit{halt} when it can no longer generate more potential, i.e.  $\msf{in}_t - \msf{out}_t - \msf{marked}_t > n$.
