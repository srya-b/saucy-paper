\subsection{Universal Composability}
The Universal Composability (UC) framework~\cite{uc} is a leading framework for defining security in cryptographic protocols.
UC is based on the real/ideal paradigm, where security is defined as a relation between two systems: the real world, which features the protocol $\pi$ under analysis, as well as an arbitrary adversary \A that controls corrupt parties; and the ideal world, which mainly comprises ideal functionality \F, a trusted third party that carries out the desired task directly.
A reason ideal functionalities have become a popular alternative to traditional game-based definitions is that a security definition consists of a single program for one trusted party, rather than a collection of properties pertaining to several (potentially faulty) parties.

To summarize the ideal/real security relation, roughly we need to show ``any attack in the real world is also exhibited by the ideal functionality.'' This means constructing a simulator \Sim that plays the role of adversary in the ideal world.
What makes UC the strongest among ideal/real frameworks is that the inputs of honest parties are chosen adaptively by the distinguishing environment \Z, which can also communicate with the adversary and interleave its interactions with honest parties.
This adversary model leads to a flexible approach to composition, which we'll say more about shortly.
More formally, the security definition says that a protocol $\pi$ realizes an ideal functionality $\F$
if for every adversary $\A$, we can construct a simulator $\Sim$, such that the real and ideal world are indistinguishable for any environment \Z:
\begin{equation}
  \label{eqn:emulation}
  \forall \A \; \exists \Sim \; \forall \Z \; \; \msf{execUC} \; \Z \, \idealP \, \F \, \Sim \sim \msf{execUC} \; \Z \, \pi \, \F_0 \, \A
\end{equation}
Here $\idealP$ is the ideal protocol that simply passes inputs between environment and ideal functionality, and $\F_0$ takes the place of the ideal functionality in the real world, and is typically used to express network assumptions or assumed primitives the current protocol relies on.
The \msf{execUC} defines the UC execution experiment that hooks up the channels to the processes in its arguments.
Importantly, the number of protocol parties in UC is entirely dynamic and chosen at runtime by the environment. 
Defining \msf{execUC} in our core calculus, and especially reconciling its the dynamic nature with the static guarantees of our type system will be the central technical challenge we'll tackle later.

\paragraph{Composition Notation}
The UC framework is designed to encourage a highly compositional and modular design approach, where we analyze single-instance protocols in isolation, then apply generic composition operators to build more complex systems.
Encoding the standard theory of UC composition in our framework is one of the main ways we validate the expressiveness of our language design.
Here we summarize the main composition theorems using category notation.
First, if $\pi$ realizes $\F$ in the $\F_0$ hybrid world according to the definition above, we write:
\[
	\F_1 \xrightarrow{\pi} \F_2
\]
This means in the real world $\pi$ makes use of a single instance of $\F_1$, and the ideal world consists of a single instance of $\F_2$.
The first composition theorem states that this relation is transitive, where $\rho \circ \pi$ is a generic composition operator that combines two protocols by connecting the $\rho \Leftarrow \F$ channels in $\rho$ to the $\pi \Leftarrow \Z$ channel of $F$. That is, when protocol $\rho$ communicates with its ideal functionality, it is is relayed as subroutine input to $\pi$.
\begin{theorem}[Composition]\label{thm:singlecomp}
\begin{mathpar}
\inferrule*[right=single-compose]
{
	\F_1 \xrightarrow{\pi} \F_2 \semi \F_2 \xrightarrow{\rho} \F_3 \\
}
{
	\F_1 \xrightarrow{\rho \circ \pi} \F_3
}
\end{mathpar}
\end{theorem}
To prove this theorem requires constructing a straightforward simulator that combines the underlying simulators of $\pi$ and $\rho$, and the complete security reduction involves translating a distinguisher $Z$ for the combined protocol $\rho \circ \pi$ to a distinguisher $Z^*$ for either $\pi$ or $\rho$ individually.
Although the proof is straightforward, the precise statement of it in our framework serves as good validation for the expressiveness of our framework: our theorem, and constructed, proof are parameteric in the session type of the protocol.\anote{how can we say that it holds for an arbitrary session type t?}

The next generic operation is the multi-session extension of $\F$, denoted $!\F$, which provides $\pi$ with an arbitrary number of instances of $\F$, each tagged with a separate \textsf{sid} (for \emph{session identifier}).
Here is a central aspect of UC's flexibility, that the environment gets to determine at runtime the exact number and values of \textsf{sid}'s, with no static bound required.
The Universal Composition theorem says that composition even holds in this setting, which we state as
$!\F_1 \rightarrow \F_2$, $!\F_2 \rightarrow \F_3 \implies !\F_1 \rightarrow F_3$.
Since this proof involves reducing a distinguisher for the composition of a variable number of hybrid, the reduction involves a sequence of variable number of hybrid games, essentially the cryptographic reasoning.

\paragraph{Universal Composability and ITMs}
The UC framework is defined on top of a communication model called interactive turing machines (ITMs), in which multiple Turing-complete processes run concurrently in a system and communicate by passing messages over channels~\cite{canettiUC}.
Although the Turing-complete computations can be instantiated in any reasonable core calculus, the approach to message passing in ITMs has some essential but subtle restrictions.
In order to do cryptographic analysis, we need to make reductions to (ordinary sequential) probabilistic polynomial time computations (PPTs).
This rules out, for example, the ordinary semantics of $\pi$-calculus, which introduces unbounded non-determinism with the possible scheduler choices.

Our approach, following ILC~\cite{ilc}, is to encode the ITMs framework as faithfully as possible.
%This is because the final step in a UC proof is to show that a distinguishing environment Z can be leveraged to construct a polynomial time solution to a hard problem like Discrete Log.
The basic rule that ITMs follow is that only one process is active at a given time. 
Specifically whenever a process writes to one of its outgoing channels, the unique process that holds the read end of that channel is immediately activated next.
In this way the message scheduling is essentially deterministic so it can be easily simulated by a sequential computation.
This discipline means that modelling inherently non-deterministic phenomena, like network schedulers, requires us to explicitly offer choices to an adversary process defined in our model.

%\paragraph{GUC-Framework}
%A limitation of the standard UC framework is that it fails to capture scenarios where multiple protocol sessions share state through some ideal functionality.
%The cannonical example used to insipire a more unconstrained environments is the signing of certificates. 
%In the real world, a protocol party $p_i$ controlling some private key may sign messages that an adverasry could replay in other protocols $p_i$ takes part in.
%The standard UC formulation, however, is incapable of modelling such an adversarial strategy as protocol sessions are completely distinct and can not share any state with each other---namely, an ideal functionality that stores signed certificates is bound only to the current protocol session.
%\todo{Is is worth motivting the GUC framework rather than just introducing what it is and that the environment can also interact with a shared functionality?}

%% There have been recent work in formalizing UC. is channel based or based.
%% A short summary is this:
%% {\small
  
%% \begin{tabular}{ccccccc}
%%   & Channel/Process & Static \# of parties & Polynomial time & Formal verification & Session types \\
%%   \hline
%%   Symbolic UC \\
%%   IPDL \\
%%   ILC \\
%%   EasyUC \\
%%   Barbosa et al. \\
%% \end{tabular}
%% } 

Even having established the message pattern, it is still not straightforward to define a notion of polynomial runtime for ITM systems.
Looking at the order of quantifiers in the UC emulation definition from Relation~\ref{eqn:emulation}, we need a way to make local judgments about each $\A$, $\Z$, $\pi$, and $\F$ individual, and conclude that the entire $\msf{execUC} \Z \pi \A \F$ experiment overall is polynomial time as a result.
We follow Canetti's approach~\cite{canettiUC}, which is to keep track at runtime of quantity called ``import tokens'' and assign a runtime budget based on these.
These tokens can be passed among the processes along with the messages sent on each tape, but the total amount of tokens must be conserved (neither created nor destroyed), and locally each process cannot take more steps than (a polynomial of) the amount of import tokens it has stored.
Somewhat more formally, we say $P$ is a \emph{locally polynomial time process} if for \emph{any} evaluation context $e[\_]$, at any step $t$ during its execution,
\[
\#\textsf{stepsTaken}(e[P])_{t} \le T(n_{\textsf{in}} - n_{\textsf{out}})
\]
were $n_{\textsf{in}}$ is the total number of import tokens received by $P$ and $n_{\textsf{out}}$ is the total number of tokens $P$ has sent, and $T$ is an arbitrary polynomial.
This is sufficient because it immediately ensures that if the system starts out with a total number of tokens bounded in the security parameter $k$, then the overall number of steps taken by any of the processes in the system is also bounded in $k$.
The expressiveness comes from the arbitrary polynomial $T$, a slack parameter that allows, for example, the emulation of a universal turing machine (which potentially incurs quadratic overhead).
%\footnote{The reason for the arbitrary polynomial $T$ is to allow enough slack to support universal simulation, for example a Universal Turing Machine simmulation may add quadratic overhead.}
Our approach, described in Section~\ref{sec:basic}, is to encode this notion directly into the type system, by tracking import tokens and statically enforcing the local polynomial runtime constraint.

%Existing definitions of polynomial-time usually center around the lengths of input and output messages. In GNUC~\cite{gnuc} considers a function of the sum of all inputs a machine receives as a bound on its runtime. Previous versions of the UC framework similarly rely on functions of the difference between the lengths of a machine's inputs and outputs
%The latest iteration of UC overcomes some drawbacks in polytime notions around ```input lengths''~\footnote{Namely, the \emph{infinite runs} problem identified in \cite{uc}.} and introduces the import mechanism.

%The import mechanism allocates the first ITI, the environment with a number of import ``tokens'', that is poynomial in the the security parameter $k$. 
%This makes up the runtime budget of the entire UC execution, and the environment can give import tokens along with inputs to other machines in the execution. Any ITM in the execution can pass import to another if it possesses enough.
%The polynomial time definition in the import mechanism takes the following form:
%The UC paper defines an import mechanism where the first ITI, the environment, is spawned with a polynomial amount of import which can be thought of as tokens or coins.
%The environment can then activate other ITIs with some import tokens allowing them to run for as long as their import token balance permits. 
%In this new definition, an ITI that is $T$-bounded takes at most $T(n')$ steps where $n'$ is the difference between the import it has received from incoming messages and outgoing import it's given to other machines.
%Any ITI can write to any other ITI in it's communication set and send it import tokens until the balance of import is exhausted.
%Eventually, the system of ITMs must halt when it runs out of import until it receives more from the environment.

%\paragraph{Realizing Import in saUCy} \label{sec:realizeimport}
%\todo{Need to add potentia in Nomos here}
%The import mechanism in the UC framework describes at a high level how to reason about resource bounded computation in the import model.
%However, for our purposes it is necessary to instantiate it concretely and make explicit the conditions under which a machine halts as we care about an implementation the UC framework in our proposed Nomos language. 
%
%In order to do this we must introduce a new concept called \textit{potential}. 
%Potential is the basic unit of computation and machines must explicitly \textit{consume} their available import balance and convert it into usable potential through a bounding polynomial $T$.
%
%Concretely, every ITM $\mu$ is spawned with a set of variables:
%\begin{itemize}
%\item $\msf{in}_t$: the total amount of import received as input by $\mu$.
%\item $\msf{out}_t$: the total amount of import sent by $\mu$ to other machines.
%\item $\msf{marked}_t$: the number of import tokens that have been consumed and used to generate potential through an input polynoial $T$.
%\item $\msf{generate\_pot}(T, n)$: a function that marks $n$ available import tokens and creates $T(n)$ units of potential.
%\end{itemize}
%
%Over the lifetime of $\mu$ it will need to generate potential multiple times as it needs to perform more computation.
%Eventually, thought, we can guarantee that every machine $\mu$ will \textit{halt} when it can no longer generate more potential, i.e.  $\msf{in}_t - \msf{out}_t - \msf{marked}_t > n$.




%% \subsection{Overview of our Solution}
%% Overview of the main parts of our design.

%%     \subsubsection{Adding Session types to ITMs.}

%%     Characteristic goal of UC is the dynamic execution pattern afforded by ITMs. The environment is able to interleave interactions with honest parties in between its interactions with the adversary.
%%     Need generality, since the theory of UC is built around highly-general composition operators.
%%     Thus our design goals are most closely related to ILC, in that the goal is to preserve the expressiveness of UC.

%%     Session types are useful for expressing the control flow structure created in a program. The session type is a partial specification of a process. We start by envisioning session types as complements to the ideal functionality definition.

%%        \anote{Insert here UC Pseudocode for FCom}
%%        \anote{Insert here our session type for FCom}
    
%%     are meaningful to apply to a single channel between a pair of parties at a time.
%%     \anote{why not use global session types or alternatives?}
    
%%     Session type is centered around a judgment that says that channel $c$ carries the session type $Sess$, which is provided by process $P$.
%%     \[
%%        c_1:A_1,c_2:A_2,... \vdash P :: \{c : Sess\}
%%        \]
%%        Each channel is associated with a single process that is its provider.
%%        No cycles are allowed.

%%        Encoding the exec UC experiment to support functionalities written like this.
%%        A typical interaction in two party protocols (like Commitment, for example) allows Z to choose between two next actions.
%%        One involves activating the honest party first, in which case.

%%        Our approach is this: we'll use session types like in Nomos, and make use of the shared channels feature of Nomos  in order to avoid cycles.
%%        Furthermore, 
%%        for communication between a pair of processes. We need to make use of shared channels.


%%        One of the characteristic qualities is that the number of parties and their identities are not statically determined, instead they can be determined adaptively at runtime by the arbitrary environment.
%%        Achieves this through multiplexing between parties, called the protocol wrapper. This mechanism is also used when defining the multisession operator.
%% }
