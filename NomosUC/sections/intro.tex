In cryptography, the leading framework for defining security is Universal Composability (UC)~\cite{canettiUC}.
UC was initially developed within the cryptography theory, where it is considered the strongest definitional model since it guarantees a protocol even when multiple sessions of the protocol are run concurrently. UC has now become popular in secure protocols more broadly, where an ideal functionality model often serves as the main formal security definition.
One reason for UC's property versus traditional game-based cryptography definitions is that UC is based on the \emph{ideal functionality} paradigm, which can lead to more cohesive definitions. In short, rather than giving the security properties through a collection of separate attack games, in UC we define security through a single program for a trusted third party that exhibits all the desired behaviors of the protocol.
UC also encourages a modular style  to a modular framework, where larger protocols can be designed using simple ideal functionalities, and UC guarantees protocols that realize them to be secure when composed with arbitrarily other protocols running concurrently.

Protocols based on UC, support for programming tool support is further behind. Providing programming language support for this framework has been a focus of recent works like ILC, EasyUC, IPDL, and others~\cite{ilc, easyuc, ipdl, sybolicuc, barbosa}. Our work goes further in this direction by asking several new questions:

\begin{enumerate}
\item 
As UC is used for increasingly complex protocols and applications, even the ideal functionalities become difficult to read and understand.
Can we use Session Types as a way of providing more structure and assisting in the analysis of the ideal world models?
Session types have been successfully employed in modeling distributed protocols~\cite{nomos}\anote{other best session types papers?}, however it is not obvious what help they provide within an adversarial model as strong as UC.
Additionally UC is very dynamic, supporting a variable number of protocol parties determined by the environment at runtime, while session types provide static guarantees for a session involving only two parties at a time.
Is it possible to reconcile these, getting some value from session types without restricting the  of UC?

\item Execution cost analysis plays a central role in UC, since we are only concerned with
attackers possessing polynomial-time computational power.
However, most prior UC formalization efforts like EasyUC and ILC forego the polynomial runtime analysis entirely, while others like IPDL and \snote{Barbosa?} achieve can enforce polynomial runtime but at the expense of restricting the UC framework to a static number of protocols.
Can we enforce polynomial running time without otherwise imposing restrictions on the UC framework?

\end{enumerate}

We answer these questions positively by designing a new language, NomosUC, that combines ideas from
Nomos~\cite{dasnomos}, a resource aware session-typed language, and ILC~\cite{ilc},
a process calculus previously used for encoding the UC.
We adapt potential in Nomos into import and polynomial constraints, and introduce a notion of vitual tokens to support 
sandboxing, a critical tool for creating reductions in UC.
%For instance, for the two-party bit commitment protocol~\cite{rocommitment}, session types guarantee
%the interface and resource requirements that the protocol offers to the environment in the ideal world, and the specific protocol 
%message and import exchange between the two parties in the real world.

We show how to resolve the static nature of session types in Nomos with the dynamic nature of UC in some clever ways. 
ITMs in UC are flexible enough to allow for arbitrary communication between any two machines or an arbitrary configuration of machines.
However, the static nature of session types poses new challenges for expressing arbitrary behavior.
In NomosUC, we abstract the notion of a channel between two processes, into a generic construction, not limited by the constraint
of linear types, that, as far as we know, can express any configuration of ITMs.
Furthermore, we contend with the static nature of the type system in several places, namely Section~\ref{sec:execuc}, when designing ideal functionalities and adversaries,
and arrive at a notion of compositional security that remains surprisingly expressive and generalizable.
Finally, we provide a systematic approach to converting any UC functionality into one that can be implemented in NomosUC.
\snote{(attempt) finished explanation of the technical challenges in making session types while still supporting the dynamic nature of UC.}

A core novelty of NomosUC is its support for ensuring \emph{resource bounded computation}.
As is common in cryptography, security of a protocol is expressed via universal quantification
on feasible computation and thus, crucially relies on the exact formulation of computational cost.
In UC, computational cost is formally expressed through a mechanism of \emph{import tokens}, where runtime is related to tokens which can be passed around between processes.
The \emph{run-time budget} $n$ of a process is then defined as the sum of import tokens received by a process \emph{minus} the sum of import of messages sent out by it.
We find that the import tokens from UC are closely related to the \emph{potential} mechanism from Nomos.
The main technical challenge is the need for running ITMs in sandbox, a critical tool for reductions of adversaries, and environments, to computationally hard problems.
Reusing existing NomosUC programs requires satisfying the import requirements their types require.
We introduce \emph{virtual tokens} that are created by the host and given to virtualized processes as ``real'' tokens. 
We create typing rules around our sandboxing approach in Section~\ref{sec:importlang} to ensure it doesn't introduce non-polynomial behavior.
\snote{(attempt) explained why sandboxing requires us to introduce virtual tokens}.
Furthermore, since import is ultimately connected to the security parameter, NomosUC
therefore, not only guarantees termination, but also asserts polynomial bounds on
the execution cost in terms of the security parameter.
A main contribution of our work, the soundness of our approach, is achieved by proving a \emph{preservation theorem}
which states that well-typed processes in NomosUC are ``locally polynomial time"
in the sense required by UC.

We validate our approach to UC both through realizing traditional UC theorems and through examples which showcase our emulation definition and composition operators.
By applying it to coin flip functionality \Fflip in Section~\ref{sec:commitment}.

\anote{Explain more of the validation we accomplish by completing the standard composition operators in UC.}
\anote{Explain more of the highlights from our \Fflip case study.}
