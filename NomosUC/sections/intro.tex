We want better tools for analyzing cryptographic applications, especially complex ones like smart contracts which make use of varied cryptographic tools (like zero knowledge proofs and multiparty computation) and have modular, layered constructions.
In cryptography, the leading framework for managing such compositions is Universal Composability (UC)~\cite{uc}.
The central idea of the frameowkr is in the ideal functionality: a security spec of a protocol given by a concrete instance of a simple program that, if run by a trusted third-party, would exhibit all of the desired behaviors of the protocol.
This leads to a modular framework, where larger protocols can be designed using simple ideal functionalitieis, and UC guarantees protocols that realize them to be secure when composed with arbitrarily other protocols running concurrently.
Providing programming language support for this framework has been a focus of recent works like ILC, EasyUC, IPDL, and others. However, these have several shortcomings, which we address through the following questions:

\begin{enumerate}
\item Increasinglt complex cryptographic applications often involve several parties communicating according to a pre-defined protocol, and implementations of them can deviate from their intended behavior.
However, existing tools often do not provide a streamlined approach of expressing and enforcing
such protocols.
For such protocols, can the programming language provide alert its user to such deviations in their code?

%\item RQ1: Cryptographic applications often involve several different parties communicating
%with each other in a pre-defined protocol.
%However, existing tools often do not provide a streamlined approach of expressing and enforcing
%such protocols.
%As cryptographic protocols become more and more complex, it is likely that the implementation
%of such applications deviates from its intended behavior.
%In such scenarios, can the programming language provide some feedback to its user that such
%a deviation has occurred?
\item Execution cost analysis plays a central role in UC, since we are only concerned with
attackers possessing polynomial-time computational power.
However, existing tools provide almost no support in enforcing such restrictions on adversaries, and,
as protocol complexity increases it is increasingly important to ensure polynomial-time bounds on the
rest of the UC components: protocols, simulators, functionalities, and environments.
Can we introduce resource-awareness into programming languages such that these restrictions
are automatically enforced?

%\item Execution cost analysis plays a central role in UC, since we are only concerned with
%attackers possessing polynomial-time computational power.
%However, existing tools provide almost no support in enforcing such restrictions on adversaries.
%In addition, UC configurations contain several different components: simulator, environment,
%adversary, ideal functionality, and honest and corrupt parties.
%Thus, it is important to ensure that polynomial-time bounds are enforced on the correct
%components, which again can become challenging as the complexity of the cryptographic protocol
%increases.
%Can we introduce resource-awareness into programming languages such that these restrictions
%are automatically enforced?
\end{enumerate}

We answer these questions by designing a new language, NomosUC, that combines ideas from
Nomos~\cite{dasnomos}, a resource aware session-typed language, and ILC~\cite{ilc},
a process calculus for UC.
Session types in Nomos allow us to express communication protocols in both the ideal and
real world implementations of cryptographic applications.
For instance, for the two-party bit commitment protocol~\cite{rocommitment}, session types guarantee
the interface and resource requirements that the protocol offers to the environment in the ideal world, and the specific protocol 
message and import exchange between the two parties in the real world.
The polynomial time guarantee in NomosUC is defined by the resource requirements specified by the import in the ideal and real world
session types.
They ensure composed protocols can provide enough computational resources to capture party communication and adverasrial capabilities in the real and ideal worlds to the sub-protocols they rely on.
THe Nomos type checker then statically enforces both of these requirements are adhered to at runtime, and  
failure to typecheck provides precise feedback to the programmer on exactly where the
implementation departs from its intended protocol.

A core novelty of NomosUC is its support for ensuring \emph{resource bounded computation}.
As is common in cryptography, security of a protocol is expressed via universal quantification
on feasible computation and thus, crucially relies on the exact formulation of computational cost.
In UC, computational cost is controlled using an \emph{import mechanism}.
Every message exchanged between individual processes contains an import field represented by
a natural number.
The \emph{run-time budget} $n$ of a process is then defined as the sum of import of messages
received by a process \emph{minus} the sum of import of messages sent by it.
Each process is constrained in a way that its total number of execution steps is bounded
by $T(n)$ where $T$ is a \emph{reasonable} polynomial.

This import mechanism is closely connected to the \emph{potential mechanism} in Nomos, and
generally speaking, resource-aware session types.
Nomos features special messages that contain \emph{potential} (again represented as a natural
number) that can be exchanged among processes involved in a computation.
And processes consume this potential to make an execution step, thereby guaranteeing that
the total potential of a process bounds the total computational cost.

NomosUC unifies these two mechanisms resulting in a deep connection between session type
semantics and the formal foundation of UC.
We achieve this unification in 2 novel steps: first we provide a construct to exchange import along
with messages among UC processes.
In addition, we provide another construct for using import to generate potential which
is then used to bound the total number of execution steps.
The latter construct guarantees that if the total import of a process is $n$, then we
can never generate more than $T(n)$ potential units
This ensures that the total computational cost of each process is bounded by a polynomial
in the import stored by it.
Furthermore, since import is ultimately connected to the security parameter, NomosUC
therefore, not only guarantees termination, but also asserts polynomial bounds on
the execution cost in terms of the security parameter.
The soundness of our approach is achieved by proving a \emph{preservation theorem}
which states that well-typed processes in NomosUC are ``locally polynomial time"
in the sense required by UC.
%=======
%
%   The challenge of “polynomial runtime” in UC is that individual processes must be judged as polynomial, but when eveluated in context with other concurrently running process it is difficult to assign blame.
%       The current best way to define polynomial runtime, found in the 2019 and later version of UC, is based a concept of ``import tokens.''
%       This turns out to be a good fit for the ``Potential'' from Nomos and Resource-Aware ML.
%Our construction can reason about local polynomial time for open terms based only on the channel types and assert polynomial-bound in the security parameter by checking valid polynomial and import bounds, and it even guarnatees termination.
%The result is a deep connection between session type semantics and the formal foundation of UC.
%    The Preservation theorem we prove associated with our type system and operational semantics proves the following: 
%  well-typed terms in Nomos UC are “locally polynomial time”, in the sense required of UC, meaning they do not take more steps that some polynomial function $T(N)$ of the net number of import tokens it has received.
%  \anote{Explain better connection between Preservation theorem and what is needed in UC proofs}
%>>>>>>> f83e42c (abstract and intro drafted)

%In this work we attempt to improve on the state of the art by applying \textit{resource-aware session types} to realize the UC framework that we call Nomos UC.



%\hrule 
% Second, Nomos features a notion of Work-aware types. This is useful for capturing the notion of “locally polynomial runtime.” This allows us to model UC more faithfully than any prior work to date
%As a starting point, we build a language that merges types rules from ILC into Nomos. The main design idea of ILC is that it is uses static typing rules to encode the requirements of the Interacting Turing Machines (ITMs) model, a model that is uniquely associated with UC. The ILC rules roughly ensure that simulations of the language can be carried out by probabilistic Turing machines, which is necessary for reduction to computationally hard problems, required for cryptographic security proofs. The rules from ILC are compatible with session types, so it turns out to be straightforward to merge these into nomos. The result provides benefits associated with session types, namely that it avoids potential errors from internally-inconsistent programs.
%   Beyond just session types, the Work-aware component of Nomos allows us to tackle a fundamental challenge in defining a programming language for UC that ILC (and all other related work) left unfulfilled, which is to express the notion of polynomially runtime.
   

%In addition, our language has other benefits.
% The Progress theorem is useful because it gives some evidence that ideal functionalities and protocols encoded in Nomos UC cannot get stuck. Together helps confirm that the process halts in polynomial time.
% TODO: Give an example of a bad machine ruled out by progress guarantee.

%% \ignore{
%% Carries forward the same metatheory guarantees as ILC. Namely: if a process terminates, then it depends only on the random coins (unlike Pi calculus, including Session-type pi calculus). Thus simulating the execution of a Nomos UC experiment can be carried out by a probabilistic polynomial time Turing machine (PPT). This is essential in UC for reduction to computationally hard problems.
%% }

%% \ignore{
%% The Universal Composability Framework~\cite{uc} is the popular and widely-used framework for modelling the security of cryptographic and distributed protocols.
%% Its novel contribution compared to other frameworks is that it provides a very strong notion of security: a UC-secure protocol is proved to be secure even when composed with arbitrary other protocols running concurrently.
%% This constrasts with other, property-based notions of security~\todo{need to get some citations here}.

%Analyzing large and complex protocols is a difficult task made easier by UC's ideal functionality abstraction. 
%However, despite this additional modularity, UC proofs and models still tend to be very complex, unwieldy, and difficult to understand.
%These issues are exacerbated when new communication models are added on top of UC~\cite{katz, etc}.
%Therefore, we propose a two-fold solution: a new construction for modelling different communication models that removes all model-specific code from protocols and functionalities, and an implementation of the UC framework in the Nomos language. 
%}

