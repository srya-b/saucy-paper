(* Coin flip *)
stype flipper = +{ f_flip: flipped } ;
stype f_flipped = +{ getflip: &{res: Bit * 1}}} ;

stype freceiver = +{ getflip: r_getflip} ;
stype r_getflip = &{ noflip: freceiver,
			 						   res: Bit * 1} ;

proc prot_flip_flipper[K]:
  (k: Int), (rng: [Bit]), (sid: session[1]),
  (pid: Int), ($z2p: flipper) |- ($p2f: sender) =
{
  case $z2p (
    flip =>
      b = sample 1 rng ;
      $p2f.commit ;
      send $p2f b ;
      case $p2f (
        randomness =>
          r = recv $p2f ;
          $p2f.open ;
          flip = r xor b ;
          case $z2p (
            getflip =>
              $z2p.res ;
              send $z2p flip ;
          )
      )
  )
} 

proc prot_flip_receiver[K] :
  (k: Int), (rng: [Bit]), (sid: session[1]), 
  (pid: Int), ($z2p: freceiver) |- ($p2f: receiver) =
{
  choice $p2f $z2p
  | case $p2f (
      commit =>
        r = sample 1 rng ;
        $p2f.randomness ;
        send $p2f r ;
        $p2f <- prot_flip_receiver_2[K] <- k rng sid pid $z2p 
    )
  | case $z2p (
      getflip =>
        $z2p.noflip ;
        $p2f <- prot_flip_recever[K] <- k rng sid pid $z2p 
    )
}
        
proc prot_flip_receiver_2[K]:
  (k: Int), (rng: [Bit]), (sid: session[1]),
  (pid: Int), ($z2p: freceiver), |- ($p2f: rcommitted) =
{
  choice $p2f $z2p 
  | case $p2f (
      open =>
        b = recv $p2f ;
        flip = b xor r ;
        case $z2p (
          getflip =>
            $z2p.res ;
            send $z2p flip ;
        )
    )
  | case $z2p (
      getflip =>
        $z2p.noflip ;
        $p2f <- prot_flip_receiver_2[K] <- k rng sid pid $z2p 
    )
}

