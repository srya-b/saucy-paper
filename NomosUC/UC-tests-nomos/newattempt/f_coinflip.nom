stype flipper = +{ f_flip: flipped } ;
stype flipped = +{ getflip: &{res: Bit * 1}}} ;

stype freceiver = +{ receive: getflip} ;
stype r_getflip = &{ noflip: getflip,
									res: Bit * 1} ;


stype adversary = &{ flip: 1 } ;

proc F_coinflip[K] :
	(k: Int), (rng: [Bit]), (sid: session[1]),
	($F: flipper), ($R: freceiver), ($A: adversary) |- ($ch: 1) =
{
	choice $F $R
	| case $F (
			f_flip =>
				b = sample 1 rng ;
				$A.flip ;
				$ch <- F_coinflip[K] <- k rng sid $F $R $A b
		)
	| case $R (
			receive =>
				$R.noflip ;
				$ch <- F_coinflip[K] <- k rng sid $F $R $A 
		)			
}

proc F_coinflip[K]:
	(k: Int), (rng: [Bit]), (sid: session[1]),
	($F: flipped), ($R: freceiver), ($A: 1), (b: Bit) |- ($ch: 1) =
{
	choice $F $R
	| case $F (
		getflip =>
			$F.res ;
			send $F b ;
			$ch <- F_coinflip_receiver[K] <- k rng $R b	
		)
	| case $R (
			getflip =>
				$R.res ;
				send $R b ;
				$ch <- F_coinflip_flipper[K] <- k rng $F b 
		)
}

proc F_coinflip_flipper[K] :
	(k: Int), (rng: [Bit]), (sid: session[1]),
	($F: f_flipped) (b: Int) |- ($ch: 1) =
{	
	case $F( getflip => $F.res ; send $F b )
}

proc F_coinflip_receiver[K]:
	(k: Int), (rng: [Bit]), (sid: session[1]),
	($R: freceiver), (b: Bit) |- ($ch: 1) =
{
	case $R ( getflip => $R.res; send $R b; )
}
