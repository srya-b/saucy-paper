proc up_to_i[K][K1][K2] :
	(k: Int), (rng: [Bit]), (sid: session[a]), (crupt: list[pid]),
	(#z_to_hybrid: comm[z2pmsg[p2f]][K]), (#hybrid_to_z: comm[p2zmsg[f2p]][K]),


proc env[K][K1][z2p, p2z] :
	(k: Int), (rng: [Bit]), (#z_to_pw : comm[z2pmsg[z2p]][K]), (#pw_to_z: comm[p2zmsg[p2z]][K]),
	(#z_to_a: comm[z2amsg[z2a]][K]), (#z_to_a: comm[a2zmsf[a2z]][K])  |- ($ch: EtoZ[a]) =
{
	crupt <- pnil[pid] <- ;
	sid = SID( 'test ') ;
	#ch.init ;
	send #ch sid ;
	send #ch crupt ;
	
	case #ch (
		init => $z <- env_real[K][K1][K2][z2p, p2z] <- k rng sid #z_to_pw #pw_to_z #z_to_a #a_to_z 
	)			
}

proc env_create_worlds[K,K1,K2][z2p, p2z] :
	...
{
	$l_z2ps <- pnil[Int,comm[z2pmsf[p2f]][K1]] <- ;
	$l_p2zs <- pnil[Int,comm[p2zmsg[f2p]][K1]] <- ;

	(* spawn internally running environment *)
	#z_z2p <- communicator_init[z2p] <- ;
	#z_p2z <- communicator_init[p2z] <- ;
	#z_a2z <- communicator_init[fh2p] <- ;
	#z_z2a <- communicator_init[p2fh] <- ;
	
	$z' <- PS.env <- ... #z_z2p #z_p2z ....
	(* do this from execUC but change the channel names 
		$z.start ;
		(*$d <- $z *)
		case $z (
			output =>
				b = recv $z ;
				$d.output ; send $d b ;
			reset =>
				#z <- release $z ;
		)
	*)

	(* TODO turns out we want to buffer output from the itnernal Z because if we attempt to
		block and wait for it, we can't do anythig ese *)

	$z <- env_multiplex[K][K1][K2] <- #z_z2p #z_p2z #z_a2z #z_z2a $l_z2ps $l_p2zs  ;
}

proc env_multiplex[K][K1][K2] :
	(k: Int), (rng: [Bit]), (#z_to_pw : comm[z2pmsg[z2p]][K]), (#pw_to_z: comm[p2zmsg[p2z]][K]),
	(#z_to_a: comm[z2amsg[z2a]][K]), (#z_to_a: comm[a2zmsf[a2z]][K]),
	(#z_z2a: comm[...][K1]), (#z_a2z: comm[...][K1]) 
	(#z_p2z: comm[...][K1]), (#z_z2p: comm[...][K1]),
	($l_p2zs: list[comm[...]][K1]), ($_z2ps: list[comm[...]][K1]) |- ($ch: 1) =
{
	case #z_p2z (
		yes =>
			Z2P(pid, P2MS(ssid, msg)) = recv #z_z2p ;
			get #z_p2z {p2zn : K1} ;
			
			if j == i && not ssid in $l_p2zs 
			then 
				ithssid = ssid ;
				j += 1 ;
			else if j < i-1 && ssid not in $l_p2zs  
			then
				(* communicators for execUC with dummy parties *)
				#ideal_z2pw <- communicator_init[z2pmsg[z2p]][K1] <- ;
				#ideal_pw2z <- communicator_init[p2zmsg[p2z]][K1] <- ;

				$l_z2ps' <- pappend $l_z2ps (j, #ideal_z2pw) ;
				$l_p2zs' <- pappand $l_p2zs (j, #ideal_pw2z) ;
	
				#ideal_z2a <- communicator_init[z2amsg[z2a]][K1] <- ;
				#ideal_a2z <- communicator_init[a2zmsg[a2z]][K1] <- ;
	
				#ideal_pw2f <- communicator_init[p2fmsg[p2f]][K1] <- ;
				#ideal_f2pw <- communicator_init[f2pmsg[f2p]][K1] <- ;

				#ideal_pw2a <- communicator_init[p2amsg[p2a]][K1] <- ;
				#ideal_a2pw <- communicator_init[a2pmsg[a2p]][K1] <- ;
	
				#ideal_a2f <- communicator_init[p2amsg[a2f]][K1] <- ;
				#ideal_f2a <- communicator_init[f2amsg[f2a]][K1] <- ;

				$pw <- partywrapper[K1][K2][p2ms][ms2p][p2ms][ms2p] <- 
								k rng ssid clist #ideal_z2pw #ideal_pw2z #ideal_pw2f #ideal_f2pw #ideal_pw2a #ideal_a2pw ;
	
				$f <- fideal_wrapper[K1][K2][p2f][f2p][a2f][f2a] <- 
								k rng ssid clist #ideal_pw2f #ideal_f2pw #ideal_a2f #ideal_f2a ;
	
				$a <- sim_ideal[K1][K2] <- k rng ssid clist #ideal_a2z #ideal_z2a #ideal_pw2a #ideal_a2pw #ideal_a2p #ideal_f2a ;
				j += 1 ;
			else if j > i && ssid not in $l_p2zs
			then
		    (* communicators for execUC with dummy parties *)
		    #real_z2pw <- communicator_init[z2pmsg[z2p]][K1] <- ;
		    #real_pw2z <- communicator_init[p2zmsg[p2z]][K1] <- ;

		    $l_z2ps' <- pappend $l_z2ps (j, #real_z2pw) ;
		    $l_p2zs' <- pappand $l_p2zs (j, #real_pw2z) ;
	
		    #real_z2a <- communicator_init[z2amsg[z2a]][K1] <- ;
		    #real_a2z <- communicator_init[a2zmsg[a2z]][K1] <- ;
	
		    #real_pw2f <- communicator_init[p2fmsg[p2f]][K1] <- ;
		    #real_f2pw <- communicator_init[f2pmsg[f2p]][K1] <- ;

		    #real_pw2a <- communicator_init[p2amsg[p2a]][K1] <- ;
		    #real_a2pw <- communicator_init[a2pmsg[a2p]][K1] <- ;
	
		    #real_a2f <- communicator_init[p2amsg[a2f]][K1] <- ;
		    #real_f2a <- communicator_init[f2amsg[f2a]][K1] <- ;

		    $pw <- partywrapper[K1][K2][p2ms][ms2p][p2ms][ms2p] <- 
		    				k rng sid clist #real_z2pw #real_pw2z #real_pw2f #real_f2pw #real_pw2a #real_a2pw ;
	
		    $f <- fhybrid_wrapper[K1][K2][p2fh][fh2p][a2fh][fh2a] <- 
		    				k rng sid clist #real_pw2f #real_f2pw #real_a2f #real_f2a ;
	
		    $a <- dummy_adv[K1][K2] <- k rng sid clist #real_a2z #real_z2a #real_pw2a #real_a2pw #real_a2p #real_f2a ;

		    j += 1 ;
			end

			if ssid == ithssid 
			then
				(* simply forward to the outside *)
				#z2pw.SEND ;
				pay #z2pw {z2pn : K}
				send #z2pw Z2P(pid, P2MS(ssid, msg)) ;
			else
				#z_z2p <- get_channel ssid ;
				#z_z2p.SEND ;
				pay #z_z2p {z2pn : K1}	
				send #z_z2p Z2P(pid, P2MS(ssid, msg)) ;
			end
		
	$ch <- env_p2z_i[K][K1][K2] <- ... #z_z2p #z_p2z #z_z2a #z_a2z $l_z2ps' $l_p2zs' 0 ; 
}

proc env_p2z_i[K][K1][K2]:
	(k: Int), (rng: [Bit]), (#z_to_pw : comm[z2pmsg[z2p]][K]), (#pw_to_z: comm[p2zmsg[p2z]][K]),
	(#z_to_a: comm[z2amsg[z2a]][K]), (#z_to_a: comm[a2zmsf[a2z]][K]),
	(#z_z2a: comm[...][K1]), (#z_a2z: comm[...][K1]) 
	(#z_p2z: comm[...][K1]), (#z_z2p: comm[...][K1]),
	($l_p2zs: list[comm[...]][K1]), ($_z2ps: list[comm[...]][K1]),
	(i: Int)  |- ($ch: 1) =
{
	if i < $l_p2zs.length
	then
		#_z_p2z <- get_channel[i] ;
		#_z_p2z.RECV ;
		case #_z_p2z (
			yes => 
				msg = recv #_z_p2z ;
				get #_z_p2z {p2zn : K1} ;
				#z_p2z.SEND ;
				pay #z_p2z {p2zn : K1} ;
				send #z_p2z msg ;
			no =>
		)
		$ch <- env_p2z_i[K][K1][K2] <- ... #z_z2p #z_p2z #z_z2a #z_a2z $l_z2ps' $l_p2zs' 1 ;
	else
		$ch <- env_real_p2z[K][K1][K2] <- ... #z_z2p #z_p2z #z_z2a #z_a2z $l_z2ps' $l_p2zs' 1 ;
}

(* TODO rest of the environment code for handling real p2z and p2a messages *)
