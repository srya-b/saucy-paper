Coin flipping is an integral part of many distributed byzantine protocols, and there are a wide array of different coin flip models with subtle differences. 
Analyzing and testing layered composition of distributed protocols on top of existing coin flip protocols, represented by ideal functionalities is a priority for a development framework for UC.
Flipping coins between mutually distrustful parties, though a simple enough functionality, captures the range of properties that UC is uniquely suitable for expressing and reasoning about. 
Relying solely on analytical security proofs, or proofs by hand, is has been shown in the past to \todo{how to tie this into it?}


For many distributed protocols, even simple examples like 2-party computation, desired properties can often be deeply interconncted such that specifying them as a list of satisfiable assertion is difficult. 
In the simplest case of two parties computing a function, notions of correctness and secrecy are connected, for example, to the choice of function being computed, what an adversary can learn about the other party's inputs before choosing its own, or what distributions do the adversary's input or the protocol's output exhibit. 
In more complex protocols we desired the analysis of properties that define notions of fairness or input availability.
Specifying these properties in a laundry list of properties can be cumbersome and error-prone, and the ideal functionality model allows expressing arbitrary properties as a computational unit.
Rather than proving specific assertions hold, UC defines security in relation to an idealized version that exhibits the desired properties implicitly.
A coin flipping protocols, references throughout this work, is a core subcomponent of many asynchronous distributed protocols, and is a useful case study for examing our implementation.

\subsection{Flipping Protocols and Fairness}
Flipping between two parties is the simplest case, where protocols like Blum's coin toss over the telephone protocol ensures unbiased coin but only when the adversary does not prematurely abort the protocol.
They are used heavily even in modern agreement protocols that operate under the strong common coin assumption: in some round all parties observe the same coin flip. 
This relatively straightforward example protocol exhibits many properties that, traditionally, UC is adept at modelling and analyzing like fairness, input availability, and adversarial influence on outcomes.
In this section we use this example to demonstrate that our implementation can express such a protocol, allow for analysis of properties like fairness and input availabiltiy, and detect failrue accross composition. \todo{this last sentence needs some work, maybe mention that we compose with the lottery here?}.

\paragraph{The Ideal Coin Flip}
In Figure~\ref{fig:fflip} we show the ideal functionality for a coin flip. 
The coin flip specifies that both parties but initiate the flip, and that the adversary can have no influence on the bias of the output bit.
Unlike the eventual delivery guarantees we discuss for async protocol, the functionality allows the adversary to decide which of the two parties, if any, receive the result.
This means that $\F_\m{flip}$ allows protocols that are \emph{not fair}: they do no guarantee that if one party receives output all parties eventually receive the output. 
\begin{figure}
\centering
\input{figures/f_flip}
\caption{Ideal coin flip without fairness.}
\label{fig:fflip}
\end{figure}
\todo{It is a known result that no coin flip protocol with n/2 corruptions is unbiased, what do say about that?}

\paragraph{A Lottery from Coin Tossing}
A lottery between $n$ participants is an example of a distributed protocol increasingly common in blockchain systems where financial incentives are involved.
Unlike agreement protocols where only safety is required, lotteries are less tolerant of protocol that aren't fair or protocols where the adverasary can excert significant influence on the outcome. 
The financial incentives involved in the protocol require development frameworks that can express and analyze these properties.
Importantly, modular design by relying on software packages is necessary, and UC allows the abstraction to be represented by ideal functionalities.
In the same way that theoretical definitionsr rely on ideal functionalities for assumptions such as authenticated communication, implementation with ideal functionalities is an important feature.
Simply allowing design in this way isn't meaningful without the ability to analyze protocols across composition and the replacement of ideal functionalities with protocols that attempt to realize them.
So far we can apply analysis techniques to prove emulation, but doing so across composition remains to be validated.

The first and primary property that we desire from the lottery is that the adverasry can not bias the output of the lottery.
If ther eare $n$ participants then party $p_i$ is chosen with probability $\frac{1}{n}$.
Furthermore, we define the standard $\frac{n}{3}$ fault model 
\todo{iron out the right lottery protocol}

UC tells us that we can compose and arbitrary number of instances of \Fflip in order to realize a lottery.
At a high level, our protocol \prot{lotto}, flips $\log n$ pair-wise coins in order to choose one of $n$ parties as the winner. 
\todo{should the lottery property only be that the prob of win is 1/(|honest| + 1)? because we don't care which adverasry wins?}

\begin{figure}
\centering
\input{figures/f_lottery}
\caption{The lottery ideal functionality.}
\label{fig:flotto}
\end{figure}


\subsection{Common Coins}
Many agreement protocols rely on common coins to introduce shared randomness into protocol to allow protocol parties to make common decisions without adversarial influence.
The strongest assumtpion is a perfect common coin: 
