In this section, we analyze the simple yet subtle coin flipping primitive
within our framework.  Coin flipping is used throughout cryptographic and
distributed protocols, and we present variants of a commitment-based protocol
that attempts to realize the ideal coin functionality $F_\m{coin}$.  Many coin
flips are then composed together to implement a lottery protocol.  Unlike the
distributed protocols most people are familiar with, flipping a coin between
two parties or taking part in a distributed lottery require additional
properties of fairness and some limitation on adversarial influence in biasing
the output.  Our implementation and analysis of these two protocols (and their
composition) in this section highlight's our framework's ability to reason
about these properties in a way that most prior work can not do.  \todo{add
citations}.  Testing for bugs manifesting as distinguishing environment in a
composed protocol demonstrates that useful parts of the UC framework remain
useful for protocol analysis in an implementation setting.  Zooming out,
studying composed protocols is important as the vision of UC as a development
framework relies on the ability of developers to find bugs in and analyze
protocols that replace ideal functionalities with software packages implemented
by others.  As protocols become more complex, programmer code will rely more
heavily on existing software and will therefore rely more on their ability to
safely replace ideal functionalities in settings perhaps not imagined by their
authors.  We begin by defining the ideal 2-party coin flip, $\F_\m{coin}$, and
create a lottery out of multiple instances of it.

Implementing a coin flipping protocol is more difficult than it seems, and the
subtle ways the protocol can fail serve as a good exampple to study.  The
example highlights the need for a framework for distributed applications that
can use a generalized testing strategy and approach to test even these
protocols.  We present the analysis by first implementing $\F_\m{coin}$ in the
most natural way, and show how its failures are easily discovered by our
fuzzing method.  Then we iteratively build upon the simple protocol trying to
patch each new failure, again in the most natural and obvious way.  Doing so we
make the point that the UC framework is necessary especially in such cases
where bugs are non-intuitive and consist of failures in adversarial influence
or fairness.  Finally, at the end of the section we discuss checking such
properties in the context of more complex, higher-level protocols like the ABA
protocol described earlier.

\subsection{Lotteries from Coin Flips}
The ideal 2-party coin flip in Figure~\ref{fig:fcoin} requires both parties to
initiate the toss, and eventually outputs the result of the coin flip to both
parties.  The latter step captures a ``fairness'' property, because our
asynchronous implementation guarantees delivery to both parties or neither of
them.  The ideal functionality also gives the adversary no additional
information about the honest party's input that it can use to bias the outcome
with its own choice of input

\begin{figure}
\centering
\input{figures/f_flip_fair}
\caption{A fair coin clip where the result is asynchronously delivered to each party.}
\label{fig:fcoin}
\end{figure}

%\begin{enumerate}[label=\protect\ecircled{\arabic*}]
%\item ada
%\item asdasdasd
%\end{enumerate}

\paragraph{A Lottery from Coin Tossing}
A fair lottery is a protocol betweeen $n$ parties that ensures that the
probability of any user winning is $\frac{1}{n}$ and that a winner is
eventually decided.  Unlike most agreement or broadcast protocols, lotteries
are special in that the output must follow strict distribution in even in
the face of byzantine parties, because the financial incentives involved
motivate parties to bias the output in their favor.  We construct a lottery
protocol that uses the multisession extension of the two-party flip, written
$!\Fcoin$, to run multiple coin flips until a single winner remains. 

We take some liberties in the definition of the lottery, for simplicity, by
using the environment to inform other parties of the results of others' flips
rather than add layers that require parties to each broadcast results to each other.
The ddditional communication complexity that broadcasting would add wouldn't a hurdle to checking distributed
systems using fuzzing, as we make evident in our case studies, but creating and debugging
an additional protocol isn't useful to the point we're making.
The ideal functionality $\F_\m{lotto}$ in Figure~\ref{fig:flotto} specifies
that the environment gives input to every party in every round eliminating half
of the participants.  This continues until a final winner is chosen, at which
point $\F_\m{lotto}$ output. Note that fairness doesn't mean much in this sense
as only the winner ever outputs anything.
\todo{the corruption threshold}

\begin{figure}
\centering
\input{figures/f_lottery}
\caption{The lottery ideal functionality.}
\label{fig:flotto}
\end{figure}

In the real world protocol, all the parties are activated with the
configuration of the current round, and they each initiate and complete their
pair-wise flips through unique instances of \Fcoin.  The parties then wait for
another input from \Z about the next round, and so on until the final flip is
completed and the winner is known.  The winning party outputs to \Z that it is
the winner.

We define a simulator for the protocol $\pi_\m{lotto}$ to realize
$\F_\m{lotto}$ in the natural way since this is a full information protocol.
Then we run the following real-ideal experiment $!\Fcoin
\xrightarrow{\pi_\m{lotto}} \F_\m{lotto}$ through our fuzzer and fix
implementation bugs until we are assured that the lottery was correctly
implemented.

\subsection{Composing With a Real Coin Flip}
It is important to underscore that even simple real-world protocols like coin
flips are subtle, small design choices can cause them to fail, and a framework
capable of discovering failures in such protocols is a necessity.  We start
with the simplest coin flip protocol, check it, and iterate on its design
patching bugs and failures that we discover.
% TODO: point out in the intro that the lottery is a small and contrived example, and the examples with variations of the shared coin in ABA are more representative and worthwhile analyses
% TODO: but highlight that even this is something other works can't reason about or automatically check
The possible failures in question, like the non-uniform distribution of the
output of a coin flip with abort, aren't immediately clear, and possibly
non-intuitive, therefore generating test cases automatically and detecting such
failures by only looking at the real-ideal relationship is a big advantage of
developing with UC. Generating a specific distribution intuitively requires
observing the output of the protocol across many runs and many different
possible inputs and adversaries.

The base coin flip protocol we used relies on the ideal bit commitments:
\begin{enumerate}
    \item The first party to activate, the \emph{flipper} $S$, commits to some bit
        $b$ with a blinding factor $r$ and sends it to $R$.  
    \item $R$ receives the commitment, flips a random $b'$, and sends it to
        $S$.
    \item $S$ waits for $b'$ and then opens the commitment to $R$.
    \item $R$ receives $b$ from the opening, checks the commitment, and both
        parties compute and output $flip = b \oplus b'$.
\end{enumerate}

We test this protocol under composition for the following relationship:
$$\m{execUC} \; \Z \, \A, \pi_\m{lotto} \circ \pi_\m{coin} \, !\F_\m{com} \, \sim$$ 
$$\m{execUC} \; \Z \, (\Sim := \Sim_\m{coin}) \, \pi_\m{lotto} \, !\F_\m{coin}$$
As we expect, our fuzzer is trivially able to find a distinguishing environment
for this protocol that results in a \emph{liveness failure} caused by a
\emph{fairness bug} in the real world protocol. There is an information asymmetry 
in the protocol where the byzantine committing party always learns the output of the flip
(it knows $R$'s $b'$ and its own $b$) first, and it can refuse to ever open its commitment
if it doesn't like the outcome.

Requiring both parties to commit to a bit also doesn't overcome the information assymetry.

\paragraph{Iteration: Security with Abort}
We patch this fix by forcing the byzantine party to be explicit about aborting the protocol
by sending
honest party an \m{abort} message (a standard practice in UC based literature~\cite{common, abort, defs}
and is enforceable in a system where financial incentives are at play).  
The new protocol adds a step between 3 and 4 where party $R$ waits for
the commitment opening or an abort message from $S$.  On \m{abort}, the honest
$R$ locally computes a coin flip $c \xleftarrow{\$} \{0,1\}$ and outputs it as
the result of the protocol, thus ensuring that honest parties always output a
result and the output is the result of a real local coin flip.
Performing the same experiment again with an adapted simulator
$\Sim'_\m{coin}$, our fuzzer no longer finds a liveness error but now asserts another failure.  Despite solving the issue
of fairness, the new protocol now fails the other desired property: a uniform 
output distribution when $S$ aborts the protocols despite the local coin flip over many runs of the protocol.
It is a non-obvious failure, but careful study of the protocol
confirms the bug. Imagine $S$ has 
preference $c$ and aborts whenever $b \oplus b' = \neg c$.
The additional local flip by $R$ makes it so that two coin flips have to result in $c$ for it to be the output, and only 1 (between $S$ and $R$) for $\neg c$.
Therefore, $P(c) = \frac{1}{4}$ and $P(\neg c) = \frac{3}{4}$.
This failure propagates up to the lottery protocol where the fuzzer observes the $P(p_i \text{ winner}) \neq \frac{1}{n}$.
% NOTE: failures can be anything but k corrupt means we tolerate k/n prob the adv wins

\paragraph{Iteration: Move Away from 2-Party Coin Flips}
Implementing the above protocols, and the asociated failures we found, makes it clear that the information assymetry can't be overcome in a 2-party coin flip unless the network can enforce some kind of fair exchange between the two parties.
This result, inferred from the outcomes of the above experiments, conforms to the current theoretical understanding of the limitations of two-party coin flips~\cite{two, party, coin, results}.
This means we must either except a certain amount of bias in the result of the coin flip, a bias of $\Omega (1/4)$~\cite{cleve, and the others}, and the lottery that uses it, or search for another primitive to construct the lottery out of. 


It is clear from reviewing the cause of the failure of the above experiment that 2-party coin flips will always result in a distribution failure as a result of one party learning the output before the other.
Naive attempts at fixing this, like requiring both parties to commit to their bits, results in similar failures.
Instead, we opt for an ideal functionality that ideally allows abort with the functionality in Figure~\ref{fig:fcoinabort}.

\begin{figure}
\centering
\input{figures/f_flip_abort}
\caption{A coin flip where the adversary can abort...}
\label{fig:fcoinabort}
\end{figure}

\paragraph{More Complex Protocols}
We perform similar experiments on the ABA protocol, where we replace the ideal
common coin with a biased one, and observe that our fuzzer is able to relate
the distribution of the inputs to the distribution of outputs in both worlds
and reliably distinguish between them.  In general, we conclude that the
adversarial model defined by UC allows fuzzing to find distinguishing
environments which exploit subtle flaws around fairness and bias for individual
protocols as well as across composition for protocols that rely on such
primitives. 

\begin{figure*}
\centering
\input{figures/coin_table}
\end{figure*}


\plan{TODO: concluding paragraph}

%The lottery protocol described by the ideal functionality $\F_\m{lotto}$ in Figure~\ref{fig:flotto} has the environment provide the protocol with full information about the pair-wise coin flips and the winners.
%This deviates from a typical lottery ideal functionality where such information is determined within the protocol, between the protocol parties, but we simplify it to remove unnecessary communication complexity. 
%$\F_\m{lotto}$ also permits a single byzantine party in the set. 
%More byzantine parties can be permitted, but if the adversary wins it doesn't matter which party wins.
%A $\frac{1}{3}$ dishonest set can also be considered without changing the results because $\F_\m{coin}$ ensures the coin flip is unbiased.
%
%The lottery protocol proceeds as follows. 
%The $n$ parties in the protocol are informed about the pair-wise coin flips they will be participating in.
%Once the first round of coin flips finishes, the environment learns the winners of each coin flip and again gives input for the new pair-wise coin flips.
%This continues until the final coin flip at which point the winning party outputs that they have won the lottery.

%The financial incentives involved in the protocol require development frameworks that can express and analyze these properties.
%Importantly, modular design by relying on software packages is necessary, and UC allows the abstraction to be represented by ideal functionalities.
%In the same way that theoretical definitionsr rely on ideal functionalities for assumptions such as authenticated communication, implementation with ideal functionalities is an important feature.
%Simply allowing design in this way isn't meaningful without the ability to analyze protocols across composition and the replacement of ideal functionalities with protocols that attempt to realize them.
%So far we can apply analysis techniques to prove emulation, but doing so across composition remains to be validated.
%\todo{iron out the right lottery protocol}

%UC tells us that we can compose and arbitrary number of instances of \Fflip in order to realize a lottery.
%At a high level, our protocol \prot{lotto}, flips $\log n$ pair-wise coins in order to choose one of $n$ parties as the winner. 
%\todo{should the lottery property only be that the prob of win is 1/(|honest| + 1)? because we don't care which adverasry wins?}


%\paragraph{The Ideal Coin Flip}
%In Figure~\ref{fig:fcoin} we show the ideal functionality for a coin flip. 
%The coin flip specifies that both parties must initiate the flip, and that the adversary can have no influence on the bias of the output bit.
%Unlike the eventual delivery guarantees we discuss for async protocol, the functionality allows the adversary to decide which of the two parties, if any, receive the result.
%This means that $\F_\m{flip}$ allows protocols that are \emph{not fair}: they do no guarantee that if one party receives output all parties eventually receive the output. 
%\begin{figure}
%\centering
%\input{figures/f_flip}
%\caption{Ideal coin flip that guarantees $P[0] = P[1] = \frac{1}{2}$ but does not guarantee fairness.}
%\label{fig:fcoin}
%\end{figure}
%\todo{It is a known result that no coin flip protocol with n/2 corruptions is unbiased, what do say about that?}


%The first protocols and primitives we examine are distributed coin flipping. 
%Both as protocols and primitives assumed in other protocols, coin tossing is is an integral part of many distributed byzantine protocols, each relying on slightly different assumptions and fault models. 
%They are a simple functionality, but they express and rely on properties such as output fairness and adversarial influence, that UC is uniquely suitable for expressing and reasoning about.
%In this section, we apply our methods to a lottery protocol built atom a two-party coin tossing primitive, and show that, despite knowledge of the aforementioned bug in the old MMR protocol our methods are capable of giving meaningful feedback to the programmer suggesting a possible liveness error \footnote{Recall we employ informal methods for analyzing the protocols in this work, and, especially for liveness, can suggest possible liveness failures rather than assert them directly without knowledge of a useful predicate on the execution.}.
%
%We focus the work in this section particularly on analyzing coin tossing across layered composition, and do this for three reasons. 
%First, we believe that coin tossing is a strong representative example of the kinds of analysis possible in UC which we want to show can be meaningfully analyzed informally as well.
%Second, the assumed primitives across different dirstributed protocols can vary subtley, and, if not carefully analyzed, can be disastrous for the protocols that use them.
%The most prominent example of this is in the original publication of the well-known byzantine agreement protocol by  Mostefaoui et al.~\cite{mmrog} (referred to as the MMR protocol from here on out).
%A work similar our own ~\cite{byzbymc}, identified a critical liveness bug that arose, because the protocol relied weak common coin that allowed the adversary to see the outcome of the coin in advance of some honest parties rather than the perfect common coin that the protocol actually required in order to terminate. 
%Third, software dependencies in this setting is analgous to layered composition. 
%Software packages are represented by ideal functionaliteis for development, and replaced with the underlying protocol that implements it.
%Testing and identifying failures arising from dependencies that either don't realize the ideal functionality or are subtley different from the assumptions expected by the application is an important capabality for the viability of our proposition in this paper. 
%
%
%\todo{keep or don't keep this, we might have this in an earlier section}
%Simple examples like 2-party computation, desired properties can often be deeply interconncted such that specifying them as a list of satisfiable assertion is difficult. 
%In the simplest case of two parties computing a function, notions of correctness and secrecy are connected, for example, to the choice of function being computed, what an adversary can learn about the other party's inputs before choosing its own, or what distributions do the adversary's input or the protocol's output exhibit. 
%In more complex protocols we desired the analysis of properties that define notions of fairness or input availability.
%Specifying these properties in a laundry list of properties can be cumbersome and error-prone, and the ideal functionality model allows expressing arbitrary properties as a computational unit.
%Rather than proving specific assertions hold, UC defines security in relation to an idealized version that exhibits the desired properties implicitly.
%A coin flipping protocols, references throughout this work, is a core subcomponent of many asynchronous distributed protocols, and is a useful case study for examing our implementation.
%
%\subsection{Flipping Fairness}V
%The first example we study is building a lottery protocol off a two-party coin tossing protocol.
%Protocols like Blum's allow two mutually distrustful parties to flip a coin over the telephone protocol, and ensures an unbiased coin only when the adversary does not prematurely abort the protocol.
%Lottery protocols are more modern uses of coin flipping that highlight the influence adversaries can have in determining the output.
%In most agreement protocols, the value of a coin flip isn't as important as long as all parties observe the same outcome.
%In distributed protocols that operate with financial incentives, the lottery being the simplest example of one, this property becomes critically important. 
%The example presented here \todo{finish}
%%Flipping a coin involving several parties is a common coin protocol: a more complex and still widely used primitive in modern agreement protocols.
%%They are used heavily even in modern agreement protocols that operate under the strong common coin assumption: in some round all parties observe the same coin flip. 
%%This relatively straightforward example protocol exhibits many properties that, traditionally, UC is adept at modelling and analyzing like fairness, input availability, and adversarial influence on outcomes.
%%In this section we use this example to demonstrate that our implementation can express such a protocol, allow for analysis of properties like fairness and input availabiltiy, and detect failrue accross composition. \todo{this last sentence needs some work, maybe mention that we compose with the lottery here?}.
%
%
%
%\subsection{Common Coins}
%Many agreement protocols rely on common coins to introduce shared randomness into protocol to allow protocol parties to make common decisions without adversarial influence.
%Common coins definitions vary in their guarantees of output fairness, corruption threshold, and adversarial influence on the output bit.
%The protocols that use common coins are prone to using them incorrectly, as we see in the case of the original MMR agreement protocol where the common coin assumption was shown in \cite{formalbyz} to be to weak and permitted a liveness fault.
%As we describe in the lottery protocol above, and in mode complex distributed protocol, 
%
%The strongest assumtpion is a perfect common coin
