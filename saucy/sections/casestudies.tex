% Emphasize that this is to assert that adapting existing dev techniques to UC is possible, can aid
% devs, catch errors
In this section we work through three case studies of engineering different byazntine agreement protocols, applying fuzz testing, a method of property-based testing that involves generating random inputs and checking output against a spec, techniques to UC implementations of byzantine protocols in our implementation and showcase its compaibility with UC at a fundamental level.

The protocols in question are: the simple, yet very well-known, Bracha broadcast~\cite{bracha}, a toy research protocol by Ben-Or~\cite{benor}, and a modern optimization of the well-known ABA protocol by Mostefaoui, Moumen, and Raynal~\cite{mmr,aba} (referred to as MMR).

% Method injecting faults
\subsection{Fuzzing}
Fuzz testing is our chosen apparatus for several reasons. The main reason is that it is a widely used and very successful software engineering tool.
As mentioned previously, some existing work around tooling for UC takes advantage of symbolic execution to aid in proving security or detecting distinguishing states in a protocol.
Fuzz testing has been shown to be as good, if not better, than such techniques at detecting bugs.
Comparatively, it provides an informal security guarantee because it can detect bugs but not rule them out.
Even so, showing the adaptability of UC and fuzz-testing for byzantine protocols establishes a foundation for casting UC as useful outside of esoteric academic use and transalatable to real implementations and engineering \todo{<< this is one of the "tag lines" of this paper and must be refined through iteration.}.
Furthermore, writing environments and testing UC definitions is a manual operation and requires a very large effort to carefully explore cases for validating a proof. This is exaacerbated for larger protocols with lots of parties that last over many rounds. 
Exploring these corner cases is a natural fit for fuzz testing: advantageous as both a development framework and a tool to aid verification and validation of literature.

We show in this case study that a reasonable type system goes a long way in enabling useful fuzz testing, that the environment-execution abstraction for UC experiments is a useful structure for generating test cases, and that the ideal functionality model makes state space searching more tractable while UC composition security bears the load of testing boundaries accross trust boundaries\todo{maybe get a better word to state this than "trust boundarie". I'm trying to refer to testing places where different code interats}.

\subsection{Checking Properties}
UC limits what is learned about a protocol to what messages the environment receives from honest parties and the adversary (which is controls).
Unlike more complicated state-aware fuzzers, there is no reference or spec to compare a protocol against other than an ideal functionality.
For byzantine agreement protocols, the important properties are safety and liveness, however other itermediate properties are also expressible through ideal functionalities, for example:
\begin{itemize}
\item only values proposed by an honest party can be decided
\item if all parties input the same value, they decide in one round 
\end{itemize}
